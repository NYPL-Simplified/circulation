
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>core.external_search &#8212; Library Simplified Circulation Manager  documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for core.external_search</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">nose.tools</span> <span class="kn">import</span> <span class="n">set_trace</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">elasticsearch</span> <span class="kn">import</span> <span class="n">Elasticsearch</span>
<span class="kn">from</span> <span class="nn">elasticsearch.helpers</span> <span class="kn">import</span> <span class="n">bulk</span> <span class="k">as</span> <span class="n">elasticsearch_bulk</span>
<span class="kn">from</span> <span class="nn">elasticsearch.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">RequestError</span><span class="p">,</span>
    <span class="n">ElasticsearchException</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">elasticsearch_dsl</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Index</span><span class="p">,</span>
    <span class="n">MultiSearch</span><span class="p">,</span>
    <span class="n">Search</span><span class="p">,</span>
    <span class="n">SF</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">elasticsearch_dsl.query</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Bool</span><span class="p">,</span>
    <span class="n">DisMax</span><span class="p">,</span>
    <span class="n">Exists</span><span class="p">,</span>
    <span class="n">FunctionScore</span><span class="p">,</span>
    <span class="n">Match</span><span class="p">,</span>
    <span class="n">MatchAll</span><span class="p">,</span>
    <span class="n">MatchNone</span><span class="p">,</span>
    <span class="n">MatchPhrase</span><span class="p">,</span>
    <span class="n">MultiMatch</span><span class="p">,</span>
    <span class="n">Nested</span><span class="p">,</span>
    <span class="n">Query</span> <span class="k">as</span> <span class="n">BaseQuery</span><span class="p">,</span>
    <span class="n">SimpleQueryString</span><span class="p">,</span>
    <span class="n">Term</span><span class="p">,</span>
    <span class="n">Terms</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">spellchecker</span> <span class="kn">import</span> <span class="n">SpellChecker</span>

<span class="kn">from</span> <span class="nn">flask_babel</span> <span class="kn">import</span> <span class="n">lazy_gettext</span> <span class="k">as</span> <span class="n">_</span>
<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Configuration</span><span class="p">,</span>
    <span class="n">CannotLoadConfiguration</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">classifier</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">KeywordBasedClassifier</span><span class="p">,</span>
    <span class="n">GradeLevelClassifier</span><span class="p">,</span>
    <span class="n">AgeClassifier</span><span class="p">,</span>
    <span class="n">Classifier</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">facets</span> <span class="kn">import</span> <span class="n">FacetConstants</span>
<span class="kn">from</span> <span class="nn">metadata_layer</span> <span class="kn">import</span> <span class="n">IdentifierData</span>
<span class="kn">from</span> <span class="nn">model</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">numericrange_to_tuple</span><span class="p">,</span>
    <span class="n">Collection</span><span class="p">,</span>
    <span class="n">Contributor</span><span class="p">,</span>
    <span class="n">ConfigurationSetting</span><span class="p">,</span>
    <span class="n">DataSource</span><span class="p">,</span>
    <span class="n">Edition</span><span class="p">,</span>
    <span class="n">ExternalIntegration</span><span class="p">,</span>
    <span class="n">Identifier</span><span class="p">,</span>
    <span class="n">Library</span><span class="p">,</span>
    <span class="n">Work</span><span class="p">,</span>
    <span class="n">WorkCoverageRecord</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">lane</span> <span class="kn">import</span> <span class="n">Pagination</span>
<span class="kn">from</span> <span class="nn">monitor</span> <span class="kn">import</span> <span class="n">WorkSweepMonitor</span>
<span class="kn">from</span> <span class="nn">coverage</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CoverageFailure</span><span class="p">,</span>
    <span class="n">WorkPresentationProvider</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">problem_details</span> <span class="kn">import</span> <span class="n">INVALID_INPUT</span>
<span class="kn">from</span> <span class="nn">selftest</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">HasSelfTests</span><span class="p">,</span>
    <span class="n">SelfTestResult</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">util.personal_names</span> <span class="kn">import</span> <span class="n">display_name_to_sort_name</span>
<span class="kn">from</span> <span class="nn">util.problem_detail</span> <span class="kn">import</span> <span class="n">ProblemDetail</span>
<span class="kn">from</span> <span class="nn">util.stopwords</span> <span class="kn">import</span> <span class="n">ENGLISH_STOPWORDS</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">time</span>

<div class="viewcode-block" id="mock_search_index"><a class="viewcode-back" href="../../core.html#core.external_search.mock_search_index">[docs]</a><span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">mock_search_index</span><span class="p">(</span><span class="n">mock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Temporarily mock the ExternalSearchIndex implementation</span>
<span class="sd">    returned by the load() class method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ExternalSearchIndex</span><span class="o">.</span><span class="n">MOCK_IMPLEMENTATION</span> <span class="o">=</span> <span class="n">mock</span>
        <span class="k">yield</span> <span class="n">mock</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">ExternalSearchIndex</span><span class="o">.</span><span class="n">MOCK_IMPLEMENTATION</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="ExternalSearchIndex"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex">[docs]</a><span class="k">class</span> <span class="nc">ExternalSearchIndex</span><span class="p">(</span><span class="n">HasSelfTests</span><span class="p">):</span>

    <span class="n">NAME</span> <span class="o">=</span> <span class="n">ExternalIntegration</span><span class="o">.</span><span class="n">ELASTICSEARCH</span>

    <span class="c1"># A test may temporarily set this to a mock of this class.</span>
    <span class="c1"># While that&#39;s true, load() will return the mock instead of</span>
    <span class="c1"># instantiating new ExternalSearchIndex objects.</span>
    <span class="n">MOCK_IMPLEMENTATION</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">WORKS_INDEX_PREFIX_KEY</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;works_index_prefix&#39;</span>
    <span class="n">DEFAULT_WORKS_INDEX_PREFIX</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;circulation-works&#39;</span>

    <span class="n">TEST_SEARCH_TERM_KEY</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;test_search_term&#39;</span>
    <span class="n">DEFAULT_TEST_SEARCH_TERM</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;test&#39;</span>

    <span class="n">work_document_type</span> <span class="o">=</span> <span class="s1">&#39;work-type&#39;</span>
    <span class="n">__client</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">CURRENT_ALIAS_SUFFIX</span> <span class="o">=</span> <span class="s1">&#39;current&#39;</span>
    <span class="n">VERSION_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;-v([0-9]+)$&#39;</span><span class="p">)</span>

    <span class="n">SETTINGS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span> <span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="n">ExternalIntegration</span><span class="o">.</span><span class="n">URL</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;URL&quot;</span><span class="p">),</span> <span class="s2">&quot;required&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="s2">&quot;url&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="n">WORKS_INDEX_PREFIX_KEY</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Index prefix&quot;</span><span class="p">),</span>
          <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="n">DEFAULT_WORKS_INDEX_PREFIX</span><span class="p">,</span>
          <span class="s2">&quot;required&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
          <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Any Elasticsearch indexes needed for this application will be created with this unique prefix. In most cases, the default will work fine. You may need to change this if you have multiple application servers using a single Elasticsearch server.&quot;</span><span class="p">)</span>
        <span class="p">},</span>
        <span class="p">{</span> <span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="n">TEST_SEARCH_TERM_KEY</span><span class="p">,</span>
          <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Test search term&quot;</span><span class="p">),</span>
          <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="n">DEFAULT_TEST_SEARCH_TERM</span><span class="p">,</span>
          <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Self tests will use this value as the search term.&quot;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">]</span>

    <span class="n">SITEWIDE</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ExternalSearchIndex.reset"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.reset">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the __client object to None so a new configuration</span>
<span class="sd">        can be applied during object initialization.</span>

<span class="sd">        This method is only intended for use in testing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__client</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.search_integration"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.search_integration">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">search_integration</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_db</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look up the ExternalIntegration for ElasticSearch.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ExternalIntegration</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span>
            <span class="n">_db</span><span class="p">,</span> <span class="n">ExternalIntegration</span><span class="o">.</span><span class="n">ELASTICSEARCH</span><span class="p">,</span>
            <span class="n">goal</span><span class="o">=</span><span class="n">ExternalIntegration</span><span class="o">.</span><span class="n">SEARCH_GOAL</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.works_prefixed"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.works_prefixed">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">works_prefixed</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_db</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prefix the given value with the prefix to use when generating index</span>
<span class="sd">        and alias names.</span>

<span class="sd">        :return: A string &quot;{prefix}-{value}&quot;, or None if no prefix is configured.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">integration</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">search_integration</span><span class="p">(</span><span class="n">_db</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">integration</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">setting</span> <span class="o">=</span> <span class="n">integration</span><span class="o">.</span><span class="n">setting</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">WORKS_INDEX_PREFIX_KEY</span><span class="p">)</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">setting</span><span class="o">.</span><span class="n">value_or_default</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">DEFAULT_WORKS_INDEX_PREFIX</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="n">value</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.works_index_name"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.works_index_name">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">works_index_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_db</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look up the name of the search index.</span>

<span class="sd">        It&#39;s possible, but unlikely, that the search index alias will</span>
<span class="sd">        point to some other index. But if there were no indexes, and a</span>
<span class="sd">        new one needed to be created, this would be the name of that</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">works_prefixed</span><span class="p">(</span><span class="n">_db</span><span class="p">,</span> <span class="n">CurrentMapping</span><span class="o">.</span><span class="n">version_name</span><span class="p">())</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.works_alias_name"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.works_alias_name">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">works_alias_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_db</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look up the name of the search index alias.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">works_prefixed</span><span class="p">(</span><span class="n">_db</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">CURRENT_ALIAS_SUFFIX</span><span class="p">)</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.load"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.load">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_db</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load a generic implementation.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">MOCK_IMPLEMENTATION</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">MOCK_IMPLEMENTATION</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_db</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_db</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">works_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">test_search_term</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">in_testing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor</span>

<span class="sd">        :param in_testing: Set this to true if you don&#39;t want an</span>
<span class="sd">        Elasticsearch client to be created, e.g. because you&#39;re</span>
<span class="sd">        running a unit test of the constructor.</span>


<span class="sd">        :param mapping: A custom Mapping object, for use in unit tests. By</span>
<span class="sd">        default, the most recent mapping will be instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;External search index&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">works_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">works_alias</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">integration</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">mapping</span> <span class="ow">or</span> <span class="n">CurrentMapping</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">ExternalIntegration</span><span class="p">):</span>
            <span class="c1"># This is how the self-test initializes this object.</span>
            <span class="n">integration</span> <span class="o">=</span> <span class="n">url</span>
            <span class="n">url</span> <span class="o">=</span> <span class="n">integration</span><span class="o">.</span><span class="n">url</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_db</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CannotLoadConfiguration</span><span class="p">(</span>
                <span class="s2">&quot;Cannot load Elasticsearch configuration without a database.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">works_index</span><span class="p">:</span>
            <span class="n">integration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_integration</span><span class="p">(</span><span class="n">_db</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">integration</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CannotLoadConfiguration</span><span class="p">(</span>
                    <span class="s2">&quot;No Elasticsearch integration configured.&quot;</span>
                <span class="p">)</span>
            <span class="n">url</span> <span class="o">=</span> <span class="n">url</span> <span class="ow">or</span> <span class="n">integration</span><span class="o">.</span><span class="n">url</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">works_index</span><span class="p">:</span>
                <span class="n">works_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">works_index_name</span><span class="p">(</span><span class="n">_db</span><span class="p">)</span>
            <span class="n">test_search_term</span> <span class="o">=</span> <span class="n">integration</span><span class="o">.</span><span class="n">setting</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">TEST_SEARCH_TERM_KEY</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">url</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CannotLoadConfiguration</span><span class="p">(</span>
                <span class="s2">&quot;No URL configured to Elasticsearch server.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_search_term</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">test_search_term</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_TEST_SEARCH_TERM</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_testing</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ExternalSearchIndex</span><span class="o">.</span><span class="n">__client</span><span class="p">:</span>
                <span class="n">use_ssl</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;https://&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Connecting to index </span><span class="si">%s</span><span class="s2"> in Elasticsearch cluster at </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">works_index</span><span class="p">,</span> <span class="n">url</span>
                <span class="p">)</span>
                <span class="n">ExternalSearchIndex</span><span class="o">.</span><span class="n">__client</span> <span class="o">=</span> <span class="n">Elasticsearch</span><span class="p">(</span>
                    <span class="n">url</span><span class="p">,</span> <span class="n">use_ssl</span><span class="o">=</span><span class="n">use_ssl</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">25</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="o">.</span><span class="n">indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="o">.</span><span class="n">index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="o">.</span><span class="n">delete</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="o">.</span><span class="n">exists</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">put_script</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="o">.</span><span class="n">put_script</span>

        <span class="c1"># Sets self.works_index and self.works_alias values.</span>
        <span class="c1"># Document upload runs against the works_index.</span>
        <span class="c1"># Search queries run against works_alias.</span>
        <span class="k">if</span> <span class="n">works_index</span> <span class="ow">and</span> <span class="n">integration</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">in_testing</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_works_index_and_alias</span><span class="p">(</span><span class="n">_db</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">RequestError</span><span class="p">:</span>
                <span class="c1"># This is almost certainly a problem with our code,</span>
                <span class="c1"># not a communications error.</span>
                <span class="k">raise</span>
            <span class="k">except</span> <span class="n">ElasticsearchException</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CannotLoadConfiguration</span><span class="p">(</span>
                    <span class="s2">&quot;Exception communicating with Elasticsearch server: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                    <span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">search</span> <span class="o">=</span> <span class="n">Search</span><span class="p">(</span><span class="n">using</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">works_alias</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">bulk</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">elasticsearch_bulk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="p">,</span> <span class="n">docs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bulk</span> <span class="o">=</span> <span class="n">bulk</span>

<div class="viewcode-block" id="ExternalSearchIndex.set_works_index_and_alias"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.set_works_index_and_alias">[docs]</a>    <span class="k">def</span> <span class="nf">set_works_index_and_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_db</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds or creates the works_index and works_alias based on</span>
<span class="sd">        the current configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The index name to use is the one known to be right for this</span>
        <span class="c1"># version.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">works_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="o">.</span><span class="n">works_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">works_index_name</span><span class="p">(</span><span class="n">_db</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">works_index</span><span class="p">):</span>
            <span class="c1"># That index doesn&#39;t actually exist. Set it up.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_index</span><span class="p">()</span>

        <span class="c1"># Make sure the alias points to the most recent index.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup_current_alias</span><span class="p">(</span><span class="n">_db</span><span class="p">)</span>

        <span class="c1"># Make sure the stored scripts for the latest mapping exist.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_stored_scripts</span><span class="p">()</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.setup_current_alias"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.setup_current_alias">[docs]</a>    <span class="k">def</span> <span class="nf">setup_current_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_db</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds or creates the works_alias as named by the current site</span>
<span class="sd">        settings.</span>

<span class="sd">        If the resulting alias exists and is affixed to a different</span>
<span class="sd">        index or if it can&#39;t be generated for any reason, the alias will</span>
<span class="sd">        not be created or moved. Instead, the search client will use the</span>
<span class="sd">        the works_index directly for search queries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alias_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">works_alias_name</span><span class="p">(</span><span class="n">_db</span><span class="p">)</span>
        <span class="n">alias_is_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">exists_alias</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">alias_name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_use_as_works_alias</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">works_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="o">.</span><span class="n">works_alias</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">if</span> <span class="n">alias_is_set</span><span class="p">:</span>
            <span class="c1"># The alias exists on the Elasticsearch server, so it must</span>
            <span class="c1"># point _somewhere.</span>
            <span class="n">exists_on_works_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">exists_alias</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">works_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">alias_name</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">exists_on_works_index</span><span class="p">:</span>
                <span class="c1"># It points to the index we were expecting it to point to.</span>
                <span class="c1"># Use it.</span>
                <span class="n">_use_as_works_alias</span><span class="p">(</span><span class="n">alias_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The alias exists but it points somewhere we didn&#39;t</span>
                <span class="c1"># expect. Rather than changing how the alias works and</span>
                <span class="c1"># then using the alias, use the index directly instead</span>
                <span class="c1"># of going through the alias.</span>
                <span class="n">_use_as_works_alias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">works_index</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Create the alias and search against it.</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">put_alias</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">works_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">alias_name</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">response</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;acknowledged&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Alias &#39;</span><span class="si">%s</span><span class="s2">&#39; could not be created&quot;</span><span class="p">,</span> <span class="n">alias_name</span><span class="p">)</span>
            <span class="c1"># Work against the index instead of an alias.</span>
            <span class="n">_use_as_works_alias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">works_index</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">_use_as_works_alias</span><span class="p">(</span><span class="n">alias_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.setup_index"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.setup_index">[docs]</a>    <span class="k">def</span> <span class="nf">setup_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">index_settings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the search index with appropriate mapping.</span>

<span class="sd">        This will destroy the search index, and all works will need</span>
<span class="sd">        to be indexed again. In production, don&#39;t use this on an</span>
<span class="sd">        existing index. Use it to create a new index, then change the</span>
<span class="sd">        alias to point to the new index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index_name</span> <span class="o">=</span> <span class="n">new_index</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">works_index</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">index_name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Deleting index </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">index_name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Creating index </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index_name</span><span class="p">)</span>
        <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">body</span><span class="p">()</span>
        <span class="n">body</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;settings&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">index_settings</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index_name</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="n">body</span><span class="p">)</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.set_stored_scripts"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.set_stored_scripts">[docs]</a>    <span class="k">def</span> <span class="nf">set_stored_scripts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">definition</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">stored_scripts</span><span class="p">():</span>
            <span class="c1"># Make sure the name of the script is scoped and versioned.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;simplified.&quot;</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">script_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="c1"># If only the source code was provided, configure it as a</span>
            <span class="c1"># Painless script.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">definition</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
                <span class="n">definition</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">script</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">lang</span><span class="o">=</span><span class="s2">&quot;painless&quot;</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">definition</span><span class="p">))</span>

            <span class="c1"># Put it in the database.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">put_script</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">definition</span><span class="p">)</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.transfer_current_alias"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.transfer_current_alias">[docs]</a>    <span class="k">def</span> <span class="nf">transfer_current_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_db</span><span class="p">,</span> <span class="n">new_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Force -current alias onto a new index&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Index &#39;</span><span class="si">%s</span><span class="s2">&#39; does not exist on this client.&quot;</span> <span class="o">%</span> <span class="n">new_index</span><span class="p">)</span>

        <span class="n">current_base_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_index_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">works_index</span><span class="p">)</span>
        <span class="n">new_base_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_index_name</span><span class="p">(</span><span class="n">new_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_base_name</span> <span class="o">!=</span> <span class="n">current_base_name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;Index &#39;</span><span class="si">%s</span><span class="s2">&#39; is not in series with current index &#39;</span><span class="si">%s</span><span class="s2">&#39;. &quot;</span>
                 <span class="s2">&quot;Confirm the base name (without version number) of both indices&quot;</span>
                 <span class="s2">&quot;is the same.&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">works_index</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">works_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="o">.</span><span class="n">works_index</span> <span class="o">=</span> <span class="n">new_index</span>
        <span class="n">alias_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">works_alias_name</span><span class="p">(</span><span class="n">_db</span><span class="p">)</span>

        <span class="n">exists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">exists_alias</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">alias_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">:</span>
            <span class="c1"># The alias doesn&#39;t already exist. Set it.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_current_alias</span><span class="p">(</span><span class="n">_db</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># We know the alias already exists. Before we set it to point</span>
        <span class="c1"># to self.works_index, we may need to remove it from some</span>
        <span class="c1"># other indices.</span>
        <span class="n">other_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">get_alias</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">alias_name</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">works_index</span> <span class="ow">in</span> <span class="n">other_indices</span><span class="p">:</span>
            <span class="c1"># If the alias already points to the works index,</span>
            <span class="c1"># that&#39;s fine -- we want to see if it points to any</span>
            <span class="c1"># _other_ indices.</span>
            <span class="n">other_indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">works_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">other_indices</span><span class="p">:</span>
            <span class="c1"># The alias exists on one or more other indices.  Remove</span>
            <span class="c1"># the alias altogether, then put it back on the works</span>
            <span class="c1"># index.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">delete_alias</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s1">&#39;_all&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">alias_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">put_alias</span><span class="p">(</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">works_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">alias_name</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">works_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="o">.</span><span class="n">works_alias</span> <span class="o">=</span> <span class="n">alias_name</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.base_index_name"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.base_index_name">[docs]</a>    <span class="k">def</span> <span class="nf">base_index_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_or_alias</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes version or current suffix from base index name&quot;&quot;&quot;</span>

        <span class="n">current_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CURRENT_ALIAS_SUFFIX</span><span class="o">+</span><span class="s1">&#39;$&#39;</span><span class="p">)</span>
        <span class="n">base_works_index</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">current_re</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">index_or_alias</span><span class="p">)</span>
        <span class="n">base_works_index</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">VERSION_RE</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">base_works_index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">base_works_index</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.create_search_doc"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.create_search_doc">[docs]</a>    <span class="k">def</span> <span class="nf">create_search_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">pagination</span><span class="p">,</span>
                          <span class="n">debug</span><span class="p">):</span>

        <span class="n">query</span> <span class="o">=</span> <span class="n">Query</span><span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="p">)</span>
        <span class="n">search</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">,</span> <span class="n">pagination</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">explain</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">filter</span><span class="o">.</span><span class="n">min_score</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">min_score</span><span class="o">=</span><span class="nb">filter</span><span class="o">.</span><span class="n">min_score</span><span class="p">)</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="c1"># Don&#39;t restrict the fields at all -- get everything.</span>
            <span class="c1"># This makes it easy to investigate everything about the</span>
            <span class="c1"># results we do get.</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># All we absolutely need is the work ID, which is a</span>
            <span class="c1"># key into the database, plus the values of any script fields,</span>
            <span class="c1"># which represent data not available through the database.</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;work_id&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">filter</span><span class="p">:</span>
                <span class="n">fields</span> <span class="o">+=</span> <span class="nb">filter</span><span class="o">.</span><span class="n">script_fields</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># Change the Search object so it only retrieves the fields</span>
        <span class="c1"># we&#39;re asking for.</span>
        <span class="k">if</span> <span class="n">fields</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">search</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.query_works"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.query_works">[docs]</a>    <span class="k">def</span> <span class="nf">query_works</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pagination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run a search query.</span>

<span class="sd">        This works by calling query_works_multi().</span>

<span class="sd">        :param query_string: The string to search for.</span>
<span class="sd">        :param filter: A Filter object, used to filter out works that</span>
<span class="sd">            would otherwise match the query string.</span>
<span class="sd">        :param pagination: A Pagination object, used to get a subset</span>
<span class="sd">            of the search results.</span>
<span class="sd">        :param debug: If this is True, debugging information will</span>
<span class="sd">            be gathered and logged. The search query will ask</span>
<span class="sd">            ElasticSearch for all available fields, not just the</span>
<span class="sd">            fields known to be used by the feed generation code.  This</span>
<span class="sd">            all comes at a slight performance cost.</span>
<span class="sd">        :return: A list of Hit objects containing information about</span>
<span class="sd">            the search results. This will include the values of any</span>
<span class="sd">            script fields calculated by ElasticSearch during the</span>
<span class="sd">            search process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="n">Filter</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">filter</span><span class="o">.</span><span class="n">match_nothing</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># We already know this search should match nothing.  We</span>
            <span class="c1"># don&#39;t even need to perform the search.</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">pagination</span> <span class="o">=</span> <span class="n">pagination</span> <span class="ow">or</span> <span class="n">Pagination</span><span class="o">.</span><span class="n">default</span><span class="p">()</span>
        <span class="n">query_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">pagination</span><span class="p">)</span>
        <span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_works_multi</span><span class="p">([</span><span class="n">query_data</span><span class="p">],</span> <span class="n">debug</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.query_works_multi"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.query_works_multi">[docs]</a>    <span class="k">def</span> <span class="nf">query_works_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queries</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run several queries simultaneously and return the results</span>
<span class="sd">        as a big list.</span>

<span class="sd">        :param queries: A list of (query string, Filter, Pagination) 3-tuples,</span>
<span class="sd">            each representing an Elasticsearch query to be run.</span>

<span class="sd">        :yield: A sequence of lists, one per item in `queries`,</span>
<span class="sd">            each containing the search results from that</span>
<span class="sd">            (query string, Filter, Pagination) 3-tuple.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the works alias is not set, all queries return empty.</span>
        <span class="c1">#</span>
        <span class="c1"># TODO: Maybe an unset works_alias should raise</span>
        <span class="c1"># CannotLoadConfiguration in the constructor. Then we wouldn&#39;t</span>
        <span class="c1"># have to worry about this.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">works_alias</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">[]</span>

        <span class="c1"># Create a MultiSearch.</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiSearch</span><span class="p">(</span><span class="n">using</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__client</span><span class="p">)</span>

        <span class="c1"># Give it a Search object for every query definition passed in</span>
        <span class="c1"># as part of `queries`.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">pagination</span><span class="p">)</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_search_doc</span><span class="p">(</span>
                <span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="nb">filter</span><span class="p">,</span> <span class="n">pagination</span><span class="o">=</span><span class="n">pagination</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span>
            <span class="p">)</span>
            <span class="n">function_scores</span> <span class="o">=</span> <span class="nb">filter</span><span class="o">.</span><span class="n">scoring_functions</span> <span class="k">if</span> <span class="nb">filter</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">function_scores</span><span class="p">:</span>
                <span class="n">function_score</span> <span class="o">=</span> <span class="n">FunctionScore</span><span class="p">(</span>
                    <span class="n">query</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">match_all</span><span class="o">=</span><span class="nb">dict</span><span class="p">()),</span>
                    <span class="n">functions</span><span class="o">=</span><span class="n">function_scores</span><span class="p">,</span>
                    <span class="n">score_mode</span><span class="o">=</span><span class="s2">&quot;sum&quot;</span>
                <span class="p">)</span>
                <span class="n">search</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">function_score</span><span class="p">)</span>
            <span class="n">multi</span> <span class="o">=</span> <span class="n">multi</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">search</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># NOTE: This is the code that actually executes the ElasticSearch</span>
        <span class="c1"># request.</span>
        <span class="n">resultset</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">multi</span><span class="o">.</span><span class="n">execute</span><span class="p">()]</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Elasticsearch query </span><span class="si">%r</span><span class="s2"> completed in </span><span class="si">%.3f</span><span class="s2">sec&quot;</span><span class="p">,</span>
                <span class="n">query_string</span><span class="p">,</span> <span class="n">b</span><span class="o">-</span><span class="n">a</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">results</span> <span class="ow">in</span> <span class="n">resultset</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s1">&#39;</span><span class="si">%02d</span><span class="s1"> &quot;</span><span class="si">%s</span><span class="s1">&quot; (</span><span class="si">%s</span><span class="s1">) work=</span><span class="si">%s</span><span class="s1"> score=</span><span class="si">%.3f</span><span class="s1"> shard=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">sort_title</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">sort_author</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">explanation</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;shard&#39;</span><span class="p">]</span>
                    <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">results</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resultset</span><span class="p">):</span>
            <span class="c1"># Tell the Pagination object about the page that was just</span>
            <span class="c1"># &#39;loaded&#39; so that Pagination.next_page will work.</span>
            <span class="c1">#</span>
            <span class="c1"># The pagination itself happened inside the Elasticsearch</span>
            <span class="c1"># server when the query ran.</span>
            <span class="n">pagination</span><span class="o">.</span><span class="n">page_loaded</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">results</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.count_works"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.count_works">[docs]</a>    <span class="k">def</span> <span class="nf">count_works</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instead of retrieving works that match `filter`, count the total.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">filter</span><span class="o">.</span><span class="n">match_nothing</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># We already know that the filter should match nothing.</span>
            <span class="c1"># We don&#39;t even need to perform the count.</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">qu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_search_doc</span><span class="p">(</span>
            <span class="n">query_string</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="nb">filter</span><span class="p">,</span> <span class="n">pagination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">qu</span><span class="o">.</span><span class="n">count</span><span class="p">()</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.bulk_update"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.bulk_update">[docs]</a>    <span class="k">def</span> <span class="nf">bulk_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">works</span><span class="p">,</span> <span class="n">retry_on_batch_failure</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Upload a batch of works to the search index at once.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">works</span><span class="p">:</span>
            <span class="c1"># There&#39;s nothing to do. Don&#39;t bother making any requests</span>
            <span class="c1"># to the search index.</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="n">time1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">needs_add</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">successes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">work</span> <span class="ow">in</span> <span class="n">works</span><span class="p">:</span>
            <span class="n">needs_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>

        <span class="c1"># Add/update any works that need adding/updating.</span>
        <span class="n">docs</span> <span class="o">=</span> <span class="n">Work</span><span class="o">.</span><span class="n">to_search_documents</span><span class="p">(</span><span class="n">needs_add</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">:</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">works_index</span>
            <span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">work_document_type</span>
        <span class="n">time2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">success_count</span><span class="p">,</span> <span class="n">errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulk</span><span class="p">(</span>
            <span class="n">docs</span><span class="p">,</span>
            <span class="n">raise_on_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">raise_on_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If the entire update failed, try it one more time before</span>
        <span class="c1"># giving up on the batch.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">docs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">retry_on_batch_failure</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Elasticsearch bulk update timed out, trying again.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulk_update</span><span class="p">(</span><span class="n">needs_add</span><span class="p">,</span> <span class="n">retry_on_batch_failure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">docs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">time3</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Created </span><span class="si">%i</span><span class="s2"> search documents in </span><span class="si">%.2f</span><span class="s2"> seconds&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">docs</span><span class="p">),</span> <span class="n">time2</span> <span class="o">-</span> <span class="n">time1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Uploaded </span><span class="si">%i</span><span class="s2"> search documents in  </span><span class="si">%.2f</span><span class="s2"> seconds&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">docs</span><span class="p">),</span> <span class="n">time3</span> <span class="o">-</span> <span class="n">time2</span><span class="p">))</span>

        <span class="n">doc_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">]</span>

        <span class="c1"># We weren&#39;t able to create search documents for these works, maybe</span>
        <span class="c1"># because they don&#39;t have presentation editions yet.</span>
        <span class="k">def</span> <span class="nf">get_error_id</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">error</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">error</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">error_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_error_id</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">]</span>

        <span class="n">missing_works</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">work</span> <span class="k">for</span> <span class="n">work</span> <span class="ow">in</span> <span class="n">works</span>
            <span class="k">if</span> <span class="n">work</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">doc_ids</span> <span class="ow">and</span> <span class="n">work</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">error_ids</span>
            <span class="ow">and</span> <span class="n">work</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">successes</span>
        <span class="p">]</span>

        <span class="n">successes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="n">work</span> <span class="k">for</span> <span class="n">work</span> <span class="ow">in</span> <span class="n">works</span>
             <span class="k">if</span> <span class="n">work</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">doc_ids</span> <span class="ow">and</span> <span class="n">work</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">error_ids</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">failures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">missing</span> <span class="ow">in</span> <span class="n">missing_works</span><span class="p">:</span>
            <span class="n">failures</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">work</span><span class="p">,</span> <span class="s2">&quot;Work not indexed&quot;</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>

            <span class="n">error_id</span> <span class="o">=</span> <span class="n">get_error_id</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
            <span class="n">work</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">works_with_error</span> <span class="o">=</span> <span class="p">[</span><span class="n">work</span> <span class="k">for</span> <span class="n">work</span> <span class="ow">in</span> <span class="n">works</span> <span class="k">if</span> <span class="n">work</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">error_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">works_with_error</span><span class="p">:</span>
                <span class="n">work</span> <span class="o">=</span> <span class="n">works_with_error</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">exception</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;exception&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">error_message</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">error_message</span><span class="p">:</span>
                <span class="n">error_message</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="n">failures</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">work</span><span class="p">,</span> <span class="n">error_message</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Successfully indexed </span><span class="si">%i</span><span class="s2"> documents, failed to index </span><span class="si">%i</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">success_count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">failures</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">successes</span><span class="p">,</span> <span class="n">failures</span></div>

<div class="viewcode-block" id="ExternalSearchIndex.remove_work"><a class="viewcode-back" href="../../core.html#core.external_search.ExternalSearchIndex.remove_work">[docs]</a>    <span class="k">def</span> <span class="nf">remove_work</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the search document for `work` from the search index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">works_index</span><span class="p">,</span> <span class="n">doc_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">work_document_type</span><span class="p">,</span>
                    <span class="nb">id</span><span class="o">=</span><span class="n">work</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_run_self_tests</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_db</span><span class="p">,</span> <span class="n">in_testing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Helper methods for setting up the self-tests:</span>

        <span class="k">def</span> <span class="nf">_search</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_search_doc</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">test_search_term</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">pagination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_works</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_works</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">test_search_term</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pagination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">debug</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="c1"># The self-tests:</span>

        <span class="k">def</span> <span class="nf">_search_for_term</span><span class="p">():</span>
            <span class="n">titles</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sort_title</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_author</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_works</span><span class="p">()]</span>
            <span class="k">return</span> <span class="n">titles</span>

        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_test</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;Search results for &#39;</span><span class="si">%s</span><span class="s2">&#39;:&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_search_term</span><span class="p">)),</span>
            <span class="n">_search_for_term</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_get_raw_doc</span><span class="p">():</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">_search</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">in_testing</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">search</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">search</span><span class="p">)</span>
                <span class="n">search</span> <span class="o">=</span> <span class="n">search</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">search</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_test</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;Search document for &#39;</span><span class="si">%s</span><span class="s2">&#39;:&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_search_term</span><span class="p">)),</span>
            <span class="n">_get_raw_doc</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_get_raw_results</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_works</span><span class="p">()]</span>

        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_test</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;Raw search results for &#39;</span><span class="si">%s</span><span class="s2">&#39;:&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_search_term</span><span class="p">)),</span>
            <span class="n">_get_raw_results</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_count_docs</span><span class="p">():</span>
            <span class="c1"># The mock methods used in testing return a list, so we have to call len() rather than count().</span>
            <span class="k">if</span> <span class="n">in_testing</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>

        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_test</span><span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;Total number of search results for &#39;</span><span class="si">%s</span><span class="s2">&#39;:&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_search_term</span><span class="p">)),</span>
            <span class="n">_count_docs</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_total_count</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count_works</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_test</span><span class="p">(</span>
            <span class="s2">&quot;Total number of documents in this search index:&quot;</span><span class="p">,</span>
            <span class="n">_total_count</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_collections</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">collections</span> <span class="o">=</span> <span class="n">_db</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Collection</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">collection</span> <span class="ow">in</span> <span class="n">collections</span><span class="p">:</span>
                <span class="nb">filter</span> <span class="o">=</span> <span class="n">Filter</span><span class="p">(</span><span class="n">collections</span><span class="o">=</span><span class="p">[</span><span class="n">collection</span><span class="p">])</span>
                <span class="n">result</span><span class="p">[</span><span class="n">collection</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_works</span><span class="p">(</span><span class="nb">filter</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_test</span><span class="p">(</span>
            <span class="s2">&quot;Total number of documents per collection:&quot;</span><span class="p">,</span>
            <span class="n">_collections</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MappingDocument"><a class="viewcode-back" href="../../core.html#core.external_search.MappingDocument">[docs]</a><span class="k">class</span> <span class="nc">MappingDocument</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class knows a lot about how the &#39;properties&#39; section of an</span>
<span class="sd">    Elasticsearch mapping document (or one of its subdocuments) is</span>
<span class="sd">    created.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subdocuments</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="MappingDocument.add_property"><a class="viewcode-back" href="../../core.html#core.external_search.MappingDocument.add_property">[docs]</a>    <span class="k">def</span> <span class="nf">add_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a field to the list of properties.</span>

<span class="sd">        :param name: Name of the field as found in search documents.</span>
<span class="sd">        :param type: Type of the field. This may be a custom type,</span>
<span class="sd">            so long as a hook method is defined for that type.</span>
<span class="sd">        :param description: Description of the field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: For some fields we could set index: False here, which</span>
        <span class="c1"># would presumably lead to a smaller index and faster</span>
        <span class="c1"># updates. However, it might hurt performance of</span>
        <span class="c1"># searches. When this code is more mature we can do a</span>
        <span class="c1"># side-by-side comparison.</span>

        <span class="n">defaults</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">description</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="k">for</span> <span class="n">default_name</span><span class="p">,</span> <span class="n">default_value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">default_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">description</span><span class="p">:</span>
                <span class="n">description</span><span class="p">[</span><span class="n">default_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_value</span>

        <span class="n">hook_method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span> <span class="o">+</span> <span class="s2">&quot;_property_hook&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hook_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hook_method</span><span class="p">(</span><span class="n">description</span><span class="p">)</span>
        <span class="c1"># TODO: Cross-check the description for correctness. Do the</span>
        <span class="c1"># things it mention actually exist? Better to fail now with a</span>
        <span class="c1"># useful error than to fail when talking to Elasticsearch.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">description</span></div>

<div class="viewcode-block" id="MappingDocument.add_properties"><a class="viewcode-back" href="../../core.html#core.external_search.MappingDocument.add_properties">[docs]</a>    <span class="k">def</span> <span class="nf">add_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">properties_by_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn a dictionary mapping types to field names into a</span>
<span class="sd">        bunch of add_property() calls.</span>

<span class="sd">        Useful when you have a lot of fields that don&#39;t need any</span>
<span class="sd">        customization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="nb">type</span><span class="p">,</span> <span class="n">properties</span> <span class="ow">in</span> <span class="n">properties_by_type</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span></div>

<div class="viewcode-block" id="MappingDocument.subdocument"><a class="viewcode-back" href="../../core.html#core.external_search.MappingDocument.subdocument">[docs]</a>    <span class="k">def</span> <span class="nf">subdocument</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new HasProperties object and register it as a</span>
<span class="sd">        sub-document of this one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subdocument</span> <span class="o">=</span> <span class="n">MappingDocument</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subdocuments</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdocument</span>
        <span class="k">return</span> <span class="n">subdocument</span></div>

<div class="viewcode-block" id="MappingDocument.basic_text_property_hook"><a class="viewcode-back" href="../../core.html#core.external_search.MappingDocument.basic_text_property_hook">[docs]</a>    <span class="k">def</span> <span class="nf">basic_text_property_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hook method to handle the custom &#39;basic_text&#39;</span>
<span class="sd">        property type.</span>

<span class="sd">        This type does not exist in Elasticsearch. It&#39;s our name for a</span>
<span class="sd">        text field that is indexed three times: once using our default</span>
<span class="sd">        English analyzer (&quot;title&quot;), once using an analyzer with</span>
<span class="sd">        minimal stemming (&quot;title.minimal&quot;) for close matches, and once</span>
<span class="sd">        using an analyzer that leaves stopwords in place, for searches</span>
<span class="sd">        that rely on stopwords.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">description</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;text&#39;</span>
        <span class="n">description</span><span class="p">[</span><span class="s1">&#39;analyzer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;en_default_text_analyzer&#39;</span>
        <span class="n">description</span><span class="p">[</span><span class="s1">&#39;fields&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;minimal&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analyzer&quot;</span><span class="p">:</span> <span class="s2">&quot;en_minimal_text_analyzer&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;with_stopwords&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span>
                <span class="s2">&quot;analyzer&quot;</span><span class="p">:</span> <span class="s2">&quot;en_with_stopwords_text_analyzer&quot;</span>
            <span class="p">},</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="MappingDocument.filterable_text_property_hook"><a class="viewcode-back" href="../../core.html#core.external_search.MappingDocument.filterable_text_property_hook">[docs]</a>    <span class="k">def</span> <span class="nf">filterable_text_property_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hook method to handle the custom &#39;filterable_text&#39;</span>
<span class="sd">        property type.</span>

<span class="sd">        This type does not exist in Elasticsearch. It&#39;s our name for a</span>
<span class="sd">        text field that can be used in both queries and filters.</span>

<span class="sd">        This field is indexed _four_ times -- the three ways a normal</span>
<span class="sd">        text field is indexed, plus again as an unparsed keyword that</span>
<span class="sd">        can be used in filters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basic_text_property_hook</span><span class="p">(</span><span class="n">description</span><span class="p">)</span>
        <span class="n">description</span><span class="p">[</span><span class="s2">&quot;fields&quot;</span><span class="p">][</span><span class="s2">&quot;keyword&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;keyword&quot;</span><span class="p">,</span>
            <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;store&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;normalizer&quot;</span><span class="p">:</span> <span class="s2">&quot;filterable_string&quot;</span><span class="p">,</span>
        <span class="p">}</span></div></div>


<div class="viewcode-block" id="Mapping"><a class="viewcode-back" href="../../core.html#core.external_search.Mapping">[docs]</a><span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">MappingDocument</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that defines the mapping for a particular version of the search index.</span>

<span class="sd">    Code that won&#39;t change between versions can go here. (Or code that</span>
<span class="sd">    can change between versions without affecting anything.)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">VERSION_NAME</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Mapping.version_name"><a class="viewcode-back" href="../../core.html#core.external_search.Mapping.version_name">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">version_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the name of this Mapping subclass.&quot;&quot;&quot;</span>
        <span class="n">version</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">VERSION_NAME</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">version</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;VERSION_NAME not defined&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">version</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">):</span>
            <span class="n">version</span> <span class="o">=</span> <span class="s1">&#39;v</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">version</span>
        <span class="k">return</span> <span class="n">version</span></div>

<div class="viewcode-block" id="Mapping.script_name"><a class="viewcode-back" href="../../core.html#core.external_search.Mapping.script_name">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">script_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scope a script name with &quot;simplified&quot; (to avoid confusion with</span>
<span class="sd">        other applications on the Elasticsearch server), and the</span>
<span class="sd">        version number (to avoid confusion with other versions *of</span>
<span class="sd">        this application*, which may implement the same script</span>
<span class="sd">        differently, on this Elasticsearch server).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;simplified.</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">base_name</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">version_name</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Mapping</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">char_filters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalizers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzers</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Mapping.create"><a class="viewcode-back" href="../../core.html#core.external_search.Mapping.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_client</span><span class="p">,</span> <span class="n">base_index_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensure that an index exists in `search_client` for this Mapping.</span>

<span class="sd">        :return: True or False, indicating whether the index was created new.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">versioned_index</span> <span class="o">=</span> <span class="n">base_index_name</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">version_name</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">search_client</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">versioned_index</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">search_client</span><span class="o">.</span><span class="n">setup_index</span><span class="p">(</span><span class="n">new_index</span><span class="o">=</span><span class="n">versioned_index</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Mapping.sort_author_keyword_property_hook"><a class="viewcode-back" href="../../core.html#core.external_search.Mapping.sort_author_keyword_property_hook">[docs]</a>    <span class="k">def</span> <span class="nf">sort_author_keyword_property_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give the `sort_author` property its custom analyzer.&quot;&quot;&quot;</span>
        <span class="n">description</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;text&#39;</span>
        <span class="n">description</span><span class="p">[</span><span class="s1">&#39;analyzer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;en_sort_author_analyzer&#39;</span>
        <span class="n">description</span><span class="p">[</span><span class="s1">&#39;fielddata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Mapping.body"><a class="viewcode-back" href="../../core.html#core.external_search.Mapping.body">[docs]</a>    <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate the body of the mapping document for this version of the</span>
<span class="sd">        mapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">analysis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="nb">filter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">,</span>
                <span class="n">char_filter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">char_filters</span><span class="p">,</span>
                <span class="n">normalizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalizers</span><span class="p">,</span>
                <span class="n">analyzer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">analyzers</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Start with the normally defined properties.</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>

        <span class="c1"># Add subdocuments as additional properties.</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">subdocument</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subdocuments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">properties</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;nested&quot;</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="n">subdocument</span><span class="o">.</span><span class="n">properties</span>
            <span class="p">)</span>

        <span class="n">mappings</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ExternalSearchIndex</span><span class="o">.</span><span class="n">work_document_type</span> <span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">properties</span><span class="o">=</span><span class="n">properties</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="n">settings</span><span class="p">,</span> <span class="n">mappings</span><span class="o">=</span><span class="n">mappings</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CurrentMapping"><a class="viewcode-back" href="../../core.html#core.external_search.CurrentMapping">[docs]</a><span class="k">class</span> <span class="nc">CurrentMapping</span><span class="p">(</span><span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The first mapping to support only Elasticsearch 6.</span>

<span class="sd">    The body of this mapping looks for bibliographic information in</span>
<span class="sd">    the core document, primarily used for matching search</span>
<span class="sd">    requests. It also has nested documents, which are used for</span>
<span class="sd">    filtering and ranking Works when generating other types of</span>
<span class="sd">    feeds:</span>

<span class="sd">    * licensepools -- the Work has these LicensePools (includes current</span>
<span class="sd">      availability as a boolean, but not detailed availability information)</span>
<span class="sd">    * customlists -- the Work is on these CustomLists</span>
<span class="sd">    * contributors -- these Contributors worked on the Work</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">VERSION_NAME</span> <span class="o">=</span> <span class="s2">&quot;v4&quot;</span>

    <span class="c1"># Use regular expressions to normalized values in sortable fields.</span>
    <span class="c1"># These regexes are applied in order; that way &quot;H. G. Wells&quot;</span>
    <span class="c1"># becomes &quot;H G Wells&quot; becomes &quot;HG Wells&quot;.</span>
    <span class="n">CHAR_FILTERS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;remove_apostrophes&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;pattern_replace&quot;</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span>
            <span class="n">replacement</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>
    <span class="n">AUTHOR_CHAR_FILTER_NAMES</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">replacement</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="c1"># The special author name &quot;[Unknown]&quot; should sort after everything</span>
        <span class="c1"># else. REPLACEMENT CHARACTER is the final valid Unicode character.</span>
        <span class="p">(</span><span class="s2">&quot;unknown_author&quot;</span><span class="p">,</span> <span class="s2">&quot;\[Unknown\]&quot;</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;</span><span class="se">\N{REPLACEMENT CHARACTER}</span><span class="s2">&quot;</span><span class="p">),</span>

        <span class="c1"># Works by a given primary author should be secondarily sorted</span>
        <span class="c1"># by title, not by the other contributors.</span>
        <span class="p">(</span><span class="s2">&quot;primary_author_only&quot;</span><span class="p">,</span> <span class="s2">&quot;\s+;.*&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>

        <span class="c1"># Remove parentheticals (e.g. the full name of someone who</span>
        <span class="c1"># goes by initials).</span>
        <span class="p">(</span><span class="s2">&quot;strip_parentheticals&quot;</span><span class="p">,</span> <span class="s2">&quot;\s+\([^)]+\)&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>

        <span class="c1"># Remove periods from consideration.</span>
        <span class="p">(</span><span class="s2">&quot;strip_periods&quot;</span><span class="p">,</span> <span class="s2">&quot;\.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>

        <span class="c1"># Collapse spaces for people whose sort names end with initials.</span>
        <span class="p">(</span><span class="s2">&quot;collapse_three_initials&quot;</span><span class="p">,</span> <span class="s2">&quot; ([A-Z]) ([A-Z]) ([A-Z])$&quot;</span><span class="p">,</span> <span class="s2">&quot; $1$2$3&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;collapse_two_initials&quot;</span><span class="p">,</span> <span class="s2">&quot; ([A-Z]) ([A-Z])$&quot;</span><span class="p">,</span> <span class="s2">&quot; $1$2&quot;</span><span class="p">),</span>
    <span class="p">]:</span>
        <span class="n">normalizer</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s2">&quot;pattern_replace&quot;</span><span class="p">,</span>
                          <span class="n">pattern</span><span class="o">=</span><span class="n">pattern</span><span class="p">,</span>
                          <span class="n">replacement</span><span class="o">=</span><span class="n">replacement</span><span class="p">)</span>
        <span class="n">CHAR_FILTERS</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalizer</span>
        <span class="n">AUTHOR_CHAR_FILTER_NAMES</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CurrentMapping</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># Set up character filters.</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">char_filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CHAR_FILTERS</span>

        <span class="c1"># This normalizer is used on freeform strings that</span>
        <span class="c1"># will be used as tokens in filters. This way we can,</span>
        <span class="c1"># e.g. ignore capitalization when considering whether</span>
        <span class="c1"># two books belong to the same series or whether two</span>
        <span class="c1"># author names are the same.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalizers</span><span class="p">[</span><span class="s1">&#39;filterable_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;custom&quot;</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lowercase&quot;</span><span class="p">,</span> <span class="s2">&quot;asciifolding&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Set up analyzers.</span>
        <span class="c1">#</span>

        <span class="c1"># We use three analyzers:</span>
        <span class="c1">#</span>
        <span class="c1"># 1. An analyzer based on Elasticsearch&#39;s default English</span>
        <span class="c1">#    analyzer, with a normal stemmer -- used as the default</span>
        <span class="c1">#    view of a text field such as &#39;description&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># 2. An analyzer that&#39;s exactly the same as #1 but with a less</span>
        <span class="c1">#    aggressive stemmer -- used as the &#39;minimal&#39; view of a</span>
        <span class="c1">#    text field such as &#39;description.minimal&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># 3. An analyzer that&#39;s exactly the same as #2 but with</span>
        <span class="c1">#    English stopwords left in place instead of filtered out --</span>
        <span class="c1">#    used as the &#39;with_stopwords&#39; view of a text field such as</span>
        <span class="c1">#    &#39;title.with_stopwords&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># The analyzers are identical except for the end of the filter</span>
        <span class="c1"># chain.</span>
        <span class="c1">#</span>
        <span class="c1"># All three analyzers are based on Elasticsearch&#39;s default English</span>
        <span class="c1"># analyzer, defined here:</span>
        <span class="c1"># https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html#english-analyzer</span>

        <span class="c1"># First, recreate the filters from the default English</span>
        <span class="c1"># analyzer. We&#39;ll be using these to build our own analyzers.</span>

        <span class="c1"># Filter out English stopwords.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;english_stop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;stop&quot;</span><span class="p">,</span> <span class="n">stopwords</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;_english_&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># The default English stemmer, used in the en_default analyzer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;english_stemmer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;stemmer&quot;</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="s2">&quot;english&quot;</span>
        <span class="p">)</span>

        <span class="c1"># A less aggressive English stemmer, used in the en_minimal analyzer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;minimal_english_stemmer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;stemmer&quot;</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="s2">&quot;minimal_english&quot;</span>
        <span class="p">)</span>

        <span class="c1"># A filter that removes English posessives such as &quot;&#39;s&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;english_posessive_stemmer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;stemmer&quot;</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="s2">&quot;possessive_english&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Some potentially useful filters that are currently not used:</span>
        <span class="c1">#</span>
        <span class="c1"># * keyword_marker -- Exempt certain keywords from stemming</span>
        <span class="c1"># * synonym -- Introduce synonyms for words</span>
        <span class="c1">#   (but probably better to use synonym_graph during the search</span>
        <span class="c1">#    -- it&#39;s more flexible).</span>

        <span class="c1"># Here&#39;s the common analyzer configuration. The comment NEW</span>
        <span class="c1"># means this is something we added on top of Elasticsearch&#39;s</span>
        <span class="c1"># default configuration for the English analyzer.</span>
        <span class="n">common_text_analyzer</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;custom&quot;</span><span class="p">,</span>
            <span class="n">char_filter</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;html_strip&quot;</span><span class="p">,</span> <span class="s2">&quot;remove_apostrophes&quot;</span><span class="p">],</span> <span class="c1"># NEW</span>
            <span class="n">tokenizer</span><span class="o">=</span><span class="s2">&quot;standard&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">common_filter</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;lowercase&quot;</span><span class="p">,</span>
            <span class="s2">&quot;asciifolding&quot;</span><span class="p">,</span>                          <span class="c1"># NEW</span>
        <span class="p">]</span>

        <span class="c1"># The default_text_analyzer uses Elasticsearch&#39;s standard</span>
        <span class="c1"># English stemmer and removes stopwords.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzers</span><span class="p">[</span><span class="s1">&#39;en_default_text_analyzer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">common_text_analyzer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzers</span><span class="p">[</span><span class="s1">&#39;en_default_text_analyzer&#39;</span><span class="p">][</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">common_filter</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;english_stop&quot;</span><span class="p">,</span> <span class="s1">&#39;english_stemmer&#39;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># The minimal_text_analyzer uses a less aggressive English</span>
        <span class="c1"># stemmer, and removes stopwords.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzers</span><span class="p">[</span><span class="s1">&#39;en_minimal_text_analyzer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">common_text_analyzer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzers</span><span class="p">[</span><span class="s1">&#39;en_minimal_text_analyzer&#39;</span><span class="p">][</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">common_filter</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;english_stop&#39;</span><span class="p">,</span> <span class="s1">&#39;minimal_english_stemmer&#39;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># The en_with_stopwords_text_analyzer uses the less aggressive</span>
        <span class="c1"># stemmer and does not remove stopwords.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzers</span><span class="p">[</span><span class="s1">&#39;en_with_stopwords_text_analyzer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">common_text_analyzer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzers</span><span class="p">[</span><span class="s1">&#39;en_with_stopwords_text_analyzer&#39;</span><span class="p">][</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">common_filter</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;minimal_english_stemmer&#39;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Now we need to define a special analyzer used only by the</span>
        <span class="c1"># &#39;sort_author&#39; property.</span>

        <span class="c1"># Here&#39;s a special filter used only by that analyzer. It</span>
        <span class="c1"># duplicates the filter used by the icu_collation_keyword data</span>
        <span class="c1"># type.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;en_sortable_filter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;icu_collation&quot;</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="s2">&quot;en&quot;</span><span class="p">,</span> <span class="n">country</span><span class="o">=</span><span class="s2">&quot;US&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Here&#39;s the analyzer used by the &#39;sort_author&#39; property.</span>
        <span class="c1"># It&#39;s the same as icu_collation_keyword, but it has some</span>
        <span class="c1"># extra character filters -- regexes that do things like</span>
        <span class="c1"># convert &quot;Tolkien, J. R. R.&quot; to &quot;Tolkien, JRR&quot;.</span>
        <span class="c1">#</span>
        <span class="c1"># This is necessary because normal icu_collation_keyword</span>
        <span class="c1"># fields can&#39;t specify char_filter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analyzers</span><span class="p">[</span><span class="s1">&#39;en_sort_author_analyzer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">tokenizer</span><span class="o">=</span><span class="s2">&quot;keyword&quot;</span><span class="p">,</span>
            <span class="nb">filter</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;en_sortable_filter&quot;</span><span class="p">],</span>
            <span class="n">char_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AUTHOR_CHAR_FILTER_NAMES</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Now, the main event. Set up the field properties for the</span>
        <span class="c1"># base document.</span>
        <span class="n">fields_by_type</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;basic_text&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;summary&#39;</span><span class="p">],</span>
            <span class="s1">&#39;filterable_text&#39;</span><span class="p">:</span> <span class="p">[</span>
                <span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;subtitle&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">,</span> <span class="s1">&#39;classifications.term&#39;</span><span class="p">,</span>
                <span class="s1">&#39;author&#39;</span><span class="p">,</span> <span class="s1">&#39;publisher&#39;</span><span class="p">,</span> <span class="s1">&#39;imprint&#39;</span>
            <span class="p">],</span>
            <span class="s1">&#39;boolean&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;presentation_ready&#39;</span><span class="p">],</span>
            <span class="s1">&#39;icu_collation_keyword&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;sort_title&#39;</span><span class="p">],</span>
            <span class="s1">&#39;sort_author_keyword&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;sort_author&#39;</span><span class="p">],</span>
            <span class="s1">&#39;integer&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;series_position&#39;</span><span class="p">,</span> <span class="s1">&#39;work_id&#39;</span><span class="p">],</span>
            <span class="s1">&#39;long&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;last_update_time&#39;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_properties</span><span class="p">(</span><span class="n">fields_by_type</span><span class="p">)</span>

        <span class="c1"># Set up subdocuments.</span>
        <span class="n">contributors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subdocument</span><span class="p">(</span><span class="s2">&quot;contributors&quot;</span><span class="p">)</span>
        <span class="n">contributor_fields</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;filterable_text&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;sort_name&#39;</span><span class="p">,</span> <span class="s1">&#39;display_name&#39;</span><span class="p">,</span> <span class="s1">&#39;family_name&#39;</span><span class="p">],</span>
            <span class="s1">&#39;keyword&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;role&#39;</span><span class="p">,</span> <span class="s1">&#39;lc&#39;</span><span class="p">,</span> <span class="s1">&#39;viaf&#39;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">contributors</span><span class="o">.</span><span class="n">add_properties</span><span class="p">(</span><span class="n">contributor_fields</span><span class="p">)</span>

        <span class="n">licensepools</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subdocument</span><span class="p">(</span><span class="s2">&quot;licensepools&quot;</span><span class="p">)</span>
        <span class="n">licensepool_fields</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;integer&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;collection_id&#39;</span><span class="p">,</span> <span class="s1">&#39;data_source_id&#39;</span><span class="p">],</span>
            <span class="s1">&#39;long&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;availability_time&#39;</span><span class="p">],</span>
            <span class="s1">&#39;boolean&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;available&#39;</span><span class="p">,</span> <span class="s1">&#39;open_access&#39;</span><span class="p">,</span> <span class="s1">&#39;suppressed&#39;</span><span class="p">,</span> <span class="s1">&#39;licensed&#39;</span><span class="p">],</span>
            <span class="s1">&#39;keyword&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;medium&#39;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">licensepools</span><span class="o">.</span><span class="n">add_properties</span><span class="p">(</span><span class="n">licensepool_fields</span><span class="p">)</span>

        <span class="n">identifiers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subdocument</span><span class="p">(</span><span class="s2">&quot;identifiers&quot;</span><span class="p">)</span>
        <span class="n">identifier_fields</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;keyword&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;identifier&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="n">identifiers</span><span class="o">.</span><span class="n">add_properties</span><span class="p">(</span><span class="n">identifier_fields</span><span class="p">)</span>

        <span class="n">genres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subdocument</span><span class="p">(</span><span class="s2">&quot;genres&quot;</span><span class="p">)</span>
        <span class="n">genre_fields</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;keyword&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;scheme&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;term&#39;</span><span class="p">],</span>
            <span class="s1">&#39;float&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">genres</span><span class="o">.</span><span class="n">add_properties</span><span class="p">(</span><span class="n">genre_fields</span><span class="p">)</span>

        <span class="n">customlists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subdocument</span><span class="p">(</span><span class="s2">&quot;customlists&quot;</span><span class="p">)</span>
        <span class="n">customlist_fields</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;integer&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;list_id&#39;</span><span class="p">],</span>
            <span class="s1">&#39;long&#39;</span><span class="p">:</span>  <span class="p">[</span><span class="s1">&#39;first_appearance&#39;</span><span class="p">],</span>
            <span class="s1">&#39;boolean&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;featured&#39;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">customlists</span><span class="o">.</span><span class="n">add_properties</span><span class="p">(</span><span class="n">customlist_fields</span><span class="p">)</span>

<div class="viewcode-block" id="CurrentMapping.stored_scripts"><a class="viewcode-back" href="../../core.html#core.external_search.CurrentMapping.stored_scripts">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">stored_scripts</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This version defines a single stored script, &quot;work_last_update&quot;,</span>
<span class="sd">        defined below.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="s2">&quot;work_last_update&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">WORK_LAST_UPDATE_SCRIPT</span></div>

    <span class="c1"># Definition of the work_last_update_script.</span>
    <span class="n">WORK_LAST_UPDATE_SCRIPT</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">double champion = -1;</span>
<span class="s2">// Start off by looking at the work&#39;s last update time.</span>
<span class="s2">for (candidate in doc[&#39;last_update_time&#39;]) {</span>
<span class="s2">    if (champion == -1 || candidate &gt; champion) { champion = candidate; }</span>
<span class="s2">}</span>
<span class="s2">if (params.collection_ids != null &amp;&amp; params.collection_ids.length &gt; 0) {</span>
<span class="s2">    // Iterate over all licensepools looking for a pool in a collection</span>
<span class="s2">    // relevant to this filter. When one is found, check its</span>
<span class="s2">    // availability time to see if it&#39;s later than the last update time.</span>
<span class="s2">    for (licensepool in params._source.licensepools) {</span>
<span class="s2">        if (!params.collection_ids.contains(licensepool[&#39;collection_id&#39;])) { continue; }</span>
<span class="s2">        double candidate = licensepool[&#39;availability_time&#39;];</span>
<span class="s2">        if (champion == -1 || candidate &gt; champion) { champion = candidate; }</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">if (params.list_ids != null &amp;&amp; params.list_ids.length &gt; 0) {</span>

<span class="s2">    // Iterate over all customlists looking for a list relevant to</span>
<span class="s2">    // this filter. When one is found, check the previous work&#39;s first</span>
<span class="s2">    // appearance on that list to see if it&#39;s later than the last</span>
<span class="s2">    // update time.</span>
<span class="s2">    for (customlist in params._source.customlists) {</span>
<span class="s2">        if (!params.list_ids.contains(customlist[&#39;list_id&#39;])) { continue; }</span>
<span class="s2">        double candidate = customlist[&#39;first_appearance&#39;];</span>
<span class="s2">        if (champion == -1 || candidate &gt; champion) { champion = candidate; }</span>
<span class="s2">    }</span>
<span class="s2">}</span>

<span class="s2">return champion;</span>
<span class="s2">&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="SearchBase"><a class="viewcode-back" href="../../core.html#core.external_search.SearchBase">[docs]</a><span class="k">class</span> <span class="nc">SearchBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A superclass containing helper methods for creating and modifying</span>
<span class="sd">    Elasticsearch-dsl Query-type objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_boost</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">boost</span><span class="p">,</span> <span class="n">queries</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">all_must_match</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boost a query by a certain amount relative to its neighbors in a</span>
<span class="sd">        dis_max query.</span>

<span class="sd">        :param boost: Numeric value to boost search results that</span>
<span class="sd">           match `queries`.</span>
<span class="sd">        :param queries: One or more Query objects to use in a query context.</span>
<span class="sd">        :param filter: A Query object to use in a filter context.</span>
<span class="sd">        :param all_must_match: If this is False (the default), then only</span>
<span class="sd">           one of the `queries` must match for a search result to get</span>
<span class="sd">           the boost. If this is True, then all `queries` must match,</span>
<span class="sd">           or the boost will not apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="n">filters</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">BaseQuery</span><span class="p">):</span>
            <span class="n">queries</span> <span class="o">=</span> <span class="p">[</span><span class="n">queries</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">all_must_match</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">queries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Every one of the subqueries in `queries` must match.</span>
            <span class="c1"># (If there&#39;s only one subquery, this simplifies the</span>
            <span class="c1"># final query slightly.)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="n">queries</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># At least one of the queries in `queries` must match.</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">should</span><span class="o">=</span><span class="n">queries</span><span class="p">,</span> <span class="n">minimum_should_match</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">boost</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">boost</span><span class="p">),</span> <span class="nb">filter</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">query</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_nest</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">subdocument</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn a normal query into a nested query.</span>

<span class="sd">        This is a helper method for a helper method; you should</span>
<span class="sd">        probably use _nestable() instead.</span>

<span class="sd">        :param subdocument: The name of the subdocument to query</span>
<span class="sd">        against, e.g. &quot;contributors&quot;.</span>

<span class="sd">        :param query: An elasticsearch-dsl Query object (not the Query</span>
<span class="sd">        objects defined by this class).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Nested</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">subdocument</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_nestable</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a query against a field nestable, if necessary.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;s.&#39;</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
            <span class="c1"># This is a query against a field from a subdocument. We</span>
            <span class="c1"># can&#39;t run it against the top-level document; it has to</span>
            <span class="c1"># be run in the context of its subdocument.</span>
            <span class="n">subdocument</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">query</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_nest</span><span class="p">(</span><span class="n">subdocument</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">query</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_match_term</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">query_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A clause that matches the query string against a specific field in</span>
<span class="sd">        the search document.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">match_query</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="n">query_string</span><span class="p">})</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_nestable</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">match_query</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_match_range</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Match a ranged value for a field, using an operation other than</span>
<span class="sd">        equality.</span>

<span class="sd">        e.g. _match_range(&quot;field.name&quot;, &quot;gte&quot;, 5) will match</span>
<span class="sd">        any value for field.name greater than 5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span> <span class="p">:</span> <span class="p">{</span><span class="n">operation</span><span class="p">:</span> <span class="n">value</span><span class="p">}}</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="n">match</span><span class="p">)</span>

<div class="viewcode-block" id="SearchBase.make_target_age_query"><a class="viewcode-back" href="../../core.html#core.external_search.SearchBase.make_target_age_query">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">make_target_age_query</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">target_age</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="mf">1.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Elasticsearch query object for a boolean query that</span>
<span class="sd">        matches works whose target ages overlap (partially or</span>
<span class="sd">        entirely) the given age range.</span>

<span class="sd">        :param target_age: A 2-tuple (lower limit, upper limit)</span>
<span class="sd">        :param boost: Boost works that fit precisely into the target</span>
<span class="sd">           age range by this amount, vis-a-vis works that don&#39;t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span> <span class="o">=</span> <span class="n">target_age</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target_age</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># There must be _some_ overlap with the provided range.</span>
        <span class="n">must</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_match_range</span><span class="p">(</span><span class="s2">&quot;target_age.upper&quot;</span><span class="p">,</span> <span class="s2">&quot;gte&quot;</span><span class="p">,</span> <span class="n">lower</span><span class="p">),</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_match_range</span><span class="p">(</span><span class="s2">&quot;target_age.lower&quot;</span><span class="p">,</span> <span class="s2">&quot;lte&quot;</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Results with ranges contained within the query range are</span>
        <span class="c1"># better.</span>
        <span class="c1"># e.g. for query 4-6, a result with 5-6 beats 6-7</span>
        <span class="n">should</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_match_range</span><span class="p">(</span><span class="s2">&quot;target_age.upper&quot;</span><span class="p">,</span> <span class="s2">&quot;lte&quot;</span><span class="p">,</span> <span class="n">upper</span><span class="p">),</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_match_range</span><span class="p">(</span><span class="s2">&quot;target_age.lower&quot;</span><span class="p">,</span> <span class="s2">&quot;gte&quot;</span><span class="p">,</span> <span class="n">lower</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="n">filter_version</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="n">must</span><span class="p">)</span>
        <span class="n">query_version</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="n">must</span><span class="p">,</span> <span class="n">should</span><span class="o">=</span><span class="n">should</span><span class="p">,</span> <span class="n">boost</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">boost</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">filter_version</span><span class="p">,</span> <span class="n">query_version</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_combine_hypotheses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hypotheses</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build an Elasticsearch Query object that tests a number</span>
<span class="sd">        of hypotheses at once.</span>

<span class="sd">        :return: A DisMax query if there are hypotheses to be tested;</span>
<span class="sd">        otherwise a MatchAll query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hypotheses</span><span class="p">:</span>
            <span class="n">qu</span> <span class="o">=</span> <span class="n">DisMax</span><span class="p">(</span><span class="n">queries</span><span class="o">=</span><span class="n">hypotheses</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We ended up with no hypotheses. Match everything.</span>
            <span class="n">qu</span> <span class="o">=</span> <span class="n">MatchAll</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">qu</span></div>

<div class="viewcode-block" id="Query"><a class="viewcode-back" href="../../core.html#core.external_search.Query">[docs]</a><span class="k">class</span> <span class="nc">Query</span><span class="p">(</span><span class="n">SearchBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An attempt to find something in the search index.&quot;&quot;&quot;</span>

    <span class="c1"># This dictionary establishes the relative importance of the</span>
    <span class="c1"># fields that someone might search for. These weights are used</span>
    <span class="c1"># directly -- an exact title match has a higher weight than an</span>
    <span class="c1"># exact author match. They are also used as the basis for other</span>
    <span class="c1"># weights: the weight of a fuzzy match for a given field is in</span>
    <span class="c1"># proportion to the weight of a non-fuzzy match for that field.</span>
    <span class="n">WEIGHT_FOR_FIELD</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">title</span><span class="o">=</span><span class="mf">140.0</span><span class="p">,</span>
        <span class="n">subtitle</span><span class="o">=</span><span class="mf">130.0</span><span class="p">,</span>
        <span class="n">series</span><span class="o">=</span><span class="mf">120.0</span><span class="p">,</span>
        <span class="n">author</span><span class="o">=</span><span class="mf">120.0</span><span class="p">,</span>
        <span class="n">summary</span><span class="o">=</span><span class="mf">80.0</span><span class="p">,</span>
        <span class="n">publisher</span><span class="o">=</span><span class="mf">40.0</span><span class="p">,</span>
        <span class="n">imprint</span><span class="o">=</span><span class="mf">40.0</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># The contributor names in the contributors sub-document have the</span>
    <span class="c1"># same weight as the &#39;author&#39; field in the main document.</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;contributors.sort_name&#39;</span><span class="p">,</span> <span class="s1">&#39;contributors.display_name&#39;</span><span class="p">]:</span>
        <span class="n">WEIGHT_FOR_FIELD</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">WEIGHT_FOR_FIELD</span><span class="p">[</span><span class="s1">&#39;author&#39;</span><span class="p">]</span>

    <span class="c1"># When someone searches for a person&#39;s name, they&#39;re most likely</span>
    <span class="c1"># searching for that person&#39;s contributions in one of these roles.</span>
    <span class="n">SEARCH_RELEVANT_ROLES</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">Contributor</span><span class="o">.</span><span class="n">PRIMARY_AUTHOR_ROLE</span><span class="p">,</span>
        <span class="n">Contributor</span><span class="o">.</span><span class="n">AUTHOR_ROLE</span><span class="p">,</span>
        <span class="n">Contributor</span><span class="o">.</span><span class="n">NARRATOR_ROLE</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># If the entire search query is turned into a filter, all works</span>
    <span class="c1"># that match the filter will be given this weight.</span>
    <span class="c1">#</span>
    <span class="c1"># This is very high, but not high enough to outweigh e.g. an exact</span>
    <span class="c1"># title match.</span>
    <span class="n">QUERY_WAS_A_FILTER_WEIGHT</span> <span class="o">=</span> <span class="mi">600</span>

    <span class="c1"># A keyword match is the best type of match we can get -- the</span>
    <span class="c1"># patron typed in a near-exact match for one of the fields.</span>
    <span class="c1">#</span>
    <span class="c1"># That said, this is a coefficient, not a weight -- a keyword</span>
    <span class="c1"># title match is better than a keyword subtitle match, etc.</span>
    <span class="n">DEFAULT_KEYWORD_MATCH_COEFFICIENT</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="c1"># Normally we weight keyword matches very highly, but for</span>
    <span class="c1"># publishers and imprints, where a keyword match may also be a</span>
    <span class="c1"># partial author match (&quot;Plympton&quot;) or topic match (&quot;Penguin&quot;), we</span>
    <span class="c1"># weight them much lower -- the author or topic is probably more</span>
    <span class="c1"># important.</span>
    <span class="c1">#</span>
    <span class="c1"># Again, these are coefficients, not weights. A keyword publisher</span>
    <span class="c1"># match is better than a keyword imprint match, even though they have</span>
    <span class="c1"># the same keyword match coefficient.</span>
    <span class="n">KEYWORD_MATCH_COEFFICIENT_FOR_FIELD</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">publisher</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">imprint</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># A normal coefficient for a normal sort of match.</span>
    <span class="n">BASELINE_COEFFICIENT</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># There are a couple places where we want to boost a query just</span>
    <span class="c1"># slightly above baseline.</span>
    <span class="n">SLIGHTLY_ABOVE_BASELINE</span> <span class="o">=</span> <span class="mf">1.1</span>

    <span class="c1"># For each of these fields, we&#39;re going to test the hypothesis</span>
    <span class="c1"># that the query string is nothing but an attempt to match this</span>
    <span class="c1"># field.</span>
    <span class="n">SIMPLE_MATCH_FIELDS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;subtitle&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">,</span> <span class="s1">&#39;publisher&#39;</span><span class="p">,</span> <span class="s1">&#39;imprint&#39;</span>
    <span class="p">]</span>

    <span class="c1"># For each of these fields, we&#39;re going to test the hypothesis</span>
    <span class="c1"># that the query string contains words from the book&#39;s title</span>
    <span class="c1"># _plus_ words from this field.</span>
    <span class="c1">#</span>
    <span class="c1"># Note that here we&#39;re doing an author query the cheap way, by</span>
    <span class="c1"># looking at the .author field -- the display name of the primary</span>
    <span class="c1"># author associated with the Work&#39;s presentation Editon -- not</span>
    <span class="c1"># the .display_names in the &#39;contributors&#39; subdocument.</span>
    <span class="n">MULTI_MATCH_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;subtitle&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">,</span> <span class="s1">&#39;author&#39;</span><span class="p">]</span>

    <span class="c1"># For each of these fields, we&#39;re going to test the hypothesis</span>
    <span class="c1"># that the query string is a good match for an aggressively</span>
    <span class="c1"># stemmed version of this field.</span>
    <span class="n">STEMMABLE_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;subtitle&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">]</span>

    <span class="c1"># Although we index all text fields using an analyzer that</span>
    <span class="c1"># preserves stopwords, these are the only fields where we</span>
    <span class="c1"># currently think it&#39;s worth testing a hypothesis that stopwords</span>
    <span class="c1"># in a query string are _important_.</span>
    <span class="n">STOPWORD_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;subtitle&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">]</span>

    <span class="c1"># SpellChecker is expensive to initialize, so keep around</span>
    <span class="c1"># a class-level instance.</span>
    <span class="n">SPELLCHECKER</span> <span class="o">=</span> <span class="n">SpellChecker</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_query_parser</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store a query string and filter.</span>

<span class="sd">        :param query_string: A user typed this string into a search box.</span>
<span class="sd">        :param filter: A Filter object representing the circumstances</span>
<span class="sd">            of the search -- for example, maybe we are searching within</span>
<span class="sd">            a specific lane.</span>

<span class="sd">        :param use_query_parser: Should we try to parse filter</span>
<span class="sd">            information out of the query string? Or did we already try</span>
<span class="sd">            that, and this constructor is being called recursively, to</span>
<span class="sd">            build a subquery from the _remaining_ portion of a larger</span>
<span class="sd">            query string?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_string</span> <span class="o">=</span> <span class="n">query_string</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">filter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_query_parser</span> <span class="o">=</span> <span class="n">use_query_parser</span>

        <span class="c1"># Pre-calculate some values that will be checked frequently</span>
        <span class="c1"># when generating the Elasticsearch-dsl query.</span>

        <span class="c1"># Check if the string contains English stopwords.</span>
        <span class="k">if</span> <span class="n">query_string</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">words</span> <span class="o">=</span> <span class="n">query_string</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">words</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contains_stopwords</span> <span class="o">=</span> <span class="n">query_string</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">word</span> <span class="ow">in</span> <span class="n">ENGLISH_STOPWORDS</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">words</span>
        <span class="p">)</span>

        <span class="c1"># Determine how heavily to weight fuzzy hypotheses.</span>
        <span class="c1">#</span>
        <span class="c1"># The &quot;fuzzy&quot; version of a hypothesis tests the idea that</span>
        <span class="c1"># someone meant to trigger the original hypothesis, but they</span>
        <span class="c1"># made a typo.</span>
        <span class="c1">#</span>
        <span class="c1"># The strength of a fuzzy hypothesis is always lower than the</span>
        <span class="c1"># non-fuzzy version of the same hypothesis.</span>
        <span class="c1">#</span>
        <span class="c1"># Depending on the query, the stregnth of a fuzzy hypothesis</span>
        <span class="c1"># may be reduced even further -- that&#39;s determined here.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">words</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPELLCHECKER</span><span class="o">.</span><span class="n">unknown</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">words</span><span class="p">):</span>
                <span class="c1"># Spell check failed. This is the default behavior, if</span>
                <span class="c1"># only because peoples&#39; names will generally fail spell</span>
                <span class="c1"># check. Fuzzy queries will be given their full weight.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_coefficient</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Everything seems to be spelled correctly. But sometimes</span>
                <span class="c1"># a word can be misspelled as another word, e.g. &quot;came&quot; -&gt;</span>
                <span class="c1"># &quot;cane&quot;, or a name may be misspelled as a word. We&#39;ll</span>
                <span class="c1"># still check the fuzzy hypotheses, but we can improve</span>
                <span class="c1"># results overall by giving them only half their normal</span>
                <span class="c1"># strength.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_coefficient</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Since this query does not contain any words, there is no</span>
            <span class="c1"># risk that a word might be misspelled. Do not create or</span>
            <span class="c1"># run the &#39;fuzzy&#39; hypotheses at all.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_coefficient</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="Query.build"><a class="viewcode-back" href="../../core.html#core.external_search.Query.build">[docs]</a>    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elasticsearch</span><span class="p">,</span> <span class="n">pagination</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make an Elasticsearch-DSL Search object out of this query.</span>

<span class="sd">        :param elasticsearch: An Elasticsearch-DSL Search object. This</span>
<span class="sd">            object is ready to run a search against an Elasticsearch server,</span>
<span class="sd">            but it doesn&#39;t represent any particular Elasticsearch query.</span>

<span class="sd">        :param pagination: A Pagination object indicating a slice of</span>
<span class="sd">            results to pull from the search index.</span>

<span class="sd">        :return: An Elasticsearch-DSL Search object that&#39;s prepared</span>
<span class="sd">            to run this specific query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elasticsearch_query</span>
        <span class="n">nested_filters</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># Convert the resulting Filter into two objects -- one</span>
        <span class="c1"># describing the base filter and one describing the nested</span>
        <span class="c1"># filters.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">:</span>
            <span class="n">base_filter</span><span class="p">,</span> <span class="n">nested_filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_filter</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">nested_filters</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># Combine the query&#39;s base Filter with the universal base</span>
        <span class="c1"># filter -- works must be presentation-ready, etc.</span>
        <span class="n">universal_base_filter</span> <span class="o">=</span> <span class="n">Filter</span><span class="o">.</span><span class="n">universal_base_filter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">universal_base_filter</span><span class="p">:</span>
            <span class="n">query_filter</span> <span class="o">=</span> <span class="n">Filter</span><span class="o">.</span><span class="n">_chain_filters</span><span class="p">(</span>
                <span class="n">base_filter</span><span class="p">,</span> <span class="n">universal_base_filter</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">query_filter</span> <span class="o">=</span> <span class="n">base_filter</span>
        <span class="k">if</span> <span class="n">query_filter</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="n">query</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="n">query_filter</span><span class="p">)</span>

        <span class="c1"># We now have an Elasticsearch-DSL Query object (which isn&#39;t</span>
        <span class="c1"># tied to a specific server). Turn it into a Search object</span>
        <span class="c1"># (which is).</span>
        <span class="n">search</span> <span class="o">=</span> <span class="n">elasticsearch</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

        <span class="c1"># Now update the &#39;nested filters&#39; dictionary with the</span>
        <span class="c1"># universal nested filters -- no suppressed license pools,</span>
        <span class="c1"># etc.</span>
        <span class="n">universal_nested_filters</span> <span class="o">=</span> <span class="n">Filter</span><span class="o">.</span><span class="n">universal_nested_filters</span><span class="p">()</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">universal_nested_filters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># Now we can convert any nested filters (universal or</span>
        <span class="c1"># otherwise) into nested queries.</span>
        <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">subfilters</span> <span class="ow">in</span> <span class="n">nested_filters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">subfilter</span> <span class="ow">in</span> <span class="n">subfilters</span><span class="p">:</span>
                <span class="c1"># This ensures that the filter logic is executed in</span>
                <span class="c1"># filter context rather than query context.</span>
                <span class="n">subquery</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="nb">filter</span><span class="o">=</span><span class="n">subfilter</span><span class="p">)</span>
                <span class="n">search</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                    <span class="n">name_or_query</span><span class="o">=</span><span class="s1">&#39;nested&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="n">subquery</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">:</span>
            <span class="c1"># Apply any necessary sort order.</span>
            <span class="n">order_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">sort_order</span>
            <span class="k">if</span> <span class="n">order_fields</span><span class="p">:</span>
                <span class="n">search</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">*</span><span class="n">order_fields</span><span class="p">)</span>

            <span class="c1"># Add any necessary script fields.</span>
            <span class="n">script_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">script_fields</span>
            <span class="k">if</span> <span class="n">script_fields</span><span class="p">:</span>
                <span class="n">search</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">script_fields</span><span class="p">(</span><span class="o">**</span><span class="n">script_fields</span><span class="p">)</span>
        <span class="c1"># Apply any necessary query restrictions imposed by the</span>
        <span class="c1"># Pagination object. This may happen through modification or</span>
        <span class="c1"># by returning an entirely new Search object.</span>
        <span class="k">if</span> <span class="n">pagination</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">pagination</span><span class="o">.</span><span class="n">modify_search_query</span><span class="p">(</span><span class="n">search</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">search</span> <span class="o">=</span> <span class="n">result</span>

        <span class="c1"># All done!</span>
        <span class="k">return</span> <span class="n">search</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elasticsearch_query</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build an Elasticsearch-DSL Query object for this query string.&quot;&quot;&quot;</span>

        <span class="c1"># The query will most likely be a dis_max query, which tests a</span>
        <span class="c1"># number of hypotheses about what the query string might</span>
        <span class="c1"># &#39;really&#39; mean. For each book, the highest-rated hypothesis</span>
        <span class="c1"># will be assumed to be true, and the highest-rated titles</span>
        <span class="c1"># overall will become the search results.</span>
        <span class="n">hypotheses</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_string</span><span class="p">:</span>
            <span class="c1"># There is no query string. Match everything.</span>
            <span class="k">return</span> <span class="n">MatchAll</span><span class="p">()</span>

        <span class="c1"># Here are the hypotheses:</span>

        <span class="c1"># The query string might be a match against a single field:</span>
        <span class="c1"># probably title or series. These are the most common</span>
        <span class="c1"># searches.</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SIMPLE_MATCH_FIELDS</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">qu</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_one_field_hypotheses</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hypothesize</span><span class="p">(</span><span class="n">hypotheses</span><span class="p">,</span> <span class="n">qu</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>

        <span class="c1"># As a coda to the above, the query string might be a match</span>
        <span class="c1"># against author. This is the same idea, but it&#39;s a little</span>
        <span class="c1"># more complicated because a book can have multiple</span>
        <span class="c1"># contributors and we&#39;re only interested in certain roles</span>
        <span class="c1"># (such as &#39;narrator&#39;).</span>
        <span class="k">for</span> <span class="n">qu</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_author_hypotheses</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hypothesize</span><span class="p">(</span><span class="n">hypotheses</span><span class="p">,</span> <span class="n">qu</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>

        <span class="c1"># The query string may be looking for a certain topic or</span>
        <span class="c1"># subject matter.</span>
        <span class="k">for</span> <span class="n">qu</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_topic_hypotheses</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hypothesize</span><span class="p">(</span><span class="n">hypotheses</span><span class="p">,</span> <span class="n">qu</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>

        <span class="c1"># The query string might *combine* terms from the title with</span>
        <span class="c1"># terms from some other major field -- probably author name.</span>
        <span class="k">for</span> <span class="n">other_field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">MULTI_MATCH_FIELDS</span><span class="p">:</span>
            <span class="c1"># The weight of this hypothesis should be proportionate to</span>
            <span class="c1"># the difference between a pure match against title, and a</span>
            <span class="c1"># pure match against the field we&#39;re checking.</span>
            <span class="k">for</span> <span class="n">multi_match</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">title_multi_match_for</span><span class="p">(</span><span class="n">other_field</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hypothesize</span><span class="p">(</span><span class="n">hypotheses</span><span class="p">,</span> <span class="n">multi_match</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>

        <span class="c1"># Finally, the query string might contain a filter portion</span>
        <span class="c1"># (e.g. a genre name or target age), with the remainder being</span>
        <span class="c1"># the &quot;real&quot; query string.</span>
        <span class="c1">#</span>
        <span class="c1"># In a query like &quot;nonfiction asteroids&quot;, &quot;nonfiction&quot; would</span>
        <span class="c1"># be the filter portion and &quot;asteroids&quot; would be the query</span>
        <span class="c1"># portion.</span>
        <span class="c1">#</span>
        <span class="c1"># The query portion, if any, is turned into a set of</span>
        <span class="c1"># sub-hypotheses. We then hypothesize that we might filter out</span>
        <span class="c1"># a lot of junk by applying the filter and running the</span>
        <span class="c1"># sub-hypotheses against the filtered set of books.</span>
        <span class="c1">#</span>
        <span class="c1"># In other words, we should try searching across nonfiction</span>
        <span class="c1"># for &quot;asteroids&quot;, and see if it gets better results than</span>
        <span class="c1"># searching for &quot;nonfiction asteroids&quot; in the text fields</span>
        <span class="c1"># (which it will).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_query_parser</span><span class="p">:</span>
            <span class="n">sub_hypotheses</span><span class="p">,</span> <span class="n">filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parsed_query_matches</span>
            <span class="k">if</span> <span class="n">sub_hypotheses</span> <span class="ow">or</span> <span class="n">filters</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sub_hypotheses</span><span class="p">:</span>
                    <span class="c1"># The entire search string was converted into a</span>
                    <span class="c1"># filter (e.g. &quot;young adult romance&quot;). Everything</span>
                    <span class="c1"># that matches this filter should be matched, and</span>
                    <span class="c1"># it should be given a relatively high boost.</span>
                    <span class="n">sub_hypotheses</span> <span class="o">=</span> <span class="n">MatchAll</span><span class="p">()</span>
                    <span class="n">boost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">QUERY_WAS_A_FILTER_WEIGHT</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Part of the search string is a filter, and part</span>
                    <span class="c1"># of it is a bunch of hypotheses that combine with</span>
                    <span class="c1"># the filter to match the entire query</span>
                    <span class="c1"># string. We&#39;ll boost works that match the filter</span>
                    <span class="c1"># slightly, but overall the goal here is to get</span>
                    <span class="c1"># better results by filtering out junk.</span>
                    <span class="n">boost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SLIGHTLY_ABOVE_BASELINE</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hypothesize</span><span class="p">(</span>
                    <span class="n">hypotheses</span><span class="p">,</span> <span class="n">sub_hypotheses</span><span class="p">,</span> <span class="n">boost</span><span class="p">,</span> <span class="n">all_must_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">filters</span><span class="o">=</span><span class="n">filters</span>
                <span class="p">)</span>

        <span class="c1"># That&#39;s it!</span>

        <span class="c1"># The score of any given book is the maximum score it gets from</span>
        <span class="c1"># any of these hypotheses.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_hypotheses</span><span class="p">(</span><span class="n">hypotheses</span><span class="p">)</span>

<div class="viewcode-block" id="Query.match_one_field_hypotheses"><a class="viewcode-back" href="../../core.html#core.external_search.Query.match_one_field_hypotheses">[docs]</a>    <span class="k">def</span> <span class="nf">match_one_field_hypotheses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_field</span><span class="p">,</span> <span class="n">query_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield a number of hypotheses representing different ways in</span>
<span class="sd">        which the query string might be an attempt to match</span>
<span class="sd">        a given field.</span>

<span class="sd">        :param base_field: The name of the field to search,</span>
<span class="sd">            e.g. &quot;title&quot; or &quot;contributors.sort_name&quot;.</span>

<span class="sd">        :param query_string: The query string to use, if different from</span>
<span class="sd">            self.query_string.</span>

<span class="sd">        :yield: A sequence of (hypothesis, weight) 2-tuples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># All hypotheses generated by this method will be weighted</span>
        <span class="c1"># relative to the standard weight for the field being checked.</span>
        <span class="c1">#</span>
        <span class="c1"># The final weight will be this field weight * a coefficient</span>
        <span class="c1"># determined by the type of match * a (potential) coefficient</span>
        <span class="c1"># associated with a fuzzy match.</span>
        <span class="n">base_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">WEIGHT_FOR_FIELD</span><span class="p">[</span><span class="n">base_field</span><span class="p">]</span>

        <span class="n">query_string</span> <span class="o">=</span> <span class="n">query_string</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_string</span>

        <span class="n">keyword_match_coefficient</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">KEYWORD_MATCH_COEFFICIENT_FOR_FIELD</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">base_field</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">DEFAULT_KEYWORD_MATCH_COEFFICIENT</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># A keyword match means the field value is a near-exact</span>
            <span class="c1"># match for the query string. This is one of the best</span>
            <span class="c1"># search results we can possibly return.</span>
            <span class="p">(</span><span class="s1">&#39;keyword&#39;</span><span class="p">,</span> <span class="n">keyword_match_coefficient</span><span class="p">,</span> <span class="n">Term</span><span class="p">),</span>

            <span class="c1"># This is the baseline query -- a phrase match against a</span>
            <span class="c1"># single field. Most queries turn out to represent</span>
            <span class="c1"># consecutive words from a single field.</span>
            <span class="p">(</span><span class="s1">&#39;minimal&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BASELINE_COEFFICIENT</span><span class="p">,</span> <span class="n">MatchPhrase</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_stopwords</span> <span class="ow">and</span> <span class="n">base_field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">STOPWORD_FIELDS</span><span class="p">:</span>
            <span class="c1"># The query might benefit from a phrase match against an</span>
            <span class="c1"># index of this field that includes the stopwords.</span>
            <span class="c1">#</span>
            <span class="c1"># Boost this slightly above the baseline so that if</span>
            <span class="c1"># it matches, it&#39;ll beat out baseline queries.</span>
            <span class="n">fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="s1">&#39;with_stopwords&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SLIGHTLY_ABOVE_BASELINE</span><span class="p">,</span> <span class="n">MatchPhrase</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">base_field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">STEMMABLE_FIELDS</span><span class="p">:</span>
            <span class="c1"># This query might benefit from a non-phrase Match against</span>
            <span class="c1"># a stemmed version of this field. This handles less</span>
            <span class="c1"># common cases where search terms are in the wrong order,</span>
            <span class="c1"># or where only the stemmed version of a word is a match.</span>
            <span class="c1">#</span>
            <span class="c1"># This hypothesis is run at a disadvantage relative to</span>
            <span class="c1"># baseline.</span>
            <span class="n">fields</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BASELINE_COEFFICIENT</span> <span class="o">*</span> <span class="mf">0.75</span><span class="p">,</span> <span class="n">Match</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">subfield</span><span class="p">,</span> <span class="n">match_type_coefficient</span><span class="p">,</span> <span class="n">query_class</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subfield</span><span class="p">:</span>
                <span class="n">field_name</span> <span class="o">=</span> <span class="n">base_field</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">subfield</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">field_name</span> <span class="o">=</span> <span class="n">base_field</span>

            <span class="n">field_weight</span> <span class="o">=</span> <span class="n">base_weight</span> <span class="o">*</span> <span class="n">match_type_coefficient</span>

            <span class="c1"># Here&#39;s what minimum_should_match=2 does:</span>
            <span class="c1">#</span>
            <span class="c1"># If a query string has two or more words, at least two of</span>
            <span class="c1"># those words must match to trigger a Match</span>
            <span class="c1"># hypothesis. This prevents &quot;Foo&quot; from showing up as a top</span>
            <span class="c1"># result for &quot;foo bar&quot;: you have to explain why they typed</span>
            <span class="c1"># &quot;bar&quot;!</span>
            <span class="c1">#</span>
            <span class="c1"># But if there are three words in the search query and</span>
            <span class="c1"># only two of them match, it may be the best we can</span>
            <span class="c1"># do. That&#39;s why we don&#39;t set minimum_should_match any</span>
            <span class="c1"># higher.</span>
            <span class="n">standard_match_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">query</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">query_string</span><span class="p">,</span>
                <span class="n">minimum_should_match</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">query_class</span> <span class="o">==</span> <span class="n">Match</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">field_name</span><span class="p">:</span> <span class="n">standard_match_kwargs</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If we&#39;re doing a Term or MatchPhrase query,</span>
                <span class="c1"># minimum_should_match is not relevant -- we just need</span>
                <span class="c1"># to provide the query string.</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">field_name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_string</span><span class="p">}</span>
            <span class="n">qu</span> <span class="o">=</span> <span class="n">query_class</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">qu</span><span class="p">,</span> <span class="n">field_weight</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_coefficient</span> <span class="ow">and</span> <span class="n">subfield</span> <span class="o">==</span> <span class="s1">&#39;minimal&#39;</span><span class="p">:</span>
                <span class="c1"># Trying one or more fuzzy versions of this hypothesis</span>
                <span class="c1"># would also be appropriate. We only do fuzzy searches</span>
                <span class="c1"># on the subfield with minimal stemming, because we</span>
                <span class="c1"># want to check against something close to what the</span>
                <span class="c1"># patron actually typed.</span>
                <span class="k">for</span> <span class="n">fuzzy_match</span><span class="p">,</span> <span class="n">fuzzy_query_coefficient</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fuzzy_matches</span><span class="p">(</span>
                    <span class="n">field_name</span><span class="p">,</span> <span class="o">**</span><span class="n">standard_match_kwargs</span>
                <span class="p">):</span>
                    <span class="k">yield</span> <span class="n">fuzzy_match</span><span class="p">,</span> <span class="p">(</span><span class="n">field_weight</span> <span class="o">*</span> <span class="n">fuzzy_query_coefficient</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">match_author_hypotheses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield a sequence of query objects representing possible ways in</span>
<span class="sd">        which a query string might represent a book&#39;s author.</span>

<span class="sd">        :param query_string: The query string that might be the name</span>
<span class="sd">            of an author.</span>

<span class="sd">        :yield: A sequence of Elasticsearch-DSL query objects to be</span>
<span class="sd">            considered as hypotheses.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ask Elasticsearch to match what was typed against</span>
        <span class="c1"># contributors.display_name.</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_author_field_must_match</span><span class="p">(</span>
            <span class="s1">&#39;display_name&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_string</span>
        <span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>

        <span class="c1"># Although almost nobody types a sort name into a search box,</span>
        <span class="c1"># they may copy-and-paste one. Furthermore, we may only know</span>
        <span class="c1"># some contributors by their sort name.  Try to convert what</span>
        <span class="c1"># was typed into a sort name, and ask Elasticsearch to match</span>
        <span class="c1"># that against contributors.sort_name.</span>
        <span class="n">sort_name</span> <span class="o">=</span> <span class="n">display_name_to_sort_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sort_name</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_author_field_must_match</span><span class="p">(</span><span class="s1">&#39;sort_name&#39;</span><span class="p">,</span> <span class="n">sort_name</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">_author_field_must_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_field</span><span class="p">,</span> <span class="n">query_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield queries that match either the keyword or minimally stemmed</span>
<span class="sd">        version of one of the fields in the contributors sub-document.</span>

<span class="sd">        The contributor must also have an appropriate authorship role.</span>

<span class="sd">        :param base_field: The base name of the contributors field to</span>
<span class="sd">        match -- probably either &#39;display_name&#39; or &#39;sort_name&#39;.</span>

<span class="sd">        :param must_match: The query string to match against.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query_string</span> <span class="o">=</span> <span class="n">query_string</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_string</span>
        <span class="n">field_name</span> <span class="o">=</span> <span class="s1">&#39;contributors.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base_field</span>
        <span class="k">for</span> <span class="n">author_matches</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_one_field_hypotheses</span><span class="p">(</span>
            <span class="n">field_name</span><span class="p">,</span> <span class="n">query_string</span>
        <span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_role_must_also_match</span><span class="p">(</span><span class="n">author_matches</span><span class="p">),</span> <span class="n">weight</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_role_must_also_match</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base_query</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Modify a query to add a restriction against the contributors</span>
<span class="sd">        sub-document, so that it also matches an appropriate role.</span>

<span class="sd">        NOTE: We can get fancier here by yielding several</span>
<span class="sd">        differently-weighted hypotheses that weight Primary Author</span>
<span class="sd">        higher than Author, and Author higher than Narrator. However,</span>
<span class="sd">        in practice this dramatically slows down searches without</span>
<span class="sd">        greatly improving results.</span>

<span class="sd">        :param base_query: An Elasticsearch-DSL query object to use</span>
<span class="sd">           when adding restrictions.</span>
<span class="sd">        :param base_score: The relative score of the base query. The resulting</span>
<span class="sd">           hypotheses will be weighted based on this score.</span>
<span class="sd">        :return: A modified hypothesis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">match_role</span> <span class="o">=</span> <span class="n">Terms</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s2">&quot;contributors.role&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="n">SEARCH_RELEVANT_ROLES</span><span class="p">})</span>
        <span class="n">match_both</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="p">[</span><span class="n">base_query</span><span class="p">,</span> <span class="n">match_role</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_nest</span><span class="p">(</span><span class="s1">&#39;contributors&#39;</span><span class="p">,</span> <span class="n">match_both</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">match_topic_hypotheses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield a number of hypotheses representing different</span>
<span class="sd">        ways in which the query string might be a topic match.</span>

<span class="sd">        Currently there is only one such hypothesis.</span>

<span class="sd">        TODO: We probably want to introduce a fuzzy version of this</span>
<span class="sd">        hypothesis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note that we are using the default analyzer, which gives us</span>
        <span class="c1"># the stemmed versions of these fields.</span>
        <span class="n">qu</span> <span class="o">=</span> <span class="n">MultiMatch</span><span class="p">(</span>
            <span class="n">query</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">query_string</span><span class="p">,</span>
            <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;summary&quot;</span><span class="p">,</span> <span class="s2">&quot;classifications.term&quot;</span><span class="p">],</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;best_fields&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">yield</span> <span class="n">qu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">WEIGHT_FOR_FIELD</span><span class="p">[</span><span class="s1">&#39;summary&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="Query.title_multi_match_for"><a class="viewcode-back" href="../../core.html#core.external_search.Query.title_multi_match_for">[docs]</a>    <span class="k">def</span> <span class="nf">title_multi_match_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_field</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method to create a MultiMatch hypothesis that crosses</span>
<span class="sd">        multiple fields.</span>

<span class="sd">        This strategy only works if everything is spelled correctly,</span>
<span class="sd">        since we can&#39;t combine a &quot;cross_fields&quot; Multimatch query</span>
<span class="sd">        with a fuzzy search.</span>

<span class="sd">        :yield: At most one (hypothesis, weight) 2-tuple.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">words</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># To match two different fields we need at least two</span>
            <span class="c1"># words. We don&#39;t have that, so there&#39;s no point in even</span>
            <span class="c1"># making this hypothesis.</span>
            <span class="k">return</span>

        <span class="c1"># We only search the &#39;.minimal&#39; variants of these fields.</span>
        <span class="n">field_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;title.minimal&#39;</span><span class="p">,</span> <span class="n">other_field</span> <span class="o">+</span> <span class="s2">&quot;.minimal&quot;</span><span class="p">]</span>

        <span class="c1"># The weight of this hypothesis should be somewhere between</span>
        <span class="c1"># the weight of a pure title match, and the weight of a pure</span>
        <span class="c1"># match against the field we&#39;re checking.</span>
        <span class="n">title_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">WEIGHT_FOR_FIELD</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span>
        <span class="n">other_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">WEIGHT_FOR_FIELD</span><span class="p">[</span><span class="n">other_field</span><span class="p">]</span>
        <span class="n">combined_weight</span> <span class="o">=</span> <span class="n">other_weight</span> <span class="o">*</span> <span class="p">(</span><span class="n">other_weight</span><span class="o">/</span><span class="n">title_weight</span><span class="p">)</span>

        <span class="n">hypothesis</span> <span class="o">=</span> <span class="n">MultiMatch</span><span class="p">(</span>
            <span class="n">query</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">query_string</span><span class="p">,</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="n">field_names</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;cross_fields&quot;</span><span class="p">,</span>

            <span class="c1"># This hypothesis must be able to explain the entire query</span>
            <span class="c1"># string. Otherwise the weight contributed by the title</span>
            <span class="c1"># will boost _partial_ title matches over better matches</span>
            <span class="c1"># obtained some other way.</span>
            <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;and&quot;</span><span class="p">,</span>
            <span class="n">minimum_should_match</span><span class="o">=</span><span class="s2">&quot;100%&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">yield</span> <span class="n">hypothesis</span><span class="p">,</span> <span class="n">combined_weight</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parsed_query_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deal with a query string that contains information that should be</span>
<span class="sd">        exactly matched against a controlled vocabulary</span>
<span class="sd">        (e.g. &quot;nonfiction&quot; or &quot;grade 5&quot;) along with information that</span>
<span class="sd">        is more search-like (such as a title or author).</span>

<span class="sd">        The match information is pulled out of the query string and</span>
<span class="sd">        used to make a series of match_phrase queries. The rest of the</span>
<span class="sd">        information is used in a simple query that matches basic</span>
<span class="sd">        fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">QueryParser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">query_string</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">match_queries</span><span class="p">,</span> <span class="n">parser</span><span class="o">.</span><span class="n">filters</span>

    <span class="k">def</span> <span class="nf">_fuzzy_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make one or more fuzzy Match versions of any MatchPhrase</span>
<span class="sd">        hypotheses, scoring them at a fraction of the original</span>
<span class="sd">        version.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># fuzziness=&quot;AUTO&quot; means the number of typoes allowed is</span>
        <span class="c1"># proportional to the length of the query.</span>
        <span class="c1">#</span>
        <span class="c1"># max_expansions limits the number of possible alternates</span>
        <span class="c1"># Elasticsearch will consider for any given word.</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fuzziness</span><span class="o">=</span><span class="s2">&quot;AUTO&quot;</span><span class="p">,</span> <span class="n">max_expansions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">Match</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">field_name</span> <span class="p">:</span> <span class="n">kwargs</span><span class="p">}),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_coefficient</span> <span class="o">*</span> <span class="mf">0.50</span>

        <span class="c1"># Assuming that no typoes were made in the first</span>
        <span class="c1"># character of a word (usually a safe assumption) we</span>
        <span class="c1"># can bump the score up to 75% of the non-fuzzy</span>
        <span class="c1"># hypothesis.</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;prefix_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">yield</span> <span class="n">Match</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">field_name</span> <span class="p">:</span> <span class="n">kwargs</span><span class="p">}),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fuzzy_coefficient</span> <span class="o">*</span> <span class="mf">0.75</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_hypothesize</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">hypotheses</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">boost</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a hypothesis to the ones to be tested for each book.</span>

<span class="sd">        :param hypotheses: A list of active hypotheses, to be</span>
<span class="sd">        appended to if necessary.</span>

<span class="sd">        :param query: An Elasticsearch-DSL Query object (or list of</span>
<span class="sd">        Query objects) to be used as the basis for this hypothesis. If</span>
<span class="sd">        there&#39;s nothing here, no new hypothesis will be generated.</span>

<span class="sd">        :param boost: Boost the overall weight of this hypothesis</span>
<span class="sd">        relative to other hypotheses being tested.</span>

<span class="sd">        :param kwargs: Keyword arguments for the _boost method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">query</span> <span class="ow">or</span> <span class="n">filters</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_boost</span><span class="p">(</span><span class="n">boost</span><span class="o">=</span><span class="n">boost</span><span class="p">,</span> <span class="n">queries</span><span class="o">=</span><span class="n">query</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">query</span><span class="p">:</span>
            <span class="n">hypotheses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hypotheses</span></div>


<div class="viewcode-block" id="QueryParser"><a class="viewcode-back" href="../../core.html#core.external_search.QueryParser">[docs]</a><span class="k">class</span> <span class="nc">QueryParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Attempt to parse filter information out of a query string.</span>

<span class="sd">    This class is where we make sense of queries like the following:</span>

<span class="sd">      asteroids nonfiction</span>
<span class="sd">      grade 5 dogs</span>
<span class="sd">      young adult romance</span>
<span class="sd">      divorce age 10 and up</span>

<span class="sd">    These queries contain information that can best be thought of in</span>
<span class="sd">    terms of a filter against specific fields (&quot;nonfiction&quot;, &quot;grade</span>
<span class="sd">    5&quot;, &quot;romance&quot;). Books either match these criteria or they don&#39;t.</span>

<span class="sd">    These queries may also contain information that can be thought of</span>
<span class="sd">    in terms of a search (&quot;asteroids&quot;, &quot;dogs&quot;) -- books may match</span>
<span class="sd">    these criteria to a greater or lesser extent.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="n">query_class</span><span class="o">=</span><span class="n">Query</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the query string and create a list of clauses</span>
<span class="sd">        that will boost certain types of books.</span>

<span class="sd">        Use .query to get an Elasticsearch-DSL Query object.</span>

<span class="sd">        :param query_class: Pass in a mock of Query here during testing</span>
<span class="sd">        to generate &#39;query&#39; objects that are easier for you to test.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_query_string</span> <span class="o">=</span> <span class="n">query_string</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_class</span> <span class="o">=</span> <span class="n">query_class</span>

        <span class="c1"># We start with no match queries and no filter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_queries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># We handle genre first so that, e.g. &#39;Science Fiction&#39; doesn&#39;t</span>
        <span class="c1"># get chomped up by the search for &#39;fiction&#39;.</span>

        <span class="c1"># Handle the &#39;romance&#39; part of &#39;young adult romance&#39;</span>
        <span class="n">genre</span><span class="p">,</span> <span class="n">genre_match</span> <span class="o">=</span> <span class="n">KeywordBasedClassifier</span><span class="o">.</span><span class="n">genre_match</span><span class="p">(</span><span class="n">query_string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">genre</span><span class="p">:</span>
            <span class="n">query_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_match_term_filter</span><span class="p">(</span>
                <span class="n">genre</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;genres.name&#39;</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="n">genre_match</span>
            <span class="p">)</span>

        <span class="c1"># Handle the &#39;young adult&#39; part of &#39;young adult romance&#39;</span>
        <span class="n">audience</span><span class="p">,</span> <span class="n">audience_match</span> <span class="o">=</span> <span class="n">KeywordBasedClassifier</span><span class="o">.</span><span class="n">audience_match</span><span class="p">(</span>
            <span class="n">query_string</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">audience</span><span class="p">:</span>
            <span class="n">query_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_match_term_filter</span><span class="p">(</span>
                <span class="n">audience</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="s1">&#39;audience&#39;</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span>
                <span class="n">audience_match</span>
            <span class="p">)</span>

        <span class="c1"># Handle the &#39;nonfiction&#39; part of &#39;asteroids nonfiction&#39;</span>
        <span class="n">fiction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bnonfiction\b&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">query_string</span><span class="p">):</span>
            <span class="n">fiction</span> <span class="o">=</span> <span class="s2">&quot;nonfiction&quot;</span>
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\bfiction\b&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">query_string</span><span class="p">):</span>
            <span class="n">fiction</span> <span class="o">=</span> <span class="s2">&quot;fiction&quot;</span>
        <span class="n">query_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_match_term_filter</span><span class="p">(</span>
            <span class="n">fiction</span><span class="p">,</span> <span class="s1">&#39;fiction&#39;</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="n">fiction</span>
        <span class="p">)</span>
        <span class="c1"># Handle the &#39;grade 5&#39; part of &#39;grade 5 dogs&#39;</span>
        <span class="n">age_from_grade</span><span class="p">,</span> <span class="n">grade_match</span> <span class="o">=</span> <span class="n">GradeLevelClassifier</span><span class="o">.</span><span class="n">target_age_match</span><span class="p">(</span>
            <span class="n">query_string</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">age_from_grade</span> <span class="ow">and</span> <span class="n">age_from_grade</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">age_from_grade</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">query_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_target_age_filter</span><span class="p">(</span>
            <span class="n">age_from_grade</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="n">grade_match</span>
        <span class="p">)</span>

        <span class="c1"># Handle the &#39;age 10 and up&#39; part of &#39;divorce age 10 and up&#39;</span>
        <span class="n">age</span><span class="p">,</span> <span class="n">age_match</span> <span class="o">=</span> <span class="n">AgeClassifier</span><span class="o">.</span><span class="n">target_age_match</span><span class="p">(</span><span class="n">query_string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">age</span> <span class="ow">and</span> <span class="n">age</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">age</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">query_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_target_age_filter</span><span class="p">(</span><span class="n">age</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="n">age_match</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">final_query_string</span> <span class="o">=</span> <span class="n">query_string</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_query_string</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Someone who searched for &#39;young adult romance&#39; ended up</span>
            <span class="c1"># with an empty query string -- they matched an audience</span>
            <span class="c1"># and a genre, and now there&#39;s nothing else to match.</span>
            <span class="k">return</span>

        <span class="c1"># Someone who searched for &#39;asteroids nonfiction&#39; ended up</span>
        <span class="c1"># with a query string of &#39;asteroids&#39;. Their query string</span>
        <span class="c1"># has a filter-type component and a query-type component.</span>
        <span class="c1">#</span>
        <span class="c1"># What is likely to be in this query-type component?</span>
        <span class="c1">#</span>
        <span class="c1"># It could be anything that would go into a regular query. And</span>
        <span class="c1"># we have lots of different ways of checking a regular query --</span>
        <span class="c1"># different hypotheses, fuzzy matches, etc. So the simplest thing</span>
        <span class="c1"># to do is to create a Query object for the smaller search query</span>
        <span class="c1"># and see what its .elasticsearch_query is.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_query_string</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_query_string</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_query_string</span><span class="p">):</span>
            <span class="n">recursive</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_class</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_query_string</span><span class="p">,</span> <span class="n">use_query_parser</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span><span class="o">.</span><span class="n">elasticsearch_query</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_queries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span>

<div class="viewcode-block" id="QueryParser.add_match_term_filter"><a class="viewcode-back" href="../../core.html#core.external_search.QueryParser.add_match_term_filter">[docs]</a>    <span class="k">def</span> <span class="nf">add_match_term_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="n">matched_portion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a match query that finds documents whose value for `field`</span>
<span class="sd">        matches `query`.</span>

<span class="sd">        Add it to `self.filters`, and remove the relevant portion</span>
<span class="sd">        of `query_string` so it doesn&#39;t get reused.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">query</span><span class="p">:</span>
            <span class="c1"># This is not a relevant part of the query string.</span>
            <span class="k">return</span> <span class="n">query_string</span>
        <span class="n">match_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_class</span><span class="o">.</span><span class="n">_match_term</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match_query</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_without_match</span><span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="n">matched_portion</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryParser.add_target_age_filter"><a class="viewcode-back" href="../../core.html#core.external_search.QueryParser.add_target_age_filter">[docs]</a>    <span class="k">def</span> <span class="nf">add_target_age_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="n">matched_portion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a query that finds documents whose value for `target_age`</span>
<span class="sd">        matches `query`.</span>

<span class="sd">        Add a filter version of this query to `.match_queries` (so that</span>
<span class="sd">        all documents outside the target age are filtered out).</span>

<span class="sd">        Add a boosted version of this query to `.match_queries` (so</span>
<span class="sd">        that documents that cluster tightly around the target age are</span>
<span class="sd">        boosted over documents that span a huge age range).</span>

<span class="sd">        Remove the relevant portion of `query_string` so it doesn&#39;t get</span>
<span class="sd">        reused.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">query</span><span class="p">:</span>
            <span class="c1"># This is not a relevant part of the query string.</span>
            <span class="k">return</span> <span class="n">query_string</span>

        <span class="nb">filter</span><span class="p">,</span> <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_class</span><span class="o">.</span><span class="n">make_target_age_query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">filter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_queries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_without_match</span><span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="n">matched_portion</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_without_match</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take the portion of a query string that matched a controlled</span>
<span class="sd">        vocabulary, and remove it from the query string, so it</span>
<span class="sd">        doesn&#39;t get reused later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the match was &quot;children&quot; and the query string was</span>
        <span class="c1"># &quot;children&#39;s&quot;, we want to remove the &quot;&#39;s&quot; as well as</span>
        <span class="c1"># the match. We want to remove everything up to the</span>
        <span class="c1"># next word boundary that&#39;s not an apostrophe or a</span>
        <span class="c1"># dash.</span>
        <span class="n">word_boundary_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\b</span><span class="si">%s</span><span class="s2">[\w&#39;\-]*\b&quot;</span>

        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="n">word_boundary_pattern</span> <span class="o">%</span> <span class="n">match</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span>
        <span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">query_string</span><span class="p">)</span></div>


<div class="viewcode-block" id="Filter"><a class="viewcode-back" href="../../core.html#core.external_search.Filter">[docs]</a><span class="k">class</span> <span class="nc">Filter</span><span class="p">(</span><span class="n">SearchBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A filter for search results.</span>

<span class="sd">    This covers every reason you might want to not exclude a search</span>
<span class="sd">    result that would otherise match the query string -- wrong media,</span>
<span class="sd">    wrong language, not available in the patron&#39;s library, etc.</span>

<span class="sd">    This also covers every way you might want to order the search</span>
<span class="sd">    results: either by relevance to the search query (the default), or</span>
<span class="sd">    by a specific field (e.g. author) as described by a Facets object.</span>

<span class="sd">    It also covers additional calculated values you might need when</span>
<span class="sd">    presenting the search results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># When search results include known script fields, we need to</span>
    <span class="c1"># wrap the works we would be returning in WorkSearchResults so</span>
    <span class="c1"># the useful information from the search engine isn&#39;t lost.</span>
    <span class="n">KNOWN_SCRIPT_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;last_update&#39;</span><span class="p">]</span>

    <span class="c1"># In general, someone looking for things &quot;by this person&quot; is</span>
    <span class="c1"># probably looking for one of these roles.</span>
    <span class="n">AUTHOR_MATCH_ROLES</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Contributor</span><span class="o">.</span><span class="n">AUTHOR_ROLES</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span>
        <span class="n">Contributor</span><span class="o">.</span><span class="n">NARRATOR_ROLE</span><span class="p">,</span> <span class="n">Contributor</span><span class="o">.</span><span class="n">EDITOR_ROLE</span><span class="p">,</span>
        <span class="n">Contributor</span><span class="o">.</span><span class="n">DIRECTOR_ROLE</span><span class="p">,</span> <span class="n">Contributor</span><span class="o">.</span><span class="n">ACTOR_ROLE</span>
    <span class="p">]</span>

<div class="viewcode-block" id="Filter.from_worklist"><a class="viewcode-back" href="../../core.html#core.external_search.Filter.from_worklist">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_worklist</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_db</span><span class="p">,</span> <span class="n">worklist</span><span class="p">,</span> <span class="n">facets</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a Filter that finds only works that belong in the given</span>
<span class="sd">        WorkList and EntryPoint.</span>

<span class="sd">        :param worklist: A WorkList</span>
<span class="sd">        :param facets: A SearchFacets object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">library</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">get_library</span><span class="p">(</span><span class="n">_db</span><span class="p">)</span>
        <span class="c1"># For most configuration settings there is a single value --</span>
        <span class="c1"># either defined on the WorkList or defined by its parent.</span>
        <span class="n">inherit_one</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">inherited_value</span>
        <span class="n">media</span> <span class="o">=</span> <span class="n">inherit_one</span><span class="p">(</span><span class="s1">&#39;media&#39;</span><span class="p">)</span>
        <span class="n">languages</span> <span class="o">=</span> <span class="n">inherit_one</span><span class="p">(</span><span class="s1">&#39;languages&#39;</span><span class="p">)</span>
        <span class="n">fiction</span> <span class="o">=</span> <span class="n">inherit_one</span><span class="p">(</span><span class="s1">&#39;fiction&#39;</span><span class="p">)</span>
        <span class="n">audiences</span> <span class="o">=</span> <span class="n">inherit_one</span><span class="p">(</span><span class="s1">&#39;audiences&#39;</span><span class="p">)</span>
        <span class="n">target_age</span> <span class="o">=</span> <span class="n">inherit_one</span><span class="p">(</span><span class="s1">&#39;target_age&#39;</span><span class="p">)</span>
        <span class="n">collections</span> <span class="o">=</span> <span class="n">inherit_one</span><span class="p">(</span><span class="s1">&#39;collection_ids&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">library</span>

        <span class="n">license_datasource_id</span> <span class="o">=</span> <span class="n">inherit_one</span><span class="p">(</span><span class="s1">&#39;license_datasource_id&#39;</span><span class="p">)</span>

        <span class="c1"># For genre IDs and CustomList IDs, we might get a separate</span>
        <span class="c1"># set of restrictions from every item in the WorkList hierarchy.</span>
        <span class="c1"># _All_ restrictions must be met for a work to match the filter.</span>
        <span class="n">inherit_some</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">inherited_values</span>
        <span class="n">genre_id_restrictions</span> <span class="o">=</span> <span class="n">inherit_some</span><span class="p">(</span><span class="s1">&#39;genre_ids&#39;</span><span class="p">)</span>
        <span class="n">customlist_id_restrictions</span> <span class="o">=</span> <span class="n">inherit_some</span><span class="p">(</span><span class="s1">&#39;customlist_ids&#39;</span><span class="p">)</span>

        <span class="c1"># See if there are any excluded audiobook sources on this</span>
        <span class="c1"># site.</span>
        <span class="n">excluded</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ConfigurationSetting</span><span class="o">.</span><span class="n">excluded_audio_data_sources</span><span class="p">(</span><span class="n">_db</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">excluded_audiobook_data_sources</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">DataSource</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">_db</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">excluded</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">library</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">allow_holds</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allow_holds</span> <span class="o">=</span> <span class="n">library</span><span class="o">.</span><span class="n">allow_holds</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">collections</span><span class="p">,</span> <span class="n">media</span><span class="p">,</span> <span class="n">languages</span><span class="p">,</span> <span class="n">fiction</span><span class="p">,</span> <span class="n">audiences</span><span class="p">,</span>
            <span class="n">target_age</span><span class="p">,</span> <span class="n">genre_id_restrictions</span><span class="p">,</span> <span class="n">customlist_id_restrictions</span><span class="p">,</span>
            <span class="n">facets</span><span class="p">,</span>
            <span class="n">excluded_audiobook_data_sources</span><span class="o">=</span><span class="n">excluded_audiobook_data_sources</span><span class="p">,</span>
            <span class="n">allow_holds</span><span class="o">=</span><span class="n">allow_holds</span><span class="p">,</span> <span class="n">license_datasource</span><span class="o">=</span><span class="n">license_datasource_id</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collections</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">media</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">languages</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fiction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">audiences</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_age</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">genre_restriction_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">customlist_restriction_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">facets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">script_fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        All arguments are optional. Passing in an empty set of</span>
<span class="sd">        arguments will match everything in the search index that</span>
<span class="sd">        matches the universal filters (e.g. works must be</span>
<span class="sd">        presentation-ready).</span>

<span class="sd">        :param collections: Find only works that are licensed to one of</span>
<span class="sd">        these Collections.</span>

<span class="sd">        :param media: Find only works in this list of media (use the</span>
<span class="sd">        constants from Edition such as Edition.BOOK_MEDIUM).</span>

<span class="sd">        :param languages: Find only works in these languages (use</span>
<span class="sd">        ISO-639-2 alpha-3 codes).</span>

<span class="sd">        :param fiction: Find only works with this fiction status.</span>

<span class="sd">        :param audiences: Find only works with a target audience in this list.</span>

<span class="sd">        :param target_age: Find only works with a target age in this</span>
<span class="sd">        range. (Use a 2-tuple, or a number to represent a specific</span>
<span class="sd">        age.)</span>

<span class="sd">        :param genre_restriction_sets: A sequence of lists of Genre</span>
<span class="sd">        objects or IDs. Each list represents an independent</span>
<span class="sd">        restriction. For each restriction, a work only matches if it&#39;s</span>
<span class="sd">        in one of the appropriate Genres.</span>

<span class="sd">        :param customlist_restriction_sets: A sequence of lists of</span>
<span class="sd">        CustomList objects or IDs. Each list represents an independent</span>
<span class="sd">        restriction. For each restriction, a work only matches if it&#39;s</span>
<span class="sd">        in one of the appropriate CustomLists.</span>

<span class="sd">        :param facets: A faceting object that can put further restrictions</span>
<span class="sd">        on the match.</span>

<span class="sd">        :param script_fields: A list of registered script fields to</span>
<span class="sd">        run on the search results.</span>

<span class="sd">        (These minor arguments were made into unnamed keyword arguments</span>
<span class="sd">        to avoid cluttering the method signature:)</span>

<span class="sd">        :param excluded_audiobook_data_sources: A list of DataSources that</span>
<span class="sd">        provide audiobooks known to be unsupported on this system.</span>
<span class="sd">        Such audiobooks will always be excluded from results.</span>

<span class="sd">        :param identifiers: A list of Identifier or IdentifierData</span>
<span class="sd">        objects. Only books associated with one of these identifiers</span>
<span class="sd">        will be matched.</span>

<span class="sd">        :param allow_holds: If this is False, books with no available</span>
<span class="sd">        copies will be excluded from results.</span>

<span class="sd">        :param series: If this is set to a string, only books in a matching</span>
<span class="sd">        series will be included. If set to True, books that belong to _any_</span>
<span class="sd">        series will be included.</span>

<span class="sd">        :param author: If this is set to a Contributor or</span>
<span class="sd">        ContributorData, then only books where this person had an</span>
<span class="sd">        authorship role will be included.</span>

<span class="sd">        :param license_datasource: If this is set to a DataSource,</span>
<span class="sd">        only books with LicensePools from that DataSource will be</span>
<span class="sd">        included.</span>

<span class="sd">        :param updated_after: If this is set to a datetime, only books</span>
<span class="sd">        whose Work records (~bibliographic metadata) have been updated since</span>
<span class="sd">        that time will be included in results.</span>

<span class="sd">        :param match_nothing: If this is set to True, the search will</span>
<span class="sd">        not even be performed -- we know for some other reason that an</span>
<span class="sd">        empty set of search results should be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">collections</span><span class="p">,</span> <span class="n">Library</span><span class="p">):</span>
            <span class="c1"># Find all works in this Library&#39;s collections.</span>
            <span class="n">collections</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">collections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collection_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_ids</span><span class="p">(</span><span class="n">collections</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">media</span> <span class="o">=</span> <span class="n">media</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">languages</span> <span class="o">=</span> <span class="n">languages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fiction</span> <span class="o">=</span> <span class="n">fiction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_audiences</span> <span class="o">=</span> <span class="n">audiences</span>

        <span class="k">if</span> <span class="n">target_age</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_age</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_age</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_age</span><span class="p">,</span> <span class="n">target_age</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_age</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_age</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_age</span> <span class="o">=</span> <span class="n">target_age</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># It&#39;s a SQLAlchemy range object. Convert it to a tuple.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_age</span> <span class="o">=</span> <span class="n">numericrange_to_tuple</span><span class="p">(</span><span class="n">target_age</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_age</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Filter the lists of database IDs to make sure we aren&#39;t</span>
        <span class="c1"># storing any database objects.</span>
        <span class="k">if</span> <span class="n">genre_restriction_sets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genre_restriction_sets</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filter_ids</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">genre_restriction_sets</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">genre_restriction_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">customlist_restriction_sets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">customlist_restriction_sets</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filter_ids</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">customlist_restriction_sets</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">customlist_restriction_sets</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Pull less-important values out of the keyword arguments.</span>
        <span class="n">excluded_audiobook_data_sources</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s1">&#39;excluded_audiobook_data_sources&#39;</span><span class="p">,</span> <span class="p">[]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excluded_audiobook_data_sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_ids</span><span class="p">(</span>
            <span class="n">excluded_audiobook_data_sources</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_holds</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;allow_holds&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">updated_after</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;updated_after&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;series&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">author</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;author&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_score</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;min_score&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">match_nothing</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;match_nothing&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">license_datasources</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;license_datasource&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">license_datasources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_ids</span><span class="p">(</span><span class="n">license_datasources</span><span class="p">)</span>

        <span class="n">identifiers</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;identifiers&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scrub_identifiers</span><span class="p">(</span><span class="n">identifiers</span><span class="p">))</span>

        <span class="c1"># At this point there should be no keyword arguments -- you can&#39;t pass</span>
        <span class="c1"># whatever you want into this method.</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown keyword arguments: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Establish default values for additional restrictions that may be</span>
        <span class="c1"># imposed by the Facets object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimum_featured_quality</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">availability</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subcollection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_ascending</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">script_fields</span> <span class="o">=</span> <span class="n">script_fields</span> <span class="ow">or</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Give the Facets object a chance to modify any or all of this</span>
        <span class="c1"># information.</span>
        <span class="k">if</span> <span class="n">facets</span><span class="p">:</span>
            <span class="n">facets</span><span class="o">.</span><span class="n">modify_search_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scoring_functions</span> <span class="o">=</span> <span class="n">facets</span><span class="o">.</span><span class="n">scoring_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scoring_functions</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">audiences</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the appropriate audiences for this query.</span>

<span class="sd">        This will be whatever audiences were provided, but it will</span>
<span class="sd">        probably also include the &#39;All Ages&#39; audience.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_audiences</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_audiences</span>

        <span class="n">as_is</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_audiences</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">as_is</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">as_is</span> <span class="o">=</span> <span class="p">[</span><span class="n">as_is</span><span class="p">]</span>

        <span class="c1"># At this point we know we have a specific list of audiences.</span>
        <span class="c1"># We&#39;re either going to return that list as-is, or we&#39;ll</span>
        <span class="c1"># return that list plus ALL_AGES.</span>
        <span class="n">with_all_ages</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">as_is</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">Classifier</span><span class="o">.</span><span class="n">AUDIENCE_ALL_AGES</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">Classifier</span><span class="o">.</span><span class="n">AUDIENCE_ALL_AGES</span> <span class="ow">in</span> <span class="n">as_is</span><span class="p">:</span>
            <span class="c1"># ALL_AGES is explicitly included.</span>
            <span class="k">return</span> <span class="n">as_is</span>

        <span class="c1"># If YOUNG_ADULT or ADULT is an audience, then ALL_AGES is</span>
        <span class="c1"># always going to be an additional audience.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">as_is</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Classifier</span><span class="o">.</span><span class="n">AUDIENCE_YOUNG_ADULT</span><span class="p">,</span>
                                    <span class="n">Classifier</span><span class="o">.</span><span class="n">AUDIENCE_ADULT</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">with_all_ages</span>

        <span class="c1"># At this point, if CHILDREN is _not_ included, we know that</span>
        <span class="c1"># ALL_AGES is not included. Specifically, ALL_AGES content</span>
        <span class="c1"># does _not_ belong in ADULTS_ONLY or RESEARCH.</span>
        <span class="k">if</span> <span class="n">Classifier</span><span class="o">.</span><span class="n">AUDIENCE_CHILDREN</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">as_is</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">as_is</span>

        <span class="c1"># Now we know that CHILDREN is an audience. It&#39;s going to come</span>
        <span class="c1"># down to the upper bound on the target age.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_age</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_age</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_age</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Classifier</span><span class="o">.</span><span class="n">ALL_AGES_AGE_CUTOFF</span><span class="p">):</span>
            <span class="c1"># The audience for this query does not include any kids</span>
            <span class="c1"># who are expected to have the reading fluency necessary</span>
            <span class="c1"># for ALL_AGES books.</span>
            <span class="k">return</span> <span class="n">as_is</span>
        <span class="k">return</span> <span class="n">with_all_ages</span>

<div class="viewcode-block" id="Filter.build"><a class="viewcode-back" href="../../core.html#core.external_search.Filter.build">[docs]</a>    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_chain_filters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert this object to an Elasticsearch Filter object.</span>

<span class="sd">        :return: A 2-tuple (filter, nested_filters). Filters on fields</span>
<span class="sd">           within nested documents (such as</span>
<span class="sd">           &#39;licensepools.collection_id&#39;) must be applied as subqueries</span>
<span class="sd">           to the query that will eventually be created from this</span>
<span class="sd">           filter. `nested_filters` is a dictionary that maps a path</span>
<span class="sd">           to a list of filters to apply to that path.</span>

<span class="sd">        :param _chain_filters: Mock function to use instead of</span>
<span class="sd">            Filter._chain_filters</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Since a Filter object can be modified after it&#39;s created, we</span>
        <span class="c1"># need to scrub all the inputs, whether or not they were</span>
        <span class="c1"># scrubbed in the constructor.</span>
        <span class="n">scrub_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scrub_list</span>
        <span class="n">filter_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_ids</span>

        <span class="n">chain</span> <span class="o">=</span> <span class="n">_chain_filters</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chain_filters</span>

        <span class="n">f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">nested_filters</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_nothing</span><span class="p">:</span>
            <span class="c1"># This Filter should match nothing. There&#39;s no need to</span>
            <span class="c1"># get fancy.</span>
            <span class="k">return</span> <span class="n">MatchNone</span><span class="p">(),</span> <span class="n">nested_filters</span>

        <span class="n">collection_ids</span> <span class="o">=</span> <span class="n">filter_ids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collection_ids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">collection_ids</span><span class="p">:</span>
            <span class="n">collection_match</span> <span class="o">=</span> <span class="n">Terms</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.collection_id&#39;</span> <span class="p">:</span> <span class="n">collection_ids</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;licensepools&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collection_match</span><span class="p">)</span>

        <span class="n">license_datasources</span> <span class="o">=</span> <span class="n">filter_ids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">license_datasources</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">license_datasources</span><span class="p">:</span>
            <span class="n">datasource_match</span> <span class="o">=</span> <span class="n">Terms</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.data_source_id&#39;</span> <span class="p">:</span> <span class="n">license_datasources</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;licensepools&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">datasource_match</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">author</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;contributors&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">author_filter</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">media</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Terms</span><span class="p">(</span><span class="n">medium</span><span class="o">=</span><span class="n">scrub_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">media</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">languages</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Terms</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="n">scrub_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">languages</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fiction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fiction</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;fiction&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;nonfiction&#39;</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Term</span><span class="p">(</span><span class="n">fiction</span><span class="o">=</span><span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># The book must belong to _some_ series.</span>
                <span class="c1">#</span>
                <span class="c1"># That is, series must exist (have a non-null value) and</span>
                <span class="c1"># have a value other than the empty string.</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Exists</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="s2">&quot;series&quot;</span><span class="p">))</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must_not</span><span class="o">=</span><span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s2">&quot;series.keyword&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">})]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s2">&quot;series.keyword&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">}))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">audiences</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Terms</span><span class="p">(</span><span class="n">audience</span><span class="o">=</span><span class="n">scrub_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">audiences</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">research</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scrub</span><span class="p">(</span><span class="n">Classifier</span><span class="o">.</span><span class="n">AUDIENCE_RESEARCH</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must_not</span><span class="o">=</span><span class="p">[</span><span class="n">Term</span><span class="p">(</span><span class="n">audience</span><span class="o">=</span><span class="n">research</span><span class="p">)]))</span>

        <span class="n">target_age_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_age_filter</span>
        <span class="k">if</span> <span class="n">target_age_filter</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_age_filter</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">genre_ids</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">genre_restriction_sets</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">filter_ids</span><span class="p">(</span><span class="n">genre_ids</span><span class="p">)</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;genres&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Terms</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;genres.term&#39;</span> <span class="p">:</span> <span class="n">filter_ids</span><span class="p">(</span><span class="n">genre_ids</span><span class="p">)})</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">customlist_ids</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">customlist_restriction_sets</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">filter_ids</span><span class="p">(</span><span class="n">customlist_ids</span><span class="p">)</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;customlists&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Terms</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;customlists.list_id&#39;</span> <span class="p">:</span> <span class="n">ids</span><span class="p">})</span>
            <span class="p">)</span>

        <span class="n">open_access</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.open_access&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability</span><span class="o">==</span><span class="n">FacetConstants</span><span class="o">.</span><span class="n">AVAILABLE_NOW</span><span class="p">:</span>
            <span class="c1"># Only open-access books and books with currently available</span>
            <span class="c1"># copies should be displayed.</span>
            <span class="n">available</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.available&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;licensepools&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Bool</span><span class="p">(</span><span class="n">should</span><span class="o">=</span><span class="p">[</span><span class="n">open_access</span><span class="p">,</span> <span class="n">available</span><span class="p">],</span> <span class="n">minimum_should_match</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability</span><span class="o">==</span><span class="n">FacetConstants</span><span class="o">.</span><span class="n">AVAILABLE_OPEN_ACCESS</span><span class="p">:</span>
            <span class="c1"># Only open-access books should be displayed.</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;licensepools&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">open_access</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">availability</span><span class="o">==</span><span class="n">FacetConstants</span><span class="o">.</span><span class="n">AVAILABLE_NOT_NOW</span><span class="p">:</span>
            <span class="c1"># Only books that are _not_ currently available should be displayed.</span>
            <span class="n">not_open_access</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.open_access&#39;</span> <span class="p">:</span> <span class="kc">False</span><span class="p">})</span>
            <span class="n">not_available</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.available&#39;</span> <span class="p">:</span> <span class="kc">False</span><span class="p">})</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;licensepools&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="p">[</span><span class="n">not_open_access</span><span class="p">,</span> <span class="n">not_available</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcollection</span><span class="o">==</span><span class="n">FacetConstants</span><span class="o">.</span><span class="n">COLLECTION_FEATURED</span><span class="p">:</span>
            <span class="c1"># Exclude books with a quality of less than the library&#39;s</span>
            <span class="c1"># minimum featured quality.</span>
            <span class="n">range_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_range</span><span class="p">(</span>
                <span class="s1">&#39;quality&#39;</span><span class="p">,</span> <span class="s1">&#39;gte&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum_featured_quality</span>
            <span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="n">range_query</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="p">:</span>
            <span class="c1"># Check every identifier for a match.</span>
            <span class="n">clauses</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">identifier</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scrub_identifiers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="p">):</span>
                <span class="n">subclauses</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># Both identifier and type must match for the match</span>
                <span class="c1"># to count.</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">(</span>
                    <span class="p">(</span><span class="s1">&#39;identifier&#39;</span><span class="p">,</span> <span class="n">identifier</span><span class="o">.</span><span class="n">identifier</span><span class="p">),</span>
                    <span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="n">identifier</span><span class="o">.</span><span class="n">type</span><span class="p">),</span>
                <span class="p">):</span>
                    <span class="n">subclauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;identifiers.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span> <span class="p">:</span> <span class="n">value</span><span class="p">})</span>
                    <span class="p">)</span>
                <span class="n">clauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="n">subclauses</span><span class="p">))</span>

            <span class="c1"># At least one the identifiers must match for the work to</span>
            <span class="c1"># match.</span>
            <span class="n">identifier_f</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">should</span><span class="o">=</span><span class="n">clauses</span><span class="p">,</span> <span class="n">minimum_should_match</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;identifiers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">identifier_f</span><span class="p">)</span>

        <span class="c1"># Some sources of audiobooks may be excluded because the</span>
        <span class="c1"># server can&#39;t fulfill them or the anticipated client can&#39;t</span>
        <span class="c1"># play them.</span>
        <span class="n">excluded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">excluded_audiobook_data_sources</span>
        <span class="k">if</span> <span class="n">excluded</span><span class="p">:</span>
            <span class="n">audio</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.medium&#39;</span><span class="p">:</span> <span class="n">Edition</span><span class="o">.</span><span class="n">AUDIO_MEDIUM</span><span class="p">})</span>
            <span class="n">excluded_audio_source</span> <span class="o">=</span> <span class="n">Terms</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.data_source_id&#39;</span> <span class="p">:</span> <span class="n">excluded</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="n">excluded_audio</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="p">[</span><span class="n">audio</span><span class="p">,</span> <span class="n">excluded_audio_source</span><span class="p">])</span>
            <span class="n">not_excluded_audio</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must_not</span><span class="o">=</span><span class="n">excluded_audio</span><span class="p">)</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;licensepools&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">not_excluded_audio</span><span class="p">)</span>

        <span class="c1"># If holds are not allowed, only license pools that are</span>
        <span class="c1"># currently available should be considered.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_holds</span><span class="p">:</span>
            <span class="n">licenses_available</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.available&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
            <span class="n">currently_available</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">should</span><span class="o">=</span><span class="p">[</span><span class="n">licenses_available</span><span class="p">,</span> <span class="n">open_access</span><span class="p">])</span>
            <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;licensepools&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currently_available</span><span class="p">)</span>

        <span class="c1"># Perhaps only books whose bibliographic metadata was updated</span>
        <span class="c1"># recently should be included.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">updated_after</span><span class="p">:</span>
            <span class="c1"># &#39;last update_time&#39; is indexed as a number of seconds, but</span>
            <span class="c1"># .last_update is probably a datetime. Convert it here.</span>
            <span class="n">updated_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">updated_after</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">updated_after</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
                <span class="n">updated_after</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">updated_after</span> <span class="o">-</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
            <span class="n">last_update_time_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_range</span><span class="p">(</span>
                <span class="s1">&#39;last_update_time&#39;</span><span class="p">,</span> <span class="s1">&#39;gte&#39;</span><span class="p">,</span> <span class="n">updated_after</span>
            <span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="n">last_update_time_query</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">nested_filters</span></div>

<div class="viewcode-block" id="Filter.universal_base_filter"><a class="viewcode-back" href="../../core.html#core.external_search.Filter.universal_base_filter">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">universal_base_filter</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_chain_filters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a set of restrictions on the main search document that are</span>
<span class="sd">        always applied, even in the absence of other filters.</span>

<span class="sd">        :param _chain_filters: Mock function to use instead of</span>
<span class="sd">            Filter._chain_filters</span>

<span class="sd">        :return: A Filter object.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_chain_filters</span> <span class="o">=</span> <span class="n">_chain_filters</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_chain_filters</span>

        <span class="n">base_filter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># We only want to show works that are presentation-ready.</span>
        <span class="n">base_filter</span> <span class="o">=</span> <span class="n">_chain_filters</span><span class="p">(</span>
            <span class="n">base_filter</span><span class="p">,</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s2">&quot;presentation_ready&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">})</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">base_filter</span></div>

<div class="viewcode-block" id="Filter.universal_nested_filters"><a class="viewcode-back" href="../../core.html#core.external_search.Filter.universal_nested_filters">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">universal_nested_filters</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a set of restrictions on subdocuments that are</span>
<span class="sd">        always applied, even in the absence of other filters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nested_filters</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># TODO: It would be great to be able to filter out</span>
        <span class="c1"># LicensePools that have no delivery mechanisms. That&#39;s the</span>
        <span class="c1"># only part of Collection.restrict_to_ready_deliverable_works</span>
        <span class="c1"># not already implemented in this class.</span>

        <span class="c1"># We don&#39;t want to consider license pools that have been</span>
        <span class="c1"># suppressed, or of which there are currently no licensed</span>
        <span class="c1"># copies. This might lead to a Work being filtered out</span>
        <span class="c1"># entirely.</span>
        <span class="c1">#</span>
        <span class="c1"># It&#39;s easier to stay consistent by indexing all Works and</span>
        <span class="c1"># filtering them out later, than to do it by adding and</span>
        <span class="c1"># removing works from the index.</span>
        <span class="n">not_suppressed</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.suppressed&#39;</span> <span class="p">:</span> <span class="kc">False</span><span class="p">})</span>
        <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;licensepools&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">not_suppressed</span><span class="p">)</span>

        <span class="n">owns_licenses</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.licensed&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="n">open_access</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.open_access&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="n">currently_owned</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">should</span><span class="o">=</span><span class="p">[</span><span class="n">owns_licenses</span><span class="p">,</span> <span class="n">open_access</span><span class="p">])</span>
        <span class="n">nested_filters</span><span class="p">[</span><span class="s1">&#39;licensepools&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currently_owned</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nested_filters</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sort_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a description, for use in an Elasticsearch document,</span>
<span class="sd">        explaining how search results should be ordered.</span>

<span class="sd">        :return: A list of dictionaries, each dictionary mapping a</span>
<span class="sd">            field name to an explanation of how to sort that</span>
<span class="sd">            field. Usually the explanation is a simple string, either</span>
<span class="sd">            &#39;asc&#39; or &#39;desc&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># These sort order fields are inserted as necessary between</span>
        <span class="c1"># the primary sort order field and the tiebreaker field (work</span>
        <span class="c1"># ID). This makes it more likely that the sort order makes</span>
        <span class="c1"># sense to a human, by putting off the opaque tiebreaker for</span>
        <span class="c1"># as long as possible. For example, a feed sorted by author</span>
        <span class="c1"># will be secondarily sorted by title and work ID, not just by</span>
        <span class="c1"># work ID.</span>
        <span class="n">default_sort_order</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sort_author&#39;</span><span class="p">,</span> <span class="s1">&#39;sort_title&#39;</span><span class="p">,</span> <span class="s1">&#39;work_id&#39;</span><span class="p">]</span>

        <span class="n">order_field_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order_field_keys</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">order_field_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">order_field_keys</span><span class="p">]</span>
        <span class="n">order_fields</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_order_field</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">order_field_keys</span>
        <span class="p">]</span>

        <span class="c1"># Apply any parts of the default sort order not yet covered,</span>
        <span class="c1"># concluding (in most cases) with work_id, the tiebreaker field.</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">default_sort_order</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">order_field_keys</span><span class="p">:</span>
                <span class="n">order_fields</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;asc&quot;</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">order_fields</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">asc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Convert order_ascending to Elasticsearch-speak.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_ascending</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;desc&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;asc&quot;</span>

    <span class="k">def</span> <span class="nf">_make_order_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;last_update_time&#39;</span><span class="p">:</span>
            <span class="c1"># Sorting by last_update_time may be very simple or very</span>
            <span class="c1"># complex, depending on whether or not the filter</span>
            <span class="c1"># involves collection or list membership.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection_ids</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">customlist_restriction_sets</span><span class="p">:</span>
                <span class="c1"># The complex case -- use a helper method.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_update_time_order_by</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The simple case, handled below.</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
            <span class="c1"># A simple case.</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">key</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">asc</span> <span class="p">}</span>

        <span class="c1"># At this point we&#39;re sorting by a nested field.</span>
        <span class="n">nested</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;licensepools.availability_time&#39;</span><span class="p">:</span>
            <span class="n">nested</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_availability_time_sort_order</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;I don&#39;t know how to sort by </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">key</span>
            <span class="p">)</span>
        <span class="n">sort_description</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">asc</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nested</span><span class="p">:</span>
            <span class="n">sort_description</span><span class="p">[</span><span class="s1">&#39;nested&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">nested</span>
        <span class="k">return</span> <span class="p">{</span> <span class="n">key</span> <span class="p">:</span> <span class="n">sort_description</span> <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_availability_time_sort_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># We&#39;re sorting works by the time they became</span>
        <span class="c1"># available to a library. This means we only want to</span>
        <span class="c1"># consider the availability times of license pools</span>
        <span class="c1"># found in one of the library&#39;s collections.</span>
        <span class="n">nested</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">collection_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_ids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collection_ids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">collection_ids</span><span class="p">:</span>
            <span class="n">nested</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">path</span><span class="o">=</span><span class="s2">&quot;licensepools&quot;</span><span class="p">,</span>
                <span class="nb">filter</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                    <span class="n">terms</span><span class="o">=</span><span class="p">{</span>
                        <span class="s2">&quot;licensepools.collection_id&quot;</span><span class="p">:</span> <span class="n">collection_ids</span>
                    <span class="p">}</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="c1"># If a book shows up in multiple collections, we&#39;re only</span>
        <span class="c1"># interested in the collection that had it the earliest.</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;min&#39;</span>
        <span class="k">return</span> <span class="n">nested</span><span class="p">,</span> <span class="n">mode</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">last_update_time_script_field</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the configuration for a script field that calculates the</span>
<span class="sd">        &#39;last update&#39; time of a work. An &#39;update&#39; happens when the</span>
<span class="sd">        work&#39;s metadata is changed, when it&#39;s added to a collection</span>
<span class="sd">        used by this Filter, or when it&#39;s added to one of the lists</span>
<span class="sd">        used by this Filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First, set up the parameters we&#39;re going to pass into the</span>
        <span class="c1"># script -- a list of custom list IDs relevant to this filter,</span>
        <span class="c1"># and a list of collection IDs relevant to this filter.</span>
        <span class="n">collection_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_ids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collection_ids</span><span class="p">)</span>

        <span class="c1"># The different restriction sets don&#39;t matter here. The filter</span>
        <span class="c1"># part of the query ensures that we only match works present</span>
        <span class="c1"># on one list in every restriction set. Here, we need to find</span>
        <span class="c1"># the latest time a work was added to _any_ relevant list.</span>
        <span class="n">all_list_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">restriction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">customlist_restriction_sets</span><span class="p">:</span>
            <span class="n">all_list_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filter_ids</span><span class="p">(</span><span class="n">restriction</span><span class="p">))</span>
        <span class="n">nested</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">path</span><span class="o">=</span><span class="s2">&quot;customlists&quot;</span><span class="p">,</span>
            <span class="nb">filter</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">terms</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;customlists.list_id&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_list_ids</span><span class="p">)}</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">collection_ids</span><span class="o">=</span><span class="n">collection_ids</span><span class="p">,</span>
            <span class="n">list_ids</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">all_list_ids</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">script</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">stored</span><span class="o">=</span><span class="n">CurrentMapping</span><span class="o">.</span><span class="n">script_name</span><span class="p">(</span><span class="s2">&quot;work_last_update&quot;</span><span class="p">),</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_last_update_time_order_by</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;We&#39;re sorting works by the time of their &#39;last update&#39;.</span>

<span class="sd">        Add the &#39;last update&#39; field to the dictionary of script fields</span>
<span class="sd">        (so we can use the result afterwards), and define it a second</span>
<span class="sd">        time as the script to use for a sort value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_update_time_script_field</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;last_update&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">script_fields</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">script_fields</span><span class="p">[</span><span class="s1">&#39;last_update&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">_script</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;number&quot;</span><span class="p">,</span>
                <span class="n">script</span><span class="o">=</span><span class="n">field</span><span class="p">[</span><span class="s1">&#39;script&#39;</span><span class="p">],</span>
                <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">asc</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="c1"># The Painless script to generate a &#39;featurability&#39; score for</span>
    <span class="c1"># a work.</span>
    <span class="c1">#</span>
    <span class="c1"># A higher-quality work is more featurable. But we don&#39;t want</span>
    <span class="c1"># to constantly feature the very highest-quality works, and if</span>
    <span class="c1"># there are no high-quality works, we want medium-quality to</span>
    <span class="c1"># outrank low-quality.</span>
    <span class="c1">#</span>
    <span class="c1"># So we establish a cutoff -- the minimum featured quality --</span>
    <span class="c1"># beyond which a work is considered &#39;featurable&#39;. All featurable</span>
    <span class="c1"># works get the same (high) score.</span>
    <span class="c1">#</span>
    <span class="c1"># Below that point, we prefer higher-quality works to</span>
    <span class="c1"># lower-quality works, such that a work&#39;s score is proportional to</span>
    <span class="c1"># the square of its quality.</span>
    <span class="n">FEATURABLE_SCRIPT</span> <span class="o">=</span> <span class="s2">&quot;Math.pow(Math.min(</span><span class="si">%(cutoff).5f</span><span class="s2">, doc[&#39;quality&#39;].value), </span><span class="si">%(exponent).5f</span><span class="s2">) * 5&quot;</span>

    <span class="c1"># Used in tests to deactivate the random component of</span>
    <span class="c1"># featurability_scoring_functions.</span>
    <span class="n">DETERMINISTIC</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<div class="viewcode-block" id="Filter.featurability_scoring_functions"><a class="viewcode-back" href="../../core.html#core.external_search.Filter.featurability_scoring_functions">[docs]</a>    <span class="k">def</span> <span class="nf">featurability_scoring_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate scoring functions that weight works randomly, but</span>
<span class="sd">        with &#39;more featurable&#39; works tending to be at the top.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">exponent</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimum_featured_quality</span> <span class="o">**</span> <span class="n">exponent</span><span class="p">)</span>
        <span class="n">script</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FEATURABLE_SCRIPT</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span>
        <span class="p">)</span>
        <span class="n">quality_field</span> <span class="o">=</span> <span class="n">SF</span><span class="p">(</span><span class="s1">&#39;script_score&#39;</span><span class="p">,</span> <span class="n">script</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">script</span><span class="p">))</span>

        <span class="c1"># Currently available works are more featurable.</span>
        <span class="n">available</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;licensepools.available&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="n">nested</span> <span class="o">=</span> <span class="n">Nested</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s1">&#39;licensepools&#39;</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="n">available</span><span class="p">)</span>
        <span class="n">available_now</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">filter</span><span class="o">=</span><span class="n">nested</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="n">function_scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">quality_field</span><span class="p">,</span> <span class="n">available_now</span><span class="p">]</span>

        <span class="c1"># Random chance can boost a lower-quality work, but not by</span>
        <span class="c1"># much -- this mainly ensures we don&#39;t get the exact same</span>
        <span class="c1"># books every time.</span>
        <span class="k">if</span> <span class="n">random_seed</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DETERMINISTIC</span><span class="p">:</span>
            <span class="n">random</span> <span class="o">=</span> <span class="n">SF</span><span class="p">(</span>
                <span class="s1">&#39;random_score&#39;</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="n">random_seed</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()),</span>
                <span class="n">field</span><span class="o">=</span><span class="s2">&quot;work_id&quot;</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="mf">1.1</span>
            <span class="p">)</span>
            <span class="n">function_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">customlist_restriction_sets</span><span class="p">:</span>
            <span class="n">list_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">restriction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">customlist_restriction_sets</span><span class="p">:</span>
                <span class="n">list_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">restriction</span><span class="p">)</span>
            <span class="c1"># We&#39;re looking for works on certain custom lists. A work</span>
            <span class="c1"># that&#39;s _featured_ on one of these lists will be boosted</span>
            <span class="c1"># quite a lot versus one that&#39;s not.</span>
            <span class="n">featured</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;customlists.featured&#39;</span> <span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
            <span class="n">on_list</span> <span class="o">=</span> <span class="n">Terms</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;customlists.list_id&#39;</span> <span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">list_ids</span><span class="p">)})</span>
            <span class="n">featured_on_list</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="p">[</span><span class="n">featured</span><span class="p">,</span> <span class="n">on_list</span><span class="p">])</span>
            <span class="n">nested</span> <span class="o">=</span> <span class="n">Nested</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s1">&#39;customlists&#39;</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="n">featured_on_list</span><span class="p">)</span>
            <span class="n">featured_on_relevant_list</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">filter</span><span class="o">=</span><span class="n">nested</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span>
            <span class="n">function_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">featured_on_relevant_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function_scores</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">target_age_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method to generate the target age subfilter.</span>

<span class="sd">        It&#39;s complicated because it has to handle cases where the upper</span>
<span class="sd">        or lower bound on target age is missing (indicating there is no</span>
<span class="sd">        upper or lower bound).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_age</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_age</span>
        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">def</span> <span class="nf">does_not_exist</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;A filter that matches if there is no value for `field`.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must_not</span><span class="o">=</span><span class="p">[</span><span class="n">Exists</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">)])</span>

        <span class="k">def</span> <span class="nf">or_does_not_exist</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Either the given `clause` matches or the given field</span>
<span class="sd">            does not exist.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">Bool</span><span class="p">(</span><span class="n">should</span><span class="o">=</span><span class="p">[</span><span class="n">clause</span><span class="p">,</span> <span class="n">does_not_exist</span><span class="p">(</span><span class="n">field</span><span class="p">)],</span>
                     <span class="n">minimum_should_match</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">clauses</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower_does_not_exist</span> <span class="o">=</span> <span class="n">does_not_exist</span><span class="p">(</span><span class="s2">&quot;target_age.lower&quot;</span><span class="p">)</span>
            <span class="n">lower_in_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_range</span><span class="p">(</span><span class="s2">&quot;target_age.lower&quot;</span><span class="p">,</span> <span class="s2">&quot;lte&quot;</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
            <span class="n">lower_match</span> <span class="o">=</span> <span class="n">or_does_not_exist</span><span class="p">(</span><span class="n">lower_in_range</span><span class="p">,</span> <span class="s2">&quot;target_age.lower&quot;</span><span class="p">)</span>
            <span class="n">clauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lower_match</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upper_does_not_exist</span> <span class="o">=</span> <span class="n">does_not_exist</span><span class="p">(</span><span class="s2">&quot;target_age.upper&quot;</span><span class="p">)</span>
            <span class="n">upper_in_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_range</span><span class="p">(</span><span class="s2">&quot;target_age.upper&quot;</span><span class="p">,</span> <span class="s2">&quot;gte&quot;</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
            <span class="n">upper_match</span> <span class="o">=</span> <span class="n">or_does_not_exist</span><span class="p">(</span><span class="n">upper_in_range</span><span class="p">,</span> <span class="s2">&quot;target_age.upper&quot;</span><span class="p">)</span>
            <span class="n">clauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upper_match</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">clauses</span><span class="p">:</span>
            <span class="c1"># Neither upper nor lower age must match.</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clauses</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Upper or lower age must match, but not both.</span>
            <span class="k">return</span> <span class="n">clauses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Both upper and lower age must match.</span>
        <span class="k">return</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="n">clauses</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">author_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a filter that matches a &#39;contributors&#39; subdocument only</span>
<span class="sd">        if it represents an author-level contribution by self.author.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">author</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">authorship_role</span> <span class="o">=</span> <span class="n">Terms</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span><span class="s1">&#39;contributors.role&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">AUTHOR_MATCH_ROLES</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">clauses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;sort_name.keyword&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">sort_name</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;display_name.keyword&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">display_name</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;viaf&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">viaf</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;lc&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">lc</span><span class="p">)</span>
        <span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="n">Edition</span><span class="o">.</span><span class="n">UNKNOWN_AUTHOR</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">clauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Term</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;contributors.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">field</span> <span class="p">:</span> <span class="n">value</span><span class="p">})</span>
            <span class="p">)</span>

        <span class="n">same_person</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">should</span><span class="o">=</span><span class="n">clauses</span><span class="p">,</span> <span class="n">minimum_should_match</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Bool</span><span class="p">(</span><span class="n">must</span><span class="o">=</span><span class="p">[</span><span class="n">authorship_role</span><span class="p">,</span> <span class="n">same_person</span><span class="p">])</span>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_scrub</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Modify a string for use in a filter match.</span>

<span class="sd">        e.g. &quot;Young Adult&quot; becomes &quot;youngadult&quot;</span>

<span class="sd">        :param s: The string to modify.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_scrub_list</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The same as _scrub, except it always outputs</span>
<span class="sd">        a list of items.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">_scrub</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_filter_ids</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process a list of database objects, provided either as their</span>
<span class="sd">        IDs or as the objects themselves.</span>

<span class="sd">        :return: A list of IDs, or None if nothing was provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generally None means &#39;no restriction&#39;, while an empty list</span>
        <span class="c1"># means &#39;one of the values in this empty list&#39; -- in other</span>
        <span class="c1"># words, they are opposites.</span>
        <span class="k">if</span> <span class="n">ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">ids</span><span class="p">]</span>

        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="c1"># Turn a database object into an ID.</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="nb">id</span><span class="o">.</span><span class="n">id</span>
            <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">processed</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_scrub_identifiers</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">identifiers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a mixed list of Identifier and IdentifierData objects</span>
<span class="sd">        into IdentifierData.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">identifiers</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">IdentifierData</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">i</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_chain_filters</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">existing</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Either chain two filters together or start a new chain.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">existing</span><span class="p">:</span>
            <span class="c1"># We&#39;re combining two filters.</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">existing</span> <span class="o">&amp;</span> <span class="n">new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># There was no previous filter -- the &#39;new&#39; one is it.</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">new</span></div>


<div class="viewcode-block" id="SortKeyPagination"><a class="viewcode-back" href="../../core.html#core.external_search.SortKeyPagination">[docs]</a><span class="k">class</span> <span class="nc">SortKeyPagination</span><span class="p">(</span><span class="n">Pagination</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Elasticsearch-specific implementation of Pagination that</span>
<span class="sd">    paginates search results by tracking where in a sorted list the</span>
<span class="sd">    previous page left off, rather than using a numeric index into the</span>
<span class="sd">    list.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">last_item_on_previous_page</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">size</span><span class="o">=</span><span class="n">Pagination</span><span class="o">.</span><span class="n">DEFAULT_SIZE</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_item_on_previous_page</span> <span class="o">=</span> <span class="n">last_item_on_previous_page</span>

        <span class="c1"># These variables are set by page_loaded(), after the query</span>
        <span class="c1"># is run.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">page_has_loaded</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_item_on_this_page</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this_page_size</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SortKeyPagination.from_request"><a class="viewcode-back" href="../../core.html#core.external_search.SortKeyPagination.from_request">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_request</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">get_arg</span><span class="p">,</span> <span class="n">default_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instantiate a SortKeyPagination object from a Flask request.&quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">size_from_request</span><span class="p">(</span><span class="n">get_arg</span><span class="p">,</span> <span class="n">default_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">ProblemDetail</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">size</span>
        <span class="n">pagination_key</span> <span class="o">=</span> <span class="n">get_arg</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pagination_key</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pagination_key</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pagination_key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">INVALID_INPUT</span><span class="o">.</span><span class="n">detailed</span><span class="p">(</span>
                    <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Invalid page key: </span><span class="si">%(key)s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">pagination_key</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">pagination_key</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span></div>

<div class="viewcode-block" id="SortKeyPagination.items"><a class="viewcode-back" href="../../core.html#core.external_search.SortKeyPagination.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield the URL arguments necessary to convey the current page</span>
<span class="sd">        state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pagination_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pagination_key</span>
        <span class="k">if</span> <span class="n">pagination_key</span><span class="p">:</span>
            <span class="k">yield</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pagination_key</span><span class="p">)</span>
        <span class="k">yield</span><span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pagination_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the pagination key for this page.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_item_on_previous_page</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_item_on_previous_page</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This object never uses the traditional offset system; offset</span>
        <span class="c1"># is determined relative to the last item on the previous</span>
        <span class="c1"># page.</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">total_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Although we technically know the total size after the first</span>
        <span class="c1"># page of results has been obtained, we don&#39;t use this feature</span>
        <span class="c1"># in pagination, so act like we don&#39;t.</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="SortKeyPagination.modify_database_query"><a class="viewcode-back" href="../../core.html#core.external_search.SortKeyPagination.modify_database_query">[docs]</a>    <span class="k">def</span> <span class="nf">modify_database_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qu</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;SortKeyPagination does not work with database queries.&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SortKeyPagination.modify_search_query"><a class="viewcode-back" href="../../core.html#core.external_search.SortKeyPagination.modify_search_query">[docs]</a>    <span class="k">def</span> <span class="nf">modify_search_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Modify the given Search object so that it starts</span>
<span class="sd">        picking up items immediately after the previous page.</span>

<span class="sd">        :param search: An elasticsearch-dsl Search object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_item_on_previous_page</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">search</span><span class="o">.</span><span class="n">update_from_dict</span><span class="p">(</span>
                <span class="nb">dict</span><span class="p">(</span><span class="n">search_after</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">last_item_on_previous_page</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SortKeyPagination</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">modify_search_query</span><span class="p">(</span><span class="n">search</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">previous_page</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: We can get the previous page by flipping the sort</span>
        <span class="c1"># order and asking for the _next_ page of the reversed list,</span>
        <span class="c1"># using the sort keys of the _first_ item as the search_after.</span>
        <span class="c1"># But this is really confusing, it requires more context than</span>
        <span class="c1"># SortKeyPagination currently has, and this feature isn&#39;t</span>
        <span class="c1"># necessary for our current implementation.</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">next_page</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If possible, create a new SortKeyPagination representing the</span>
<span class="sd">        next page of results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">this_page_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># This page is empty; there is no next page.</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_item_on_this_page</span><span class="p">:</span>
            <span class="c1"># This probably means load_page wasn&#39;t called. At any</span>
            <span class="c1"># rate, we can&#39;t say anything about the next page.</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">SortKeyPagination</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_item_on_this_page</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

<div class="viewcode-block" id="SortKeyPagination.page_loaded"><a class="viewcode-back" href="../../core.html#core.external_search.SortKeyPagination.page_loaded">[docs]</a>    <span class="k">def</span> <span class="nf">page_loaded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">page</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An actual page of results has been fetched. Keep any internal state</span>
<span class="sd">        that would be useful to know when reasoning about earlier or</span>
<span class="sd">        later pages.</span>

<span class="sd">        Specifically, keep track of the sort value of the last item on</span>
<span class="sd">        this page, so that self.next_page will create a</span>
<span class="sd">        SortKeyPagination object capable of generating the subsequent</span>
<span class="sd">        page.</span>

<span class="sd">        :param page: A list of elasticsearch-dsl Hit objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SortKeyPagination</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">page_loaded</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">page</span><span class="p">:</span>
            <span class="n">last_item</span> <span class="o">=</span> <span class="n">page</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">last_item</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">sort</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># There&#39;s nothing on this page, so there&#39;s no next page</span>
            <span class="c1"># either.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_item_on_this_page</span> <span class="o">=</span> <span class="n">values</span></div></div>


<div class="viewcode-block" id="WorkSearchResult"><a class="viewcode-back" href="../../core.html#core.external_search.WorkSearchResult">[docs]</a><span class="k">class</span> <span class="nc">WorkSearchResult</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wraps a Work object to give extra information obtained from</span>
<span class="sd">    ElasticSearch.</span>

<span class="sd">    This object acts just like a Work (though isinstance(x, Work) will</span>
<span class="sd">    fail), with one exception: you can access the raw ElasticSearch Hit</span>
<span class="sd">    result as ._hit.</span>

<span class="sd">    This is useful when a Work needs to be &#39;tagged&#39; with information</span>
<span class="sd">    obtained through Elasticsearch, such as its &#39;last modified&#39; date</span>
<span class="sd">    the context of a specific lane.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">hit</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_work</span> <span class="o">=</span> <span class="n">work</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hit</span> <span class="o">=</span> <span class="n">hit</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_work</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="MockExternalSearchIndex"><a class="viewcode-back" href="../../core.html#core.external_search.MockExternalSearchIndex">[docs]</a><span class="k">class</span> <span class="nc">MockExternalSearchIndex</span><span class="p">(</span><span class="n">ExternalSearchIndex</span><span class="p">):</span>

    <span class="n">work_document_type</span> <span class="o">=</span> <span class="s1">&#39;work-type&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">works_index</span> <span class="o">=</span> <span class="s2">&quot;works&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">works_alias</span> <span class="o">=</span> <span class="s2">&quot;works-current&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;Mock external search index&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_search_term</span> <span class="o">=</span> <span class="s2">&quot;a search term&quot;</span>

    <span class="k">def</span> <span class="nf">_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">doc_type</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">doc_type</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>

<div class="viewcode-block" id="MockExternalSearchIndex.index"><a class="viewcode-back" href="../../core.html#core.external_search.MockExternalSearchIndex.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">doc_type</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">doc_type</span><span class="p">,</span> <span class="nb">id</span><span class="p">)]</span> <span class="o">=</span> <span class="n">body</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="MockExternalSearchIndex.delete"><a class="viewcode-back" href="../../core.html#core.external_search.MockExternalSearchIndex.delete">[docs]</a>    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">doc_type</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">doc_type</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="MockExternalSearchIndex.exists"><a class="viewcode-back" href="../../core.html#core.external_search.MockExternalSearchIndex.exists">[docs]</a>    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">doc_type</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">doc_type</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span></div>

<div class="viewcode-block" id="MockExternalSearchIndex.create_search_doc"><a class="viewcode-back" href="../../core.html#core.external_search.MockExternalSearchIndex.create_search_doc">[docs]</a>    <span class="k">def</span> <span class="nf">create_search_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pagination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="o">.</span><span class="n">values</span><span class="p">()</span></div>

<div class="viewcode-block" id="MockExternalSearchIndex.query_works"><a class="viewcode-back" href="../../core.html#core.external_search.MockExternalSearchIndex.query_works">[docs]</a>    <span class="k">def</span> <span class="nf">query_works</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">pagination</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queries</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">pagination</span><span class="p">,</span> <span class="n">debug</span><span class="p">))</span>
        <span class="c1"># During a test we always sort works by the order in which the</span>
        <span class="c1"># work was created.</span>

        <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c1"># This needs to work with either a MockSearchResult or a</span>
            <span class="c1"># dictionary representing a raw search result.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MockSearchResult</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">work_id</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">]</span>
        <span class="n">docs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">sort_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pagination</span><span class="p">:</span>
            <span class="n">start_at</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pagination</span><span class="p">,</span> <span class="n">SortKeyPagination</span><span class="p">):</span>
                <span class="c1"># Figure out where the previous page ended by looking</span>
                <span class="c1"># for the corresponding work ID.</span>
                <span class="k">if</span> <span class="n">pagination</span><span class="o">.</span><span class="n">last_item_on_previous_page</span><span class="p">:</span>
                    <span class="n">look_for</span> <span class="o">=</span> <span class="n">pagination</span><span class="o">.</span><span class="n">last_item_on_previous_page</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">docs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">look_for</span><span class="p">:</span>
                            <span class="n">start_at</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start_at</span> <span class="o">=</span> <span class="n">pagination</span><span class="o">.</span><span class="n">offset</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">start_at</span> <span class="o">+</span> <span class="n">pagination</span><span class="o">.</span><span class="n">size</span>
            <span class="n">docs</span> <span class="o">=</span> <span class="n">docs</span><span class="p">[</span><span class="n">start_at</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MockSearchResult</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">MockSearchResult</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;author&quot;</span><span class="p">],</span> <span class="p">{},</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">])</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">pagination</span><span class="p">:</span>
            <span class="n">pagination</span><span class="o">.</span><span class="n">page_loaded</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="MockExternalSearchIndex.query_works_multi"><a class="viewcode-back" href="../../core.html#core.external_search.MockExternalSearchIndex.query_works_multi">[docs]</a>    <span class="k">def</span> <span class="nf">query_works_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queries</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Implement query_works_multi by calling query_works several</span>
        <span class="c1"># times. This is the opposite of what happens in the</span>
        <span class="c1"># non-mocked ExternalSearchIndex, because it&#39;s easier to mock</span>
        <span class="c1"># the simple case and performance isn&#39;t an issue.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">pagination</span><span class="p">)</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_works</span><span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">pagination</span><span class="p">,</span> <span class="n">debug</span><span class="p">)</span></div>

<div class="viewcode-block" id="MockExternalSearchIndex.count_works"><a class="viewcode-back" href="../../core.html#core.external_search.MockExternalSearchIndex.count_works">[docs]</a>    <span class="k">def</span> <span class="nf">count_works</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MockExternalSearchIndex.bulk"><a class="viewcode-back" href="../../core.html#core.external_search.MockExternalSearchIndex.bulk">[docs]</a>    <span class="k">def</span> <span class="nf">bulk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="s1">&#39;_index&#39;</span><span class="p">],</span> <span class="n">doc</span><span class="p">[</span><span class="s1">&#39;_type&#39;</span><span class="p">],</span> <span class="n">doc</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">],</span> <span class="n">doc</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">docs</span><span class="p">),</span> <span class="p">[]</span></div></div>

<div class="viewcode-block" id="MockMeta"><a class="viewcode-back" href="../../core.html#core.external_search.MockMeta">[docs]</a><span class="k">class</span> <span class="nc">MockMeta</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mock the .meta object associated with an Elasticsearch search</span>
<span class="sd">    result.  This is necessary to get SortKeyPagination to work with</span>
<span class="sd">    MockExternalSearchIndex.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;_sort&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="MockSearchResult"><a class="viewcode-back" href="../../core.html#core.external_search.MockSearchResult">[docs]</a><span class="k">class</span> <span class="nc">MockSearchResult</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort_title</span><span class="p">,</span> <span class="n">sort_author</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort_title</span> <span class="o">=</span> <span class="n">sort_title</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort_author</span> <span class="o">=</span> <span class="n">sort_author</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;_sort&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sort_title</span><span class="p">,</span> <span class="n">sort_author</span><span class="p">,</span> <span class="nb">id</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">MockMeta</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">work_id</span> <span class="o">=</span> <span class="nb">id</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="MockSearchResult.to_dict"><a class="viewcode-back" href="../../core.html#core.external_search.MockSearchResult.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_title</span><span class="p">,</span>
            <span class="s2">&quot;author&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_author</span><span class="p">,</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
            <span class="s2">&quot;meta&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">,</span>
        <span class="p">}</span></div></div>


<div class="viewcode-block" id="SearchIndexCoverageProvider"><a class="viewcode-back" href="../../core.html#core.external_search.SearchIndexCoverageProvider">[docs]</a><span class="k">class</span> <span class="nc">SearchIndexCoverageProvider</span><span class="p">(</span><span class="n">WorkPresentationProvider</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make sure all Works have up-to-date representation in the</span>
<span class="sd">    search index.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SERVICE_NAME</span> <span class="o">=</span> <span class="s1">&#39;Search index coverage provider&#39;</span>

    <span class="n">DEFAULT_BATCH_SIZE</span> <span class="o">=</span> <span class="mi">500</span>

    <span class="n">OPERATION</span> <span class="o">=</span> <span class="n">WorkCoverageRecord</span><span class="o">.</span><span class="n">UPDATE_SEARCH_INDEX_OPERATION</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">search_index_client</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;search_index_client&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SearchIndexCoverageProvider</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_index_client</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">search_index_client</span> <span class="ow">or</span> <span class="n">ExternalSearchIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_db</span><span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="SearchIndexCoverageProvider.process_batch"><a class="viewcode-back" href="../../core.html#core.external_search.SearchIndexCoverageProvider.process_batch">[docs]</a>    <span class="k">def</span> <span class="nf">process_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">works</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: a mixed list of Works and CoverageFailure objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">successes</span><span class="p">,</span> <span class="n">failures</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_index_client</span><span class="o">.</span><span class="n">bulk_update</span><span class="p">(</span><span class="n">works</span><span class="p">)</span>

        <span class="n">records</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">successes</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="ow">in</span> <span class="n">failures</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
                <span class="n">error</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
            <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CoverageFailure</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">records</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Library Simplified Circulation Manager</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">circulation</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, The New York Public Library, Astor, Lenox, and Tilden Foundations.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>