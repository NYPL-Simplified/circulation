
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>threading &#8212; Library Simplified Circulation Manager  documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for threading</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Thread module emulating a subset of Java&#39;s threading model.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span> <span class="k">as</span> <span class="nn">_sys</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">thread</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">del</span> <span class="n">_sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span>
    <span class="k">raise</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span> <span class="k">as</span> <span class="n">_deque</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span> <span class="k">as</span> <span class="n">_count</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span> <span class="k">as</span> <span class="n">_time</span><span class="p">,</span> <span class="n">sleep</span> <span class="k">as</span> <span class="n">_sleep</span>
<span class="kn">from</span> <span class="nn">traceback</span> <span class="kn">import</span> <span class="n">format_exc</span> <span class="k">as</span> <span class="n">_format_exc</span>

<span class="c1"># Note regarding PEP 8 compliant aliases</span>
<span class="c1">#  This threading model was originally inspired by Java, and inherited</span>
<span class="c1"># the convention of camelCase function and method names from that</span>
<span class="c1"># language. While those names are not in any imminent danger of being</span>
<span class="c1"># deprecated, starting with Python 2.6, the module now provides a</span>
<span class="c1"># PEP 8 compliant alias for any such method name.</span>
<span class="c1"># Using the new PEP 8 compliant names also facilitates substitution</span>
<span class="c1"># with the multiprocessing module, which doesn&#39;t provide the old</span>
<span class="c1"># Java inspired names.</span>


<span class="c1"># Rename some stuff so &quot;from threading import *&quot; is safe</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;activeCount&#39;</span><span class="p">,</span> <span class="s1">&#39;active_count&#39;</span><span class="p">,</span> <span class="s1">&#39;Condition&#39;</span><span class="p">,</span> <span class="s1">&#39;currentThread&#39;</span><span class="p">,</span>
           <span class="s1">&#39;current_thread&#39;</span><span class="p">,</span> <span class="s1">&#39;enumerate&#39;</span><span class="p">,</span> <span class="s1">&#39;Event&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Lock&#39;</span><span class="p">,</span> <span class="s1">&#39;RLock&#39;</span><span class="p">,</span> <span class="s1">&#39;Semaphore&#39;</span><span class="p">,</span> <span class="s1">&#39;BoundedSemaphore&#39;</span><span class="p">,</span> <span class="s1">&#39;Thread&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Timer&#39;</span><span class="p">,</span> <span class="s1">&#39;setprofile&#39;</span><span class="p">,</span> <span class="s1">&#39;settrace&#39;</span><span class="p">,</span> <span class="s1">&#39;local&#39;</span><span class="p">,</span> <span class="s1">&#39;stack_size&#39;</span><span class="p">]</span>

<span class="n">_start_new_thread</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">start_new_thread</span>
<span class="n">_allocate_lock</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">allocate_lock</span>
<span class="n">_get_ident</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">get_ident</span>
<span class="n">ThreadError</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">error</span>
<span class="k">del</span> <span class="n">thread</span>


<span class="c1"># sys.exc_clear is used to work around the fact that except blocks</span>
<span class="c1"># don&#39;t fully clear the exception until 3.0.</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                        <span class="n">module</span><span class="o">=</span><span class="s1">&#39;threading&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;sys.exc_clear&#39;</span><span class="p">)</span>

<span class="c1"># Debug support (adapted from ihooks.py).</span>
<span class="c1"># All the major classes here derive from _Verbose.  We force that to</span>
<span class="c1"># be a new-style class so that all the major classes here are new-style.</span>
<span class="c1"># This helps debugging (type(instance) is more revealing for instances</span>
<span class="c1"># of new-style classes).</span>

<span class="n">_VERBOSE</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>

    <span class="k">class</span> <span class="nc">_Verbose</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">_VERBOSE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="k">def</span> <span class="nf">_note</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__verbose</span><span class="p">:</span>
                <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span> <span class="o">%</span> <span class="n">args</span>
                <span class="c1"># Issue #4188: calling current_thread() can incur an infinite</span>
                <span class="c1"># recursion if it has to create a DummyThread on the fly.</span>
                <span class="n">ident</span> <span class="o">=</span> <span class="n">_get_ident</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">_active</span><span class="p">[</span><span class="n">ident</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&lt;OS thread </span><span class="si">%d</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">ident</span>
                <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
                <span class="n">_sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>

<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Disable this when using &quot;python -O&quot;</span>
    <span class="k">class</span> <span class="nc">_Verbose</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">def</span> <span class="nf">_note</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">pass</span>

<span class="c1"># Support for profile and trace hooks</span>

<span class="n">_profile_hook</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_trace_hook</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">setprofile</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set a profile function for all threads started from the threading module.</span>

<span class="sd">    The func will be passed to sys.setprofile() for each thread, before its</span>
<span class="sd">    run() method is called.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_profile_hook</span>
    <span class="n">_profile_hook</span> <span class="o">=</span> <span class="n">func</span>

<span class="k">def</span> <span class="nf">settrace</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set a trace function for all threads started from the threading module.</span>

<span class="sd">    The func will be passed to sys.settrace() for each thread, before its run()</span>
<span class="sd">    method is called.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_trace_hook</span>
    <span class="n">_trace_hook</span> <span class="o">=</span> <span class="n">func</span>

<span class="c1"># Synchronization classes</span>

<span class="n">Lock</span> <span class="o">=</span> <span class="n">_allocate_lock</span>

<span class="k">def</span> <span class="nf">RLock</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Factory function that returns a new reentrant lock.</span>

<span class="sd">    A reentrant lock must be released by the thread that acquired it. Once a</span>
<span class="sd">    thread has acquired a reentrant lock, the same thread may acquire it again</span>
<span class="sd">    without blocking; the thread must release it once for each time it has</span>
<span class="sd">    acquired it.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_RLock</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_RLock</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A reentrant lock must be released by the thread that acquired it. Once a</span>
<span class="sd">       thread has acquired a reentrant lock, the same thread may acquire it</span>
<span class="sd">       again without blocking; the thread must release it once for each time it</span>
<span class="sd">       has acquired it.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">owner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">owner</span> <span class="o">=</span> <span class="n">_active</span><span class="p">[</span><span class="n">owner</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> owner=</span><span class="si">%r</span><span class="s2"> count=</span><span class="si">%d</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__count</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Acquire a lock, blocking or non-blocking.</span>

<span class="sd">        When invoked without arguments: if this thread already owns the lock,</span>
<span class="sd">        increment the recursion level by one, and return immediately. Otherwise,</span>
<span class="sd">        if another thread owns the lock, block until the lock is unlocked. Once</span>
<span class="sd">        the lock is unlocked (not owned by any thread), then grab ownership, set</span>
<span class="sd">        the recursion level to one, and return. If more than one thread is</span>
<span class="sd">        blocked waiting until the lock is unlocked, only one at a time will be</span>
<span class="sd">        able to grab ownership of the lock. There is no return value in this</span>
<span class="sd">        case.</span>

<span class="sd">        When invoked with the blocking argument set to true, do the same thing</span>
<span class="sd">        as when called without arguments, and return true.</span>

<span class="sd">        When invoked with the blocking argument set to false, do not block. If a</span>
<span class="sd">        call without an argument would block, return false immediately;</span>
<span class="sd">        otherwise, do the same thing as when called without arguments, and</span>
<span class="sd">        return true.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">me</span> <span class="o">=</span> <span class="n">_get_ident</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">==</span> <span class="n">me</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.acquire(</span><span class="si">%s</span><span class="s2">): recursive success&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">blocking</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="n">me</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.acquire(</span><span class="si">%s</span><span class="s2">): initial success&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.acquire(</span><span class="si">%s</span><span class="s2">): failure&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rc</span>

    <span class="fm">__enter__</span> <span class="o">=</span> <span class="n">acquire</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Release a lock, decrementing the recursion level.</span>

<span class="sd">        If after the decrement it is zero, reset the lock to unlocked (not owned</span>
<span class="sd">        by any thread), and if any other threads are blocked waiting for the</span>
<span class="sd">        lock to become unlocked, allow exactly one of them to proceed. If after</span>
<span class="sd">        the decrement the recursion level is still nonzero, the lock remains</span>
<span class="sd">        locked and owned by the calling thread.</span>

<span class="sd">        Only call this method when the calling thread owns the lock. A</span>
<span class="sd">        RuntimeError is raised if this method is called when the lock is</span>
<span class="sd">        unlocked.</span>

<span class="sd">        There is no return value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">!=</span> <span class="n">_get_ident</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot release un-acquired lock&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.release(): final release&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.release(): non-final release&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="c1"># Internal methods used by condition variables</span>

    <span class="k">def</span> <span class="nf">_acquire_restore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_owner</span><span class="p">):</span>
        <span class="n">count</span><span class="p">,</span> <span class="n">owner</span> <span class="o">=</span> <span class="n">count_owner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="n">owner</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">._acquire_restore()&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_release_save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">._release_save()&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">owner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_owned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">==</span> <span class="n">_get_ident</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">Condition</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Factory function that returns a new condition variable object.</span>

<span class="sd">    A condition variable allows one or more threads to wait until they are</span>
<span class="sd">    notified by another thread.</span>

<span class="sd">    If the lock argument is given and not None, it must be a Lock or RLock</span>
<span class="sd">    object, and it is used as the underlying lock. Otherwise, a new RLock object</span>
<span class="sd">    is created and used as the underlying lock.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_Condition</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_Condition</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Condition variables allow one or more threads to wait until they are</span>
<span class="sd">       notified by another thread.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span> <span class="o">=</span> <span class="n">lock</span>
        <span class="c1"># Export the lock&#39;s acquire() and release() methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">release</span>
        <span class="c1"># If the lock defines _release_save() and/or _acquire_restore(),</span>
        <span class="c1"># these override the default implementations (which just call</span>
        <span class="c1"># release() and acquire() on the lock).  Ditto for _is_owned().</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_release_save</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">_release_save</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acquire_restore</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">_acquire_restore</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_owned</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">_is_owned</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="fm">__enter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="fm">__exit__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Condition(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_release_save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>           <span class="c1"># No state to save</span>

    <span class="k">def</span> <span class="nf">_acquire_restore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>           <span class="c1"># Ignore saved state</span>

    <span class="k">def</span> <span class="nf">_is_owned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Return True if lock is owned by current_thread.</span>
        <span class="c1"># This method is called only if __lock doesn&#39;t have _is_owned().</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wait until notified or until a timeout occurs.</span>

<span class="sd">        If the calling thread has not acquired the lock when this method is</span>
<span class="sd">        called, a RuntimeError is raised.</span>

<span class="sd">        This method releases the underlying lock, and then blocks until it is</span>
<span class="sd">        awakened by a notify() or notifyAll() call for the same condition</span>
<span class="sd">        variable in another thread, or until the optional timeout occurs. Once</span>
<span class="sd">        awakened or timed out, it re-acquires the lock and returns.</span>

<span class="sd">        When the timeout argument is present and not None, it should be a</span>
<span class="sd">        floating point number specifying a timeout for the operation in seconds</span>
<span class="sd">        (or fractions thereof).</span>

<span class="sd">        When the underlying lock is an RLock, it is not released using its</span>
<span class="sd">        release() method, since this may not actually unlock the lock when it</span>
<span class="sd">        was acquired multiple times recursively. Instead, an internal interface</span>
<span class="sd">        of the RLock class is used, which really unlocks it even when it has</span>
<span class="sd">        been recursively acquired several times. Another internal interface is</span>
<span class="sd">        then used to restore the recursion level when the lock is reacquired.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_owned</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot wait on un-acquired lock&quot;</span><span class="p">)</span>
        <span class="n">waiter</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>
        <span class="n">waiter</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">waiter</span><span class="p">)</span>
        <span class="n">saved_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_release_save</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>    <span class="c1"># restore state no matter what (e.g., KeyboardInterrupt)</span>
            <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">waiter</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.wait(): got it&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Balancing act:  We can&#39;t afford a pure busy loop, so we</span>
                <span class="c1"># have to sleep; but if we sleep the whole timeout time,</span>
                <span class="c1"># we&#39;ll be unresponsive.  The scheme here sleeps very</span>
                <span class="c1"># little at first, longer as time goes on, but never longer</span>
                <span class="c1"># than 20 times per second (or the timeout time remaining).</span>
                <span class="n">endtime</span> <span class="o">=</span> <span class="n">_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
                <span class="n">delay</span> <span class="o">=</span> <span class="mf">0.0005</span> <span class="c1"># 500 us -&gt; initial delay of 1 ms</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">gotit</span> <span class="o">=</span> <span class="n">waiter</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">gotit</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">remaining</span> <span class="o">=</span> <span class="n">endtime</span> <span class="o">-</span> <span class="n">_time</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">delay</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">delay</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="o">.</span><span class="mi">05</span><span class="p">)</span>
                    <span class="n">_sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">gotit</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.wait(</span><span class="si">%s</span><span class="s2">): timed out&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">waiter</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.wait(</span><span class="si">%s</span><span class="s2">): got it&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acquire_restore</span><span class="p">(</span><span class="n">saved_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">notify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wake up one or more threads waiting on this condition, if any.</span>

<span class="sd">        If the calling thread has not acquired the lock when this method is</span>
<span class="sd">        called, a RuntimeError is raised.</span>

<span class="sd">        This method wakes up at most n of the threads waiting for the condition</span>
<span class="sd">        variable; it is a no-op if no threads are waiting.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_owned</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot notify on un-acquired lock&quot;</span><span class="p">)</span>
        <span class="n">__waiters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span>
        <span class="n">waiters</span> <span class="o">=</span> <span class="n">__waiters</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">waiters</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.notify(): no waiters&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.notify(): notifying </span><span class="si">%d</span><span class="s2"> waiter</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                   <span class="n">n</span><span class="o">!=</span><span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot;s&quot;</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">waiter</span> <span class="ow">in</span> <span class="n">waiters</span><span class="p">:</span>
            <span class="n">waiter</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">__waiters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">waiter</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">notifyAll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wake up all threads waiting on this condition.</span>

<span class="sd">        If the calling thread has not acquired the lock when this method</span>
<span class="sd">        is called, a RuntimeError is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">))</span>

    <span class="n">notify_all</span> <span class="o">=</span> <span class="n">notifyAll</span>


<span class="k">def</span> <span class="nf">Semaphore</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A factory function that returns a new semaphore.</span>

<span class="sd">    Semaphores manage a counter representing the number of release() calls minus</span>
<span class="sd">    the number of acquire() calls, plus an initial value. The acquire() method</span>
<span class="sd">    blocks if necessary until it can return without making the counter</span>
<span class="sd">    negative. If not given, value defaults to 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_Semaphore</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_Semaphore</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Semaphores manage a counter representing the number of release() calls</span>
<span class="sd">       minus the number of acquire() calls, plus an initial value. The acquire()</span>
<span class="sd">       method blocks if necessary until it can return without making the counter</span>
<span class="sd">       negative. If not given, value defaults to 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># After Tim Peters&#39; semaphore class, but not quite the same (no maximum)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;semaphore initial value must be &gt;= 0&quot;</span><span class="p">)</span>
        <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Acquire a semaphore, decrementing the internal counter by one.</span>

<span class="sd">        When invoked without arguments: if the internal counter is larger than</span>
<span class="sd">        zero on entry, decrement it by one and return immediately. If it is zero</span>
<span class="sd">        on entry, block, waiting until some other thread has called release() to</span>
<span class="sd">        make it larger than zero. This is done with proper interlocking so that</span>
<span class="sd">        if multiple acquire() calls are blocked, release() will wake exactly one</span>
<span class="sd">        of them up. The implementation may pick one at random, so the order in</span>
<span class="sd">        which blocked threads are awakened should not be relied on. There is no</span>
<span class="sd">        return value in this case.</span>

<span class="sd">        When invoked with blocking set to true, do the same thing as when called</span>
<span class="sd">        without arguments, and return true.</span>

<span class="sd">        When invoked with blocking set to false, do not block. If a call without</span>
<span class="sd">        an argument would block, return false immediately; otherwise, do the</span>
<span class="sd">        same thing as when called without arguments, and return true.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">blocking</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.acquire(</span><span class="si">%s</span><span class="s2">): blocked waiting, value=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.acquire: success, value=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">)</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">rc</span>

    <span class="fm">__enter__</span> <span class="o">=</span> <span class="n">acquire</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Release a semaphore, incrementing the internal counter by one.</span>

<span class="sd">        When the counter is zero on entry and another thread is waiting for it</span>
<span class="sd">        to become larger than zero again, wake up that thread.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.release: success, value=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">BoundedSemaphore</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A factory function that returns a new bounded semaphore.</span>

<span class="sd">    A bounded semaphore checks to make sure its current value doesn&#39;t exceed its</span>
<span class="sd">    initial value. If it does, ValueError is raised. In most situations</span>
<span class="sd">    semaphores are used to guard resources with limited capacity.</span>

<span class="sd">    If the semaphore is released too many times it&#39;s a sign of a bug. If not</span>
<span class="sd">    given, value defaults to 1.</span>

<span class="sd">    Like regular semaphores, bounded semaphores manage a counter representing</span>
<span class="sd">    the number of release() calls minus the number of acquire() calls, plus an</span>
<span class="sd">    initial value. The acquire() method blocks if necessary until it can return</span>
<span class="sd">    without making the counter negative. If not given, value defaults to 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_BoundedSemaphore</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_BoundedSemaphore</span><span class="p">(</span><span class="n">_Semaphore</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A bounded semaphore checks to make sure its current value doesn&#39;t exceed</span>
<span class="sd">       its initial value. If it does, ValueError is raised. In most situations</span>
<span class="sd">       semaphores are used to guard resources with limited capacity.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_Semaphore</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Release a semaphore, incrementing the internal counter by one.</span>

<span class="sd">        When the counter is zero on entry and another thread is waiting for it</span>
<span class="sd">        to become larger than zero again, wake up that thread.</span>

<span class="sd">        If the number of releases exceeds the number of acquires,</span>
<span class="sd">        raise a ValueError.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Semaphore__cond</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Semaphore__value</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_value</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Semaphore released too many times&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Semaphore__value</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Semaphore__cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">Event</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A factory function that returns a new event.</span>

<span class="sd">    Events manage a flag that can be set to true with the set() method and reset</span>
<span class="sd">    to false with the clear() method. The wait() method blocks until the flag is</span>
<span class="sd">    true.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_Event</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_Event</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A factory function that returns a new event object. An event manages a</span>
<span class="sd">       flag that can be set to true with the set() method and reset to false</span>
<span class="sd">       with the clear() method. The wait() method blocks until the flag is true.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># After Tim Peters&#39; event class (without is_posted())</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_reset_internal_locks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># private!  called by Thread._reset_internal_locks by _after_fork()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">isSet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Return true if and only if the internal flag is true.&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span>

    <span class="n">is_set</span> <span class="o">=</span> <span class="n">isSet</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the internal flag to true.</span>

<span class="sd">        All threads waiting for the flag to become true are awakened. Threads</span>
<span class="sd">        that call wait() once the flag is true will not block at all.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the internal flag to false.</span>

<span class="sd">        Subsequently, threads calling wait() will block until set() is called to</span>
<span class="sd">        set the internal flag to true again.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Block until the internal flag is true.</span>

<span class="sd">        If the internal flag is true on entry, return immediately. Otherwise,</span>
<span class="sd">        block until another thread calls set() to set the flag to true, or until</span>
<span class="sd">        the optional timeout occurs.</span>

<span class="sd">        When the timeout argument is present and not None, it should be a</span>
<span class="sd">        floating point number specifying a timeout for the operation in seconds</span>
<span class="sd">        (or fractions thereof).</span>

<span class="sd">        This method returns the internal flag on exit, so it will always return</span>
<span class="sd">        True except if a timeout is given and the operation times out.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span>

<span class="c1"># Helper to generate new thread names</span>
<span class="n">_counter</span> <span class="o">=</span> <span class="n">_count</span><span class="p">()</span><span class="o">.</span><span class="n">next</span>
<span class="n">_counter</span><span class="p">()</span> <span class="c1"># Consume 0 so first non-main thread has id 1.</span>
<span class="k">def</span> <span class="nf">_newname</span><span class="p">(</span><span class="n">template</span><span class="o">=</span><span class="s2">&quot;Thread-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">template</span> <span class="o">%</span> <span class="n">_counter</span><span class="p">()</span>

<span class="c1"># Active thread administration</span>
<span class="n">_active_limbo_lock</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>
<span class="n">_active</span> <span class="o">=</span> <span class="p">{}</span>    <span class="c1"># maps thread id to Thread object</span>
<span class="n">_limbo</span> <span class="o">=</span> <span class="p">{}</span>


<span class="c1"># Main class for threads</span>

<span class="k">class</span> <span class="nc">Thread</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents a thread of control.</span>

<span class="sd">    This class can be safely subclassed in a limited fashion.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__initialized</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Need to store a reference to sys.exc_info for printing</span>
    <span class="c1"># out exceptions when a thread tries to use a global var. during interp.</span>
    <span class="c1"># shutdown and thus raises an exception about trying to perform some</span>
    <span class="c1"># operation on/with a NoneType</span>
    <span class="n">__exc_info</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">exc_info</span>
    <span class="c1"># Keep sys.exc_clear too to clear the exception just before</span>
    <span class="c1"># allowing .join() to return.</span>
    <span class="n">__exc_clear</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">exc_clear</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This constructor should always be called with keyword arguments. Arguments are:</span>

<span class="sd">        *group* should be None; reserved for future extension when a ThreadGroup</span>
<span class="sd">        class is implemented.</span>

<span class="sd">        *target* is the callable object to be invoked by the run()</span>
<span class="sd">        method. Defaults to None, meaning nothing is called.</span>

<span class="sd">        *name* is the thread name. By default, a unique name is constructed of</span>
<span class="sd">        the form &quot;Thread-N&quot; where N is a small decimal number.</span>

<span class="sd">        *args* is the argument tuple for the target invocation. Defaults to ().</span>

<span class="sd">        *kwargs* is a dictionary of keyword arguments for the target</span>
<span class="sd">        invocation. Defaults to {}.</span>

<span class="sd">        If a subclass overrides the constructor, it must make sure to invoke</span>
<span class="sd">        the base class constructor (Thread.__init__()) before doing anything</span>
<span class="sd">        else to the thread.</span>

<span class="sd">&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;group argument must be None for now&quot;</span>
        <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span> <span class="ow">or</span> <span class="n">_newname</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__daemonic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_daemon</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__started</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># sys.stderr is not stored in the class like</span>
        <span class="c1"># sys.exc_info since it can be changed between instances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">stderr</span>

    <span class="k">def</span> <span class="nf">_reset_internal_locks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># private!  Called by _after_fork() to reset our internal locks as</span>
        <span class="c1"># they may be in an invalid state leading to a deadlock or crash.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_Thread__block&#39;</span><span class="p">):</span>  <span class="c1"># DummyThread deletes self.__block</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">_reset_internal_locks</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># used by a unittest</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__block</span>

    <span class="k">def</span> <span class="nf">_set_daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Overridden in _MainThread and _DummyThread</span>
        <span class="k">return</span> <span class="n">current_thread</span><span class="p">()</span><span class="o">.</span><span class="n">daemon</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() was not called&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;initial&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;started&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;stopped&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__daemonic</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">+=</span> <span class="s2">&quot; daemon&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start the thread&#39;s activity.</span>

<span class="sd">        It must be called at most once per thread object. It arranges for the</span>
<span class="sd">        object&#39;s run() method to be invoked in a separate thread of control.</span>

<span class="sd">        This method will raise a RuntimeError if called more than once on the</span>
<span class="sd">        same thread object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;thread.__init__() not called&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;threads can only be started once&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.start(): starting thread&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
            <span class="n">_limbo</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_start_new_thread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bootstrap</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">_limbo</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="k">raise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method representing the thread&#39;s activity.</span>

<span class="sd">        You may override this method in a subclass. The standard run() method</span>
<span class="sd">        invokes the callable object passed to the object&#39;s constructor as the</span>
<span class="sd">        target argument, if any, with sequential and keyword arguments taken</span>
<span class="sd">        from the args and kwargs arguments, respectively.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__target</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__target</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">__kwargs</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Avoid a refcycle if the thread is running a function with</span>
            <span class="c1"># an argument that has a member that points to the thread.</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__kwargs</span>

    <span class="k">def</span> <span class="nf">__bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Wrapper around the real bootstrap code that ignores</span>
        <span class="c1"># exceptions during interpreter cleanup.  Those typically</span>
        <span class="c1"># happen when a daemon thread wakes up at an unfortunate</span>
        <span class="c1"># moment, finds the world around it destroyed, and raises some</span>
        <span class="c1"># random exception *** while trying to report the exception in</span>
        <span class="c1"># __bootstrap_inner() below ***.  Those random exceptions</span>
        <span class="c1"># don&#39;t help anybody, and they confuse users, so we suppress</span>
        <span class="c1"># them.  We suppress them only when it appears that the world</span>
        <span class="c1"># indeed has already been destroyed, so that exceptions in</span>
        <span class="c1"># __bootstrap_inner() during normal business hours are properly</span>
        <span class="c1"># reported.  Also, we only suppress them for daemonic threads;</span>
        <span class="c1"># if a non-daemonic encounters this, something else is wrong.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__bootstrap_inner</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__daemonic</span> <span class="ow">and</span> <span class="n">_sys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">_set_ident</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span> <span class="o">=</span> <span class="n">_get_ident</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__bootstrap_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_ident</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
            <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
                <span class="n">_active</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__ident</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">del</span> <span class="n">_limbo</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): thread started&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">_trace_hook</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): registering trace hook&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="n">_sys</span><span class="o">.</span><span class="n">settrace</span><span class="p">(</span><span class="n">_trace_hook</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_profile_hook</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): registering profile hook&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="n">_sys</span><span class="o">.</span><span class="n">setprofile</span><span class="p">(</span><span class="n">_profile_hook</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">SystemExit</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): raised SystemExit&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): unhandled exception&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="c1"># If sys.stderr is no more (most likely from interpreter</span>
                <span class="c1"># shutdown) use self.__stderr.  Otherwise still use sys (as in</span>
                <span class="c1"># _sys) in case sys.stderr was redefined since the creation of</span>
                <span class="c1"># self.</span>
                <span class="k">if</span> <span class="n">_sys</span> <span class="ow">and</span> <span class="n">_sys</span><span class="o">.</span><span class="n">stderr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="o">&gt;&gt;</span><span class="n">_sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Exception in thread </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                         <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">_format_exc</span><span class="p">()))</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Do the best job possible w/o a huge amt. of code to</span>
                    <span class="c1"># approximate a traceback (code ideas from</span>
                    <span class="c1"># Lib/traceback.py)</span>
                    <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_tb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__exc_info</span><span class="p">()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">print</span><span class="o">&gt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span><span class="p">,</span> <span class="p">(</span>
                            <span class="s2">&quot;Exception in thread &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
                            <span class="s2">&quot; (most likely raised during interpreter shutdown):&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="o">&gt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span><span class="p">,</span> <span class="p">(</span>
                            <span class="s2">&quot;Traceback (most recent call last):&quot;</span><span class="p">)</span>
                        <span class="k">while</span> <span class="n">exc_tb</span><span class="p">:</span>
                            <span class="nb">print</span><span class="o">&gt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span><span class="p">,</span> <span class="p">(</span>
                                <span class="s1">&#39;  File &quot;</span><span class="si">%s</span><span class="s1">&quot;, line </span><span class="si">%s</span><span class="s1">, in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">,</span>
                                    <span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_lineno</span><span class="p">,</span>
                                    <span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">))</span>
                            <span class="n">exc_tb</span> <span class="o">=</span> <span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_next</span>
                        <span class="nb">print</span><span class="o">&gt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">))</span>
                    <span class="c1"># Make sure that exc_tb gets deleted since it is a memory</span>
                    <span class="c1"># hog; deleting everything else is just for thoroughness</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_tb</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): normal return&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="c1"># Prevent a race in</span>
                <span class="c1"># test_threading.test_no_refcycle_through_target when</span>
                <span class="c1"># the exception keeps the target alive past when we</span>
                <span class="c1"># assert that it&#39;s dead.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__exc_clear</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__stop</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># We don&#39;t call self.__delete() because it also</span>
                    <span class="c1"># grabs _active_limbo_lock.</span>
                    <span class="k">del</span> <span class="n">_active</span><span class="p">[</span><span class="n">_get_ident</span><span class="p">()]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># DummyThreads delete self.__block, but they have no waiters to</span>
        <span class="c1"># notify anyway (join() is forbidden on them).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_Thread__block&#39;</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Remove current thread from the dict of currently running threads.&quot;</span>

        <span class="c1"># Notes about running with dummy_thread:</span>
        <span class="c1">#</span>
        <span class="c1"># Must take care to not raise an exception if dummy_thread is being</span>
        <span class="c1"># used (and thus this module is being used as an instance of</span>
        <span class="c1"># dummy_threading).  dummy_thread.get_ident() always returns -1 since</span>
        <span class="c1"># there is only one thread if dummy_thread is being used.  Thus</span>
        <span class="c1"># len(_active) is always &lt;= 1 here, and any Thread instance created</span>
        <span class="c1"># overwrites the (if any) thread currently registered in _active.</span>
        <span class="c1">#</span>
        <span class="c1"># An instance of _MainThread is always created by &#39;threading&#39;.  This</span>
        <span class="c1"># gets overwritten the instant an instance of Thread is created; both</span>
        <span class="c1"># threads return -1 from dummy_thread.get_ident() and thus have the</span>
        <span class="c1"># same key in the dict.  So when the _MainThread instance created by</span>
        <span class="c1"># &#39;threading&#39; tries to clean itself up when atexit calls this method</span>
        <span class="c1"># it gets a KeyError if another Thread instance was created.</span>
        <span class="c1">#</span>
        <span class="c1"># This all means that KeyError from trying to delete something from</span>
        <span class="c1"># _active if dummy_threading is being used is a red herring.  But</span>
        <span class="c1"># since it isn&#39;t if dummy_threading is *not* being used then don&#39;t</span>
        <span class="c1"># hide the exception.</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">_active</span><span class="p">[</span><span class="n">_get_ident</span><span class="p">()]</span>
                <span class="c1"># There must not be any python code between the previous line</span>
                <span class="c1"># and after the lock is released.  Otherwise a tracing function</span>
                <span class="c1"># could try to acquire the lock again in the same thread, (in</span>
                <span class="c1"># current_thread()), and would block.</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;dummy_threading&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
                <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wait until the thread terminates.</span>

<span class="sd">        This blocks the calling thread until the thread whose join() method is</span>
<span class="sd">        called terminates -- either normally or through an unhandled exception</span>
<span class="sd">        or until the optional timeout occurs.</span>

<span class="sd">        When the timeout argument is present and not None, it should be a</span>
<span class="sd">        floating point number specifying a timeout for the operation in seconds</span>
<span class="sd">        (or fractions thereof). As join() always returns None, you must call</span>
<span class="sd">        isAlive() after join() to decide whether a timeout happened -- if the</span>
<span class="sd">        thread is still alive, the join() call timed out.</span>

<span class="sd">        When the timeout argument is not present or None, the operation will</span>
<span class="sd">        block until the thread terminates.</span>

<span class="sd">        A thread can be join()ed many times.</span>

<span class="sd">        join() raises a RuntimeError if an attempt is made to join the current</span>
<span class="sd">        thread as that would cause a deadlock. It is also an error to join() a</span>
<span class="sd">        thread before it has been started and attempts to do so raises the same</span>
<span class="sd">        exception.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Thread.__init__() not called&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot join thread before it is started&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">current_thread</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot join current thread&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.join(): waiting until thread stops&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.join(): thread stopped&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">deadline</span> <span class="o">=</span> <span class="n">_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span><span class="p">:</span>
                    <span class="n">delay</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">_time</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">delay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.join(): timed out&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.join(): thread stopped&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A string used for identification purposes only.</span>

<span class="sd">        It has no semantics. Multiple threads may be given the same name. The</span>
<span class="sd">        initial name is set by the constructor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ident</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Thread identifier of this thread or None if it has not been started.</span>

<span class="sd">        This is a nonzero integer. See the thread.get_ident() function. Thread</span>
<span class="sd">        identifiers may be recycled when a thread exits and another thread is</span>
<span class="sd">        created. The identifier is available even after the thread has exited.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span>

    <span class="k">def</span> <span class="nf">isAlive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the thread is alive.</span>

<span class="sd">        This method returns True just before the run() method starts until just</span>
<span class="sd">        after the run() method terminates. The module function enumerate()</span>
<span class="sd">        returns a list of all alive threads.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span>

    <span class="n">is_alive</span> <span class="o">=</span> <span class="n">isAlive</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A boolean value indicating whether this thread is a daemon thread (True) or not (False).</span>

<span class="sd">        This must be set before start() is called, otherwise RuntimeError is</span>
<span class="sd">        raised. Its initial value is inherited from the creating thread; the</span>
<span class="sd">        main thread is not a daemon thread and therefore all threads created in</span>
<span class="sd">        the main thread default to daemon = False.</span>

<span class="sd">        The entire Python program exits when no alive non-daemon threads are</span>
<span class="sd">        left.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__daemonic</span>

    <span class="nd">@daemon</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daemonic</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Thread.__init__() not called&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot set daemon status of active thread&quot;</span><span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__daemonic</span> <span class="o">=</span> <span class="n">daemonic</span>

    <span class="k">def</span> <span class="nf">isDaemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span>

    <span class="k">def</span> <span class="nf">setDaemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daemonic</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="n">daemonic</span>

    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">setName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="c1"># The timer class was contributed by Itamar Shtull-Trauring</span>

<span class="k">def</span> <span class="nf">Timer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Factory function to create a Timer object.</span>

<span class="sd">    Timers call a function after a specified number of seconds:</span>

<span class="sd">        t = Timer(30.0, f, args=[], kwargs={})</span>
<span class="sd">        t.start()</span>
<span class="sd">        t.cancel()     # stop the timer&#39;s action if it&#39;s still waiting</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_Timer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_Timer</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Call a function after a specified number of seconds:</span>

<span class="sd">            t = Timer(30.0, f, args=[], kwargs={})</span>
<span class="sd">            t.start()</span>
<span class="sd">            t.cancel()     # stop the timer&#39;s action if it&#39;s still waiting</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stop the timer if it hasn&#39;t finished yet&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

<span class="c1"># Special thread class to represent the main thread</span>
<span class="c1"># This is garbage collected through an exit handler</span>

<span class="k">class</span> <span class="nc">_MainThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;MainThread&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Thread__started</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_ident</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
            <span class="n">_active</span><span class="p">[</span><span class="n">_get_ident</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_set_daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_exitfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Thread__stop</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">_pickSomeNonDaemonThread</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: waiting for other threads&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">_pickSomeNonDaemonThread</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: exiting&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Thread__delete</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_pickSomeNonDaemonThread</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">t</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="c1"># Dummy thread class to represent threads not started here.</span>
<span class="c1"># These aren&#39;t garbage collected when they die, nor can they be waited for.</span>
<span class="c1"># If they invoke anything in threading.py that calls current_thread(), they</span>
<span class="c1"># leave an entry in the _active dict forever after.</span>
<span class="c1"># Their purpose is to return *something* from current_thread().</span>
<span class="c1"># They are marked as daemon threads so we won&#39;t wait for them</span>
<span class="c1"># when we exit (conform previous semantics).</span>

<span class="k">class</span> <span class="nc">_DummyThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">_newname</span><span class="p">(</span><span class="s2">&quot;Dummy-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="c1"># Thread.__block consumes an OS-level locking primitive, which</span>
        <span class="c1"># can never be used by a _DummyThread.  Since a _DummyThread</span>
        <span class="c1"># instance is immortal, that&#39;s bad, so release this resource.</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Thread__block</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_Thread__started</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_ident</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
            <span class="n">_active</span><span class="p">[</span><span class="n">_get_ident</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_set_daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;cannot join a dummy thread&quot;</span>


<span class="c1"># Global API functions</span>

<span class="k">def</span> <span class="nf">currentThread</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the current Thread object, corresponding to the caller&#39;s thread of control.</span>

<span class="sd">    If the caller&#39;s thread of control was not created through the threading</span>
<span class="sd">    module, a dummy thread object with limited functionality is returned.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_active</span><span class="p">[</span><span class="n">_get_ident</span><span class="p">()]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1">##print &quot;current_thread(): no current thread for&quot;, _get_ident()</span>
        <span class="k">return</span> <span class="n">_DummyThread</span><span class="p">()</span>

<span class="n">current_thread</span> <span class="o">=</span> <span class="n">currentThread</span>

<span class="k">def</span> <span class="nf">activeCount</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the number of Thread objects currently alive.</span>

<span class="sd">    The returned count is equal to the length of the list returned by</span>
<span class="sd">    enumerate().</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">_active</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">_limbo</span><span class="p">)</span>

<span class="n">active_count</span> <span class="o">=</span> <span class="n">activeCount</span>

<span class="k">def</span> <span class="nf">_enumerate</span><span class="p">():</span>
    <span class="c1"># Same as enumerate(), but without the lock. Internal use only.</span>
    <span class="k">return</span> <span class="n">_active</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="o">+</span> <span class="n">_limbo</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">enumerate</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return a list of all Thread objects currently alive.</span>

<span class="sd">    The list includes daemonic threads, dummy thread objects created by</span>
<span class="sd">    current_thread(), and the main thread. It excludes terminated threads and</span>
<span class="sd">    threads that have not yet been started.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_active</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="o">+</span> <span class="n">_limbo</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">thread</span> <span class="kn">import</span> <span class="n">stack_size</span>

<span class="c1"># Create the main thread object,</span>
<span class="c1"># and make it available for the interpreter</span>
<span class="c1"># (Py_Main) as threading._shutdown.</span>

<span class="n">_shutdown</span> <span class="o">=</span> <span class="n">_MainThread</span><span class="p">()</span><span class="o">.</span><span class="n">_exitfunc</span>

<span class="c1"># get thread-local implementation, either from the thread</span>
<span class="c1"># module, or from the python fallback</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">thread</span> <span class="kn">import</span> <span class="n">_local</span> <span class="k">as</span> <span class="n">local</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_threading_local</span> <span class="kn">import</span> <span class="n">local</span>


<span class="k">def</span> <span class="nf">_after_fork</span><span class="p">():</span>
    <span class="c1"># This function is called by Python/ceval.c:PyEval_ReInitThreads which</span>
    <span class="c1"># is called from PyOS_AfterFork.  Here we cleanup threading module state</span>
    <span class="c1"># that should not exist after a fork.</span>

    <span class="c1"># Reset _active_limbo_lock, in case we forked while the lock was held</span>
    <span class="c1"># by another (non-forked) thread.  http://bugs.python.org/issue874900</span>
    <span class="k">global</span> <span class="n">_active_limbo_lock</span>
    <span class="n">_active_limbo_lock</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>

    <span class="c1"># fork() only copied the current thread; clear references to others.</span>
    <span class="n">new_active</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">current_thread</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">_enumerate</span><span class="p">():</span>
            <span class="c1"># Any lock/condition variable may be currently locked or in an</span>
            <span class="c1"># invalid state, so we reinitialize them.</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">thread</span><span class="p">,</span> <span class="s1">&#39;_reset_internal_locks&#39;</span><span class="p">):</span>
                <span class="n">thread</span><span class="o">.</span><span class="n">_reset_internal_locks</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">thread</span> <span class="ow">is</span> <span class="n">current</span><span class="p">:</span>
                <span class="c1"># There is only one active thread. We reset the ident to</span>
                <span class="c1"># its new value since it can have changed.</span>
                <span class="n">ident</span> <span class="o">=</span> <span class="n">_get_ident</span><span class="p">()</span>
                <span class="n">thread</span><span class="o">.</span><span class="n">_Thread__ident</span> <span class="o">=</span> <span class="n">ident</span>
                <span class="n">new_active</span><span class="p">[</span><span class="n">ident</span><span class="p">]</span> <span class="o">=</span> <span class="n">thread</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># All the others are already stopped.</span>
                <span class="n">thread</span><span class="o">.</span><span class="n">_Thread__stop</span><span class="p">()</span>

        <span class="n">_limbo</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">_active</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">_active</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_active</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">_active</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>


<span class="c1"># Self-test code</span>

<span class="k">def</span> <span class="nf">_test</span><span class="p">():</span>

    <span class="k">class</span> <span class="nc">BoundedQueue</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
            <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mon</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rc</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wc</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">_deque</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;put(</span><span class="si">%s</span><span class="s2">): queue full&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wc</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;put(</span><span class="si">%s</span><span class="s2">): appended, length now </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                       <span class="n">item</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rc</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;get(): queue empty&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rc</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;get(): got </span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> left&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wc</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">item</span>

    <span class="k">class</span> <span class="nc">ProducerThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">quota</span><span class="p">):</span>
            <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Producer&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quota</span> <span class="o">=</span> <span class="n">quota</span>

        <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">random</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">quota</span><span class="p">:</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">counter</span><span class="p">))</span>
                <span class="n">_sleep</span><span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.00001</span><span class="p">)</span>


    <span class="k">class</span> <span class="nc">ConsumerThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
            <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Consumer&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span>

        <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="nb">print</span> <span class="n">item</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">NP</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">QL</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">NI</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">Q</span> <span class="o">=</span> <span class="n">BoundedQueue</span><span class="p">(</span><span class="n">QL</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NP</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ProducerThread</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">NI</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Producer-</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">ConsumerThread</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">NI</span><span class="o">*</span><span class="n">NP</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">_sleep</span><span class="p">(</span><span class="mf">0.000001</span><span class="p">)</span>
    <span class="n">C</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">C</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">_test</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Library Simplified Circulation Manager</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">circulation</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, The New York Public Library, Astor, Lenox, and Tilden Foundations.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>