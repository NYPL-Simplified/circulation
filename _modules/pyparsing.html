
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pyparsing &#8212; Library Simplified Circulation Manager  documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pyparsing</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># module pyparsing.py</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2003-2019  Paul T. McGuire</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="c1"># a copy of this software and associated documentation files (the</span>
<span class="c1"># &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="c1"># without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="c1"># distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="c1"># permit persons to whom the Software is furnished to do so, subject to</span>
<span class="c1"># the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be</span>
<span class="c1"># included in all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="c1"># EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="c1"># MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.</span>
<span class="c1"># IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY</span>
<span class="c1"># CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,</span>
<span class="c1"># TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE</span>
<span class="c1"># SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="c1">#</span>

<span class="vm">__doc__</span> <span class="o">=</span> \
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">pyparsing module - Classes and methods to define and execute parsing grammars</span>
<span class="sd">=============================================================================</span>

<span class="sd">The pyparsing module is an alternative approach to creating and</span>
<span class="sd">executing simple grammars, vs. the traditional lex/yacc approach, or the</span>
<span class="sd">use of regular expressions.  With pyparsing, you don&#39;t need to learn</span>
<span class="sd">a new syntax for defining grammars or matching expressions - the parsing</span>
<span class="sd">module provides a library of classes that you use to construct the</span>
<span class="sd">grammar directly in Python.</span>

<span class="sd">Here is a program to parse &quot;Hello, World!&quot; (or any greeting of the form</span>
<span class="sd">``&quot;&lt;salutation&gt;, &lt;addressee&gt;!&quot;``), built up using :class:`Word`,</span>
<span class="sd">:class:`Literal`, and :class:`And` elements</span>
<span class="sd">(the :class:`&#39;+&#39;&lt;ParserElement.__add__&gt;` operators create :class:`And` expressions,</span>
<span class="sd">and the strings are auto-converted to :class:`Literal` expressions)::</span>

<span class="sd">    from pyparsing import Word, alphas</span>

<span class="sd">    # define grammar of a greeting</span>
<span class="sd">    greet = Word(alphas) + &quot;,&quot; + Word(alphas) + &quot;!&quot;</span>

<span class="sd">    hello = &quot;Hello, World!&quot;</span>
<span class="sd">    print (hello, &quot;-&gt;&quot;, greet.parseString(hello))</span>

<span class="sd">The program outputs the following::</span>

<span class="sd">    Hello, World! -&gt; [&#39;Hello&#39;, &#39;,&#39;, &#39;World&#39;, &#39;!&#39;]</span>

<span class="sd">The Python representation of the grammar is quite readable, owing to the</span>
<span class="sd">self-explanatory class names, and the use of &#39;+&#39;, &#39;|&#39; and &#39;^&#39; operators.</span>

<span class="sd">The :class:`ParseResults` object returned from</span>
<span class="sd">:class:`ParserElement.parseString` can be</span>
<span class="sd">accessed as a nested list, a dictionary, or an object with named</span>
<span class="sd">attributes.</span>

<span class="sd">The pyparsing module handles some of the problems that are typically</span>
<span class="sd">vexing when writing text parsers:</span>

<span class="sd">  - extra or missing whitespace (the above program will also handle</span>
<span class="sd">    &quot;Hello,World!&quot;, &quot;Hello  ,  World  !&quot;, etc.)</span>
<span class="sd">  - quoted strings</span>
<span class="sd">  - embedded comments</span>


<span class="sd">Getting Started -</span>
<span class="sd">-----------------</span>
<span class="sd">Visit the classes :class:`ParserElement` and :class:`ParseResults` to</span>
<span class="sd">see the base classes that most other pyparsing</span>
<span class="sd">classes inherit from. Use the docstrings for examples of how to:</span>

<span class="sd"> - construct literal match expressions from :class:`Literal` and</span>
<span class="sd">   :class:`CaselessLiteral` classes</span>
<span class="sd"> - construct character word-group expressions using the :class:`Word`</span>
<span class="sd">   class</span>
<span class="sd"> - see how to create repetitive expressions using :class:`ZeroOrMore`</span>
<span class="sd">   and :class:`OneOrMore` classes</span>
<span class="sd"> - use :class:`&#39;+&#39;&lt;And&gt;`, :class:`&#39;|&#39;&lt;MatchFirst&gt;`, :class:`&#39;^&#39;&lt;Or&gt;`,</span>
<span class="sd">   and :class:`&#39;&amp;&#39;&lt;Each&gt;` operators to combine simple expressions into</span>
<span class="sd">   more complex ones</span>
<span class="sd"> - associate names with your parsed results using</span>
<span class="sd">   :class:`ParserElement.setResultsName`</span>
<span class="sd"> - access the parsed data, which is returned as a :class:`ParseResults`</span>
<span class="sd">   object</span>
<span class="sd"> - find some helpful expression short-cuts like :class:`delimitedList`</span>
<span class="sd">   and :class:`oneOf`</span>
<span class="sd"> - find more useful common expressions in the :class:`pyparsing_common`</span>
<span class="sd">   namespace class</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;2.4.7&quot;</span>
<span class="n">__versionTime__</span> <span class="o">=</span> <span class="s2">&quot;30 Mar 2020 00:43 UTC&quot;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Paul McGuire &lt;ptmcg@users.sourceforge.net&gt;&quot;</span>

<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">from</span> <span class="nn">weakref</span> <span class="kn">import</span> <span class="n">ref</span> <span class="k">as</span> <span class="n">wkref</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sre_constants</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Python 3</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">filterfalse</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">ifilterfalse</span> <span class="k">as</span> <span class="n">filterfalse</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_thread</span> <span class="kn">import</span> <span class="n">RLock</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">RLock</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Python 3</span>
    <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
    <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">Mapping</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># Python 2.7</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Iterable</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span> <span class="k">as</span> <span class="n">_OrderedDict</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">ordereddict</span> <span class="kn">import</span> <span class="n">OrderedDict</span> <span class="k">as</span> <span class="n">_OrderedDict</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">_OrderedDict</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">SimpleNamespace</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">SimpleNamespace</span><span class="p">:</span> <span class="k">pass</span>

<span class="c1"># version compatibility configuration</span>
<span class="n">__compat__</span> <span class="o">=</span> <span class="n">SimpleNamespace</span><span class="p">()</span>
<span class="n">__compat__</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    A cross-version compatibility configuration for pyparsing features that will be</span>
<span class="s2">    released in a future version. By setting values in this configuration to True,</span>
<span class="s2">    those features can be enabled in prior versions for compatibility development</span>
<span class="s2">    and testing.</span>

<span class="s2">     - collect_all_And_tokens - flag to enable fix for Issue #63 that fixes erroneous grouping</span>
<span class="s2">       of results names when an And expression is nested within an Or or MatchFirst; set to</span>
<span class="s2">       True to enable bugfix released in pyparsing 2.3.0, or False to preserve</span>
<span class="s2">       pre-2.3.0 handling of named results</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">__compat__</span><span class="o">.</span><span class="n">collect_all_And_tokens</span> <span class="o">=</span> <span class="kc">True</span>

<span class="n">__diag__</span> <span class="o">=</span> <span class="n">SimpleNamespace</span><span class="p">()</span>
<span class="n">__diag__</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Diagnostic configuration (all default to False)</span>
<span class="s2">     - warn_multiple_tokens_in_named_alternation - flag to enable warnings when a results</span>
<span class="s2">       name is defined on a MatchFirst or Or expression with one or more And subexpressions</span>
<span class="s2">       (only warns if __compat__.collect_all_And_tokens is False)</span>
<span class="s2">     - warn_ungrouped_named_tokens_in_collection - flag to enable warnings when a results</span>
<span class="s2">       name is defined on a containing expression with ungrouped subexpressions that also</span>
<span class="s2">       have results names</span>
<span class="s2">     - warn_name_set_on_empty_Forward - flag to enable warnings whan a Forward is defined</span>
<span class="s2">       with a results name, but has no contents defined</span>
<span class="s2">     - warn_on_multiple_string_args_to_oneof - flag to enable warnings whan oneOf is</span>
<span class="s2">       incorrectly called with multiple str arguments</span>
<span class="s2">     - enable_debug_on_named_expressions - flag to auto-enable debug on all subsequent</span>
<span class="s2">       calls to ParserElement.setName()</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">__diag__</span><span class="o">.</span><span class="n">warn_multiple_tokens_in_named_alternation</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">__diag__</span><span class="o">.</span><span class="n">warn_ungrouped_named_tokens_in_collection</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">__diag__</span><span class="o">.</span><span class="n">warn_name_set_on_empty_Forward</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">__diag__</span><span class="o">.</span><span class="n">warn_on_multiple_string_args_to_oneof</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">__diag__</span><span class="o">.</span><span class="n">enable_debug_on_named_expressions</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">__diag__</span><span class="o">.</span><span class="n">_all_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">nm</span> <span class="k">for</span> <span class="n">nm</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">__diag__</span><span class="p">)</span> <span class="k">if</span> <span class="n">nm</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;enable_&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">nm</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;warn_&quot;</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_enable_all_warnings</span><span class="p">():</span>
    <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_multiple_tokens_in_named_alternation</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_ungrouped_named_tokens_in_collection</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_name_set_on_empty_Forward</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_on_multiple_string_args_to_oneof</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">__diag__</span><span class="o">.</span><span class="n">enable_all_warnings</span> <span class="o">=</span> <span class="n">_enable_all_warnings</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;__version__&#39;</span><span class="p">,</span> <span class="s1">&#39;__versionTime__&#39;</span><span class="p">,</span> <span class="s1">&#39;__author__&#39;</span><span class="p">,</span> <span class="s1">&#39;__compat__&#39;</span><span class="p">,</span> <span class="s1">&#39;__diag__&#39;</span><span class="p">,</span>
           <span class="s1">&#39;And&#39;</span><span class="p">,</span> <span class="s1">&#39;CaselessKeyword&#39;</span><span class="p">,</span> <span class="s1">&#39;CaselessLiteral&#39;</span><span class="p">,</span> <span class="s1">&#39;CharsNotIn&#39;</span><span class="p">,</span> <span class="s1">&#39;Combine&#39;</span><span class="p">,</span> <span class="s1">&#39;Dict&#39;</span><span class="p">,</span> <span class="s1">&#39;Each&#39;</span><span class="p">,</span> <span class="s1">&#39;Empty&#39;</span><span class="p">,</span>
           <span class="s1">&#39;FollowedBy&#39;</span><span class="p">,</span> <span class="s1">&#39;Forward&#39;</span><span class="p">,</span> <span class="s1">&#39;GoToColumn&#39;</span><span class="p">,</span> <span class="s1">&#39;Group&#39;</span><span class="p">,</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">,</span> <span class="s1">&#39;LineEnd&#39;</span><span class="p">,</span> <span class="s1">&#39;LineStart&#39;</span><span class="p">,</span> <span class="s1">&#39;Literal&#39;</span><span class="p">,</span>
           <span class="s1">&#39;PrecededBy&#39;</span><span class="p">,</span> <span class="s1">&#39;MatchFirst&#39;</span><span class="p">,</span> <span class="s1">&#39;NoMatch&#39;</span><span class="p">,</span> <span class="s1">&#39;NotAny&#39;</span><span class="p">,</span> <span class="s1">&#39;OneOrMore&#39;</span><span class="p">,</span> <span class="s1">&#39;OnlyOnce&#39;</span><span class="p">,</span> <span class="s1">&#39;Optional&#39;</span><span class="p">,</span> <span class="s1">&#39;Or&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ParseBaseException&#39;</span><span class="p">,</span> <span class="s1">&#39;ParseElementEnhance&#39;</span><span class="p">,</span> <span class="s1">&#39;ParseException&#39;</span><span class="p">,</span> <span class="s1">&#39;ParseExpression&#39;</span><span class="p">,</span> <span class="s1">&#39;ParseFatalException&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ParseResults&#39;</span><span class="p">,</span> <span class="s1">&#39;ParseSyntaxException&#39;</span><span class="p">,</span> <span class="s1">&#39;ParserElement&#39;</span><span class="p">,</span> <span class="s1">&#39;QuotedString&#39;</span><span class="p">,</span> <span class="s1">&#39;RecursiveGrammarException&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Regex&#39;</span><span class="p">,</span> <span class="s1">&#39;SkipTo&#39;</span><span class="p">,</span> <span class="s1">&#39;StringEnd&#39;</span><span class="p">,</span> <span class="s1">&#39;StringStart&#39;</span><span class="p">,</span> <span class="s1">&#39;Suppress&#39;</span><span class="p">,</span> <span class="s1">&#39;Token&#39;</span><span class="p">,</span> <span class="s1">&#39;TokenConverter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;White&#39;</span><span class="p">,</span> <span class="s1">&#39;Word&#39;</span><span class="p">,</span> <span class="s1">&#39;WordEnd&#39;</span><span class="p">,</span> <span class="s1">&#39;WordStart&#39;</span><span class="p">,</span> <span class="s1">&#39;ZeroOrMore&#39;</span><span class="p">,</span> <span class="s1">&#39;Char&#39;</span><span class="p">,</span>
           <span class="s1">&#39;alphanums&#39;</span><span class="p">,</span> <span class="s1">&#39;alphas&#39;</span><span class="p">,</span> <span class="s1">&#39;alphas8bit&#39;</span><span class="p">,</span> <span class="s1">&#39;anyCloseTag&#39;</span><span class="p">,</span> <span class="s1">&#39;anyOpenTag&#39;</span><span class="p">,</span> <span class="s1">&#39;cStyleComment&#39;</span><span class="p">,</span> <span class="s1">&#39;col&#39;</span><span class="p">,</span>
           <span class="s1">&#39;commaSeparatedList&#39;</span><span class="p">,</span> <span class="s1">&#39;commonHTMLEntity&#39;</span><span class="p">,</span> <span class="s1">&#39;countedArray&#39;</span><span class="p">,</span> <span class="s1">&#39;cppStyleComment&#39;</span><span class="p">,</span> <span class="s1">&#39;dblQuotedString&#39;</span><span class="p">,</span>
           <span class="s1">&#39;dblSlashComment&#39;</span><span class="p">,</span> <span class="s1">&#39;delimitedList&#39;</span><span class="p">,</span> <span class="s1">&#39;dictOf&#39;</span><span class="p">,</span> <span class="s1">&#39;downcaseTokens&#39;</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="s1">&#39;hexnums&#39;</span><span class="p">,</span>
           <span class="s1">&#39;htmlComment&#39;</span><span class="p">,</span> <span class="s1">&#39;javaStyleComment&#39;</span><span class="p">,</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;lineEnd&#39;</span><span class="p">,</span> <span class="s1">&#39;lineStart&#39;</span><span class="p">,</span> <span class="s1">&#39;lineno&#39;</span><span class="p">,</span>
           <span class="s1">&#39;makeHTMLTags&#39;</span><span class="p">,</span> <span class="s1">&#39;makeXMLTags&#39;</span><span class="p">,</span> <span class="s1">&#39;matchOnlyAtCol&#39;</span><span class="p">,</span> <span class="s1">&#39;matchPreviousExpr&#39;</span><span class="p">,</span> <span class="s1">&#39;matchPreviousLiteral&#39;</span><span class="p">,</span>
           <span class="s1">&#39;nestedExpr&#39;</span><span class="p">,</span> <span class="s1">&#39;nullDebugAction&#39;</span><span class="p">,</span> <span class="s1">&#39;nums&#39;</span><span class="p">,</span> <span class="s1">&#39;oneOf&#39;</span><span class="p">,</span> <span class="s1">&#39;opAssoc&#39;</span><span class="p">,</span> <span class="s1">&#39;operatorPrecedence&#39;</span><span class="p">,</span> <span class="s1">&#39;printables&#39;</span><span class="p">,</span>
           <span class="s1">&#39;punc8bit&#39;</span><span class="p">,</span> <span class="s1">&#39;pythonStyleComment&#39;</span><span class="p">,</span> <span class="s1">&#39;quotedString&#39;</span><span class="p">,</span> <span class="s1">&#39;removeQuotes&#39;</span><span class="p">,</span> <span class="s1">&#39;replaceHTMLEntity&#39;</span><span class="p">,</span>
           <span class="s1">&#39;replaceWith&#39;</span><span class="p">,</span> <span class="s1">&#39;restOfLine&#39;</span><span class="p">,</span> <span class="s1">&#39;sglQuotedString&#39;</span><span class="p">,</span> <span class="s1">&#39;srange&#39;</span><span class="p">,</span> <span class="s1">&#39;stringEnd&#39;</span><span class="p">,</span>
           <span class="s1">&#39;stringStart&#39;</span><span class="p">,</span> <span class="s1">&#39;traceParseAction&#39;</span><span class="p">,</span> <span class="s1">&#39;unicodeString&#39;</span><span class="p">,</span> <span class="s1">&#39;upcaseTokens&#39;</span><span class="p">,</span> <span class="s1">&#39;withAttribute&#39;</span><span class="p">,</span>
           <span class="s1">&#39;indentedBlock&#39;</span><span class="p">,</span> <span class="s1">&#39;originalTextFor&#39;</span><span class="p">,</span> <span class="s1">&#39;ungroup&#39;</span><span class="p">,</span> <span class="s1">&#39;infixNotation&#39;</span><span class="p">,</span> <span class="s1">&#39;locatedExpr&#39;</span><span class="p">,</span> <span class="s1">&#39;withClass&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CloseMatch&#39;</span><span class="p">,</span> <span class="s1">&#39;tokenMap&#39;</span><span class="p">,</span> <span class="s1">&#39;pyparsing_common&#39;</span><span class="p">,</span> <span class="s1">&#39;pyparsing_unicode&#39;</span><span class="p">,</span> <span class="s1">&#39;unicode_set&#39;</span><span class="p">,</span>
           <span class="s1">&#39;conditionAsParseAction&#39;</span><span class="p">,</span> <span class="s1">&#39;re&#39;</span><span class="p">,</span>
           <span class="p">]</span>

<span class="n">system_version</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">PY_3</span> <span class="o">=</span> <span class="n">system_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
<span class="k">if</span> <span class="n">PY_3</span><span class="p">:</span>
    <span class="n">_MAX_INT</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
    <span class="n">basestring</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="n">unichr</span> <span class="o">=</span> <span class="nb">chr</span>
    <span class="n">unicode</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="n">_ustr</span> <span class="o">=</span> <span class="nb">str</span>

    <span class="c1"># build list of single arg builtins, that can be used as parse actions</span>
    <span class="n">singleArgBuiltins</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">any</span><span class="p">,</span> <span class="nb">all</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">]</span>

<span class="k">else</span><span class="p">:</span>
    <span class="n">_MAX_INT</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxint</span>
    <span class="nb">range</span> <span class="o">=</span> <span class="n">xrange</span>

    <span class="k">def</span> <span class="nf">_ustr</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drop-in replacement for str(obj) that tries to be Unicode</span>
<span class="sd">        friendly. It first tries str(obj). If that fails with</span>
<span class="sd">        a UnicodeEncodeError, then it tries unicode(obj). It then</span>
<span class="sd">        &lt; returns the unicode object | encodes it with the default</span>
<span class="sd">        encoding | ... &gt;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">unicode</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># If this works, then _ustr(obj) has the same behaviour as str(obj), so</span>
            <span class="c1"># it won&#39;t break any existing code.</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>
            <span class="c1"># Else encode it</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">unicode</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getdefaultencoding</span><span class="p">(),</span> <span class="s1">&#39;xmlcharrefreplace&#39;</span><span class="p">)</span>
            <span class="n">xmlcharref</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&amp;#\d+;&#39;</span><span class="p">)</span>
            <span class="n">xmlcharref</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">u&#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">2</span><span class="p">:])</span>
            <span class="k">return</span> <span class="n">xmlcharref</span><span class="o">.</span><span class="n">transformString</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

    <span class="c1"># build list of single arg builtins, tolerant of Python version, that can be used as parse actions</span>
    <span class="n">singleArgBuiltins</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="kn">import</span> <span class="nn">__builtin__</span>

    <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="s2">&quot;sum len sorted reversed list tuple set any all min max&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">singleArgBuiltins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">__builtin__</span><span class="p">,</span> <span class="n">fname</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">continue</span>

<span class="n">_generatorType</span> <span class="o">=</span> <span class="nb">type</span><span class="p">((</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">_xml_escape</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Escape &amp;, &lt;, &gt;, &quot;, &#39;, etc. in a string of data.&quot;&quot;&quot;</span>

    <span class="c1"># ampersand must be replaced first</span>
    <span class="n">from_symbols</span> <span class="o">=</span> <span class="s1">&#39;&amp;&gt;&lt;&quot;</span><span class="se">\&#39;</span><span class="s1">&#39;</span>
    <span class="n">to_symbols</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&amp;&#39;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;;&#39;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="s2">&quot;amp gt lt quot apos&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">from_</span><span class="p">,</span> <span class="n">to_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">from_symbols</span><span class="p">,</span> <span class="n">to_symbols</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">from_</span><span class="p">,</span> <span class="n">to_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="n">alphas</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span>
<span class="n">nums</span> <span class="o">=</span> <span class="s2">&quot;0123456789&quot;</span>
<span class="n">hexnums</span> <span class="o">=</span> <span class="n">nums</span> <span class="o">+</span> <span class="s2">&quot;ABCDEFabcdef&quot;</span>
<span class="n">alphanums</span> <span class="o">=</span> <span class="n">alphas</span> <span class="o">+</span> <span class="n">nums</span>
<span class="n">_bslash</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span>
<span class="n">printables</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">printable</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">whitespace</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">conditionAsParseAction</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fatal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">message</span> <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;failed user-defined condition&quot;</span>
    <span class="n">exc_type</span> <span class="o">=</span> <span class="n">ParseFatalException</span> <span class="k">if</span> <span class="n">fatal</span> <span class="k">else</span> <span class="n">ParseException</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">_trim_arity</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">exc_type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pa</span>

<span class="k">class</span> <span class="nc">ParseBaseException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;base exception class for all parsing runtime exceptions&quot;&quot;&quot;</span>
    <span class="c1"># Performance tuning: we construct a *lot* of these, so keep this</span>
    <span class="c1"># constructor as small and fast as possible</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pstr</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elem</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">pstr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span> <span class="o">=</span> <span class="n">pstr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parserElement</span> <span class="o">=</span> <span class="n">elem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">pstr</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_exception</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">pe</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        internal factory method to simplify creating one type of ParseException</span>
<span class="sd">        from another - avoids having __init__ signature conflicts among subclasses</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">pe</span><span class="o">.</span><span class="n">pstr</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="n">msg</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="n">parserElement</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;supported attributes by name are:</span>
<span class="sd">           - lineno - returns the line number of the exception text</span>
<span class="sd">           - col - returns the column number of the exception text</span>
<span class="sd">           - line - returns the line containing the exception text</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">aname</span> <span class="o">==</span> <span class="s2">&quot;lineno&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lineno</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">aname</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;column&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">col</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">aname</span> <span class="o">==</span> <span class="s2">&quot;line&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">aname</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pstr</span><span class="p">):</span>
                <span class="n">foundstr</span> <span class="o">=</span> <span class="s1">&#39;, found end of text&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">foundstr</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;, found </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">foundstr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">  (at char </span><span class="si">%d</span><span class="s2">), (line:</span><span class="si">%d</span><span class="s2">, col:</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">,</span> <span class="n">foundstr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">))</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">markInputline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">markerString</span><span class="o">=</span><span class="s2">&quot;&gt;!&lt;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts the exception line from the input string, and marks</span>
<span class="sd">           the location of the exception with a special symbol.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">line_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span>
        <span class="n">line_column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">markerString</span><span class="p">:</span>
            <span class="n">line_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">line_str</span><span class="p">[:</span><span class="n">line_column</span><span class="p">],</span>
                                <span class="n">markerString</span><span class="p">,</span> <span class="n">line_str</span><span class="p">[</span><span class="n">line_column</span><span class="p">:]))</span>
        <span class="k">return</span> <span class="n">line_str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;lineno col line&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="o">+</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">ParseException</span><span class="p">(</span><span class="n">ParseBaseException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception thrown when parse expressions don&#39;t match class;</span>
<span class="sd">    supported attributes by name are:</span>
<span class="sd">    - lineno - returns the line number of the exception text</span>
<span class="sd">    - col - returns the column number of the exception text</span>
<span class="sd">    - line - returns the line containing the exception text</span>

<span class="sd">    Example::</span>

<span class="sd">        try:</span>
<span class="sd">            Word(nums).setName(&quot;integer&quot;).parseString(&quot;ABC&quot;)</span>
<span class="sd">        except ParseException as pe:</span>
<span class="sd">            print(pe)</span>
<span class="sd">            print(&quot;column: {}&quot;.format(pe.col))</span>

<span class="sd">    prints::</span>

<span class="sd">       Expected integer (at char 0), (line:1, col:1)</span>
<span class="sd">        column: 1</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">explain</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">16</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to take an exception and translate the Python internal traceback into a list</span>
<span class="sd">        of the pyparsing expressions that caused the exception to be raised.</span>

<span class="sd">        Parameters:</span>

<span class="sd">         - exc - exception raised during parsing (need not be a ParseException, in support</span>
<span class="sd">           of Python exceptions that might be raised in a parse action)</span>
<span class="sd">         - depth (default=16) - number of levels back in the stack trace to list expression</span>
<span class="sd">           and function names; if None, the full stack trace names will be listed; if 0, only</span>
<span class="sd">           the failing input line, marker, and exception string will be shown</span>

<span class="sd">        Returns a multi-line string listing the ParserElements and/or function names in the</span>
<span class="sd">        exception&#39;s stack trace.</span>

<span class="sd">        Note: the diagnostic output will include string representations of the expressions</span>
<span class="sd">        that failed to parse. These representations will be more helpful if you use `setName` to</span>
<span class="sd">        give identifiable names to your expressions. Otherwise they will use the default string</span>
<span class="sd">        forms, which may be cryptic to read.</span>

<span class="sd">        explain() is only supported under Python 3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">inspect</span>

        <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrecursionlimit</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">ParseBaseException</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">line</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">callers</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getinnerframes</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">depth</span><span class="p">)</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">callers</span><span class="p">[</span><span class="o">-</span><span class="n">depth</span><span class="p">:]):</span>
                <span class="n">frm</span> <span class="o">=</span> <span class="n">ff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">f_self</span> <span class="o">=</span> <span class="n">frm</span><span class="o">.</span><span class="n">f_locals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f_self</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">frm</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;parseImpl&#39;</span><span class="p">,</span> <span class="s1">&#39;_parseNoCache&#39;</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">f_self</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f_self</span><span class="p">)</span>

                    <span class="n">self_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">f_self</span><span class="p">)</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.</span><span class="si">{1}</span><span class="s2"> - </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">self_type</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                                                      <span class="n">self_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                      <span class="n">f_self</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">f_self</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">self_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">f_self</span><span class="p">)</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">self_type</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                                                <span class="n">self_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">code</span> <span class="o">=</span> <span class="n">frm</span><span class="o">.</span><span class="n">f_code</span>
                    <span class="k">if</span> <span class="n">code</span><span class="o">.</span><span class="n">co_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;wrapper&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;module&gt;&#39;</span><span class="p">):</span>
                        <span class="k">continue</span>

                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">co_name</span><span class="p">))</span>

                <span class="n">depth</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">depth</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ParseFatalException</span><span class="p">(</span><span class="n">ParseBaseException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;user-throwable exception thrown when inconsistent parse content</span>
<span class="sd">       is found; stops all parsing immediately&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">ParseSyntaxException</span><span class="p">(</span><span class="n">ParseFatalException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;just like :class:`ParseFatalException`, but thrown internally</span>
<span class="sd">    when an :class:`ErrorStop&lt;And._ErrorStop&gt;` (&#39;-&#39; operator) indicates</span>
<span class="sd">    that parsing is to stop immediately because an unbacktrackable</span>
<span class="sd">    syntax error has been found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="c1">#~ class ReparseException(ParseBaseException):</span>
    <span class="c1">#~ &quot;&quot;&quot;Experimental class - parse actions can raise this exception to cause</span>
       <span class="c1">#~ pyparsing to reparse the input string:</span>
        <span class="c1">#~ - with a modified input string, and/or</span>
        <span class="c1">#~ - with a modified start location</span>
       <span class="c1">#~ Set the values of the ReparseException in the constructor, and raise the</span>
       <span class="c1">#~ exception in a parse action to cause pyparsing to use the new string/location.</span>
       <span class="c1">#~ Setting the values as None causes no change to be made.</span>
       <span class="c1">#~ &quot;&quot;&quot;</span>
    <span class="c1">#~ def __init_( self, newstring, restartLoc ):</span>
        <span class="c1">#~ self.newParseText = newstring</span>
        <span class="c1">#~ self.reparseLoc = restartLoc</span>

<span class="k">class</span> <span class="nc">RecursiveGrammarException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;exception thrown by :class:`ParserElement.validate` if the</span>
<span class="sd">    grammar could be improperly recursive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parseElementTrace</span> <span class="o">=</span> <span class="n">parseElementList</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;RecursiveGrammarException: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseElementTrace</span>

<span class="k">class</span> <span class="nc">_ParseResultsWithOffset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tup</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">setOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ParseResults</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Structured parse results, to provide multiple means of access to</span>
<span class="sd">    the parsed data:</span>

<span class="sd">       - as a list (``len(results)``)</span>
<span class="sd">       - by list index (``results[0], results[1]``, etc.)</span>
<span class="sd">       - by attribute (``results.&lt;resultsName&gt;`` - see :class:`ParserElement.setResultsName`)</span>

<span class="sd">    Example::</span>

<span class="sd">        integer = Word(nums)</span>
<span class="sd">        date_str = (integer.setResultsName(&quot;year&quot;) + &#39;/&#39;</span>
<span class="sd">                        + integer.setResultsName(&quot;month&quot;) + &#39;/&#39;</span>
<span class="sd">                        + integer.setResultsName(&quot;day&quot;))</span>
<span class="sd">        # equivalent form:</span>
<span class="sd">        # date_str = integer(&quot;year&quot;) + &#39;/&#39; + integer(&quot;month&quot;) + &#39;/&#39; + integer(&quot;day&quot;)</span>

<span class="sd">        # parseString returns a ParseResults object</span>
<span class="sd">        result = date_str.parseString(&quot;1999/12/31&quot;)</span>

<span class="sd">        def test(s, fn=repr):</span>
<span class="sd">            print(&quot;%s -&gt; %s&quot; % (s, fn(eval(s))))</span>
<span class="sd">        test(&quot;list(result)&quot;)</span>
<span class="sd">        test(&quot;result[0]&quot;)</span>
<span class="sd">        test(&quot;result[&#39;month&#39;]&quot;)</span>
<span class="sd">        test(&quot;result.day&quot;)</span>
<span class="sd">        test(&quot;&#39;month&#39; in result&quot;)</span>
<span class="sd">        test(&quot;&#39;minutes&#39; in result&quot;)</span>
<span class="sd">        test(&quot;result.dump()&quot;, str)</span>

<span class="sd">    prints::</span>

<span class="sd">        list(result) -&gt; [&#39;1999&#39;, &#39;/&#39;, &#39;12&#39;, &#39;/&#39;, &#39;31&#39;]</span>
<span class="sd">        result[0] -&gt; &#39;1999&#39;</span>
<span class="sd">        result[&#39;month&#39;] -&gt; &#39;12&#39;</span>
<span class="sd">        result.day -&gt; &#39;31&#39;</span>
<span class="sd">        &#39;month&#39; in result -&gt; True</span>
<span class="sd">        &#39;minutes&#39; in result -&gt; False</span>
<span class="sd">        result.dump() -&gt; [&#39;1999&#39;, &#39;/&#39;, &#39;12&#39;, &#39;/&#39;, &#39;31&#39;]</span>
<span class="sd">        - day: 31</span>
<span class="sd">        - month: 12</span>
<span class="sd">        - year: 1999</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">toklist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asList</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">modal</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">toklist</span>
        <span class="n">retobj</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">retobj</span><span class="o">.</span><span class="n">__doinit</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">retobj</span>

    <span class="c1"># Performance tuning: we construct a *lot* of these, so keep this</span>
    <span class="c1"># constructor as small and fast as possible</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toklist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asList</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">modal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">isinstance</span><span class="o">=</span><span class="nb">isinstance</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__doinit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__doinit</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__asList</span> <span class="o">=</span> <span class="n">asList</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__modal</span> <span class="o">=</span> <span class="n">modal</span>
            <span class="k">if</span> <span class="n">toklist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">toklist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="o">=</span> <span class="n">toklist</span><span class="p">[:]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span> <span class="n">_generatorType</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">toklist</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="o">=</span> <span class="p">[</span><span class="n">toklist</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">modal</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># will always return a str, but use _ustr for consistency</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">basestring</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="n">toklist</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[])):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
                    <span class="n">toklist</span> <span class="o">=</span> <span class="p">[</span><span class="n">toklist</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">asList</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">ParseResults</span><span class="p">(</span><span class="n">toklist</span><span class="o">.</span><span class="n">__toklist</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">ParseResults</span><span class="p">(</span><span class="n">toklist</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">toklist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">toklist</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ParseResults</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="nb">isinstance</span><span class="o">=</span><span class="nb">isinstance</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_ParseResultsWithOffset</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">list</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">list</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
            <span class="n">sub</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="n">wkref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="n">mylen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># convert int to slice</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="n">mylen</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># get removed indices</span>
            <span class="n">removed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">mylen</span><span class="p">)))</span>
            <span class="n">removed</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="c1"># fixup indices in token dictionary</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">occurrences</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">occurrences</span><span class="p">):</span>
                        <span class="n">occurrences</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">position</span> <span class="o">-</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="ow">not</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">)</span>
    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">,</span> <span class="s2">&quot;iterkeys&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iterkeys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iterkeys</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">PY_3</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">_iterkeys</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result keys.&quot;&quot;&quot;</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">_itervalues</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result values.&quot;&quot;&quot;</span>

        <span class="n">items</span> <span class="o">=</span> <span class="n">_iteritems</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result key-value tuples.&quot;&quot;&quot;</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">iterkeys</span> <span class="o">=</span> <span class="n">_iterkeys</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result keys (Python 2.x only).&quot;&quot;&quot;</span>

        <span class="n">itervalues</span> <span class="o">=</span> <span class="n">_itervalues</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result values (Python 2.x only).&quot;&quot;&quot;</span>

        <span class="n">iteritems</span> <span class="o">=</span> <span class="n">_iteritems</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result key-value tuples (Python 2.x only).&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns all named result keys (as a list in Python 2.x, as an iterator in Python 3.x).&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns all named result values (as a list in Python 2.x, as an iterator in Python 3.x).&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">itervalues</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns all named result key-values (as a list of tuples in Python 2.x, as an iterator in Python 3.x).&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">haskeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Since keys() returns an iterator, this method is helpful in bypassing</span>
<span class="sd">           code that looks for the existence of any defined results names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes and returns item at specified index (default= ``last``).</span>
<span class="sd">        Supports both ``list`` and ``dict`` semantics for ``pop()``. If</span>
<span class="sd">        passed no argument or an integer argument, it will use ``list``</span>
<span class="sd">        semantics and pop tokens from the list of parsed tokens. If passed</span>
<span class="sd">        a non-integer argument (most likely a string), it will use ``dict``</span>
<span class="sd">        semantics and pop the corresponding value from any defined results</span>
<span class="sd">        names. A second default return value argument is supported, just as in</span>
<span class="sd">        ``dict.pop()``.</span>

<span class="sd">        Example::</span>

<span class="sd">            def remove_first(tokens):</span>
<span class="sd">                tokens.pop(0)</span>
<span class="sd">            print(OneOrMore(Word(nums)).parseString(&quot;0 123 321&quot;)) # -&gt; [&#39;0&#39;, &#39;123&#39;, &#39;321&#39;]</span>
<span class="sd">            print(OneOrMore(Word(nums)).addParseAction(remove_first).parseString(&quot;0 123 321&quot;)) # -&gt; [&#39;123&#39;, &#39;321&#39;]</span>

<span class="sd">            label = Word(alphas)</span>
<span class="sd">            patt = label(&quot;LABEL&quot;) + OneOrMore(Word(nums))</span>
<span class="sd">            print(patt.parseString(&quot;AAB 123 321&quot;).dump())</span>

<span class="sd">            # Use pop() in a parse action to remove named result (note that corresponding value is not</span>
<span class="sd">            # removed from list form of results)</span>
<span class="sd">            def remove_LABEL(tokens):</span>
<span class="sd">                tokens.pop(&quot;LABEL&quot;)</span>
<span class="sd">                return tokens</span>
<span class="sd">            patt.addParseAction(remove_LABEL)</span>
<span class="sd">            print(patt.parseString(&quot;AAB 123 321&quot;).dump())</span>

<span class="sd">        prints::</span>

<span class="sd">            [&#39;AAB&#39;, &#39;123&#39;, &#39;321&#39;]</span>
<span class="sd">            - LABEL: AAB</span>

<span class="sd">            [&#39;AAB&#39;, &#39;123&#39;, &#39;321&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;pop() got an unexpected keyword argument &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">or</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">defaultvalue</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">defaultvalue</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">defaultValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns named result matching the given key, or if there is no</span>
<span class="sd">        such name, then returns the given ``defaultValue`` or ``None`` if no</span>
<span class="sd">        ``defaultValue`` is specified.</span>

<span class="sd">        Similar to ``dict.get()``.</span>

<span class="sd">        Example::</span>

<span class="sd">            integer = Word(nums)</span>
<span class="sd">            date_str = integer(&quot;year&quot;) + &#39;/&#39; + integer(&quot;month&quot;) + &#39;/&#39; + integer(&quot;day&quot;)</span>

<span class="sd">            result = date_str.parseString(&quot;1999/12/31&quot;)</span>
<span class="sd">            print(result.get(&quot;year&quot;)) # -&gt; &#39;1999&#39;</span>
<span class="sd">            print(result.get(&quot;hour&quot;, &quot;not specified&quot;)) # -&gt; &#39;not specified&#39;</span>
<span class="sd">            print(result.get(&quot;hour&quot;)) # -&gt; None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">defaultValue</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">insStr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts new element at location index in the list of parsed tokens.</span>

<span class="sd">        Similar to ``list.insert()``.</span>

<span class="sd">        Example::</span>

<span class="sd">            print(OneOrMore(Word(nums)).parseString(&quot;0 123 321&quot;)) # -&gt; [&#39;0&#39;, &#39;123&#39;, &#39;321&#39;]</span>

<span class="sd">            # use a parse action to insert the parse location in the front of the parsed results</span>
<span class="sd">            def insert_locn(locn, tokens):</span>
<span class="sd">                tokens.insert(0, locn)</span>
<span class="sd">            print(OneOrMore(Word(nums)).addParseAction(insert_locn).parseString(&quot;0 123 321&quot;)) # -&gt; [0, &#39;0&#39;, &#39;123&#39;, &#39;321&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">insStr</span><span class="p">)</span>
        <span class="c1"># fixup indices in token dictionary</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">occurrences</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">occurrences</span><span class="p">):</span>
                <span class="n">occurrences</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">position</span> <span class="o">+</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;</span> <span class="n">index</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add single element to end of ParseResults list of elements.</span>

<span class="sd">        Example::</span>

<span class="sd">            print(OneOrMore(Word(nums)).parseString(&quot;0 123 321&quot;)) # -&gt; [&#39;0&#39;, &#39;123&#39;, &#39;321&#39;]</span>

<span class="sd">            # use a parse action to compute the sum of the parsed integers, and add it to the end</span>
<span class="sd">            def append_sum(tokens):</span>
<span class="sd">                tokens.append(sum(map(int, tokens)))</span>
<span class="sd">            print(OneOrMore(Word(nums)).addParseAction(append_sum).parseString(&quot;0 123 321&quot;)) # -&gt; [&#39;0&#39;, &#39;123&#39;, &#39;321&#39;, 444]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itemseq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add sequence of elements to end of ParseResults list of elements.</span>

<span class="sd">        Example::</span>

<span class="sd">            patt = OneOrMore(Word(alphas))</span>

<span class="sd">            # use a parse action to append the reverse of the matched strings, to make a palindrome</span>
<span class="sd">            def make_palindrome(tokens):</span>
<span class="sd">                tokens.extend(reversed([t[::-1] for t in tokens]))</span>
<span class="sd">                return &#39;&#39;.join(tokens)</span>
<span class="sd">            print(patt.addParseAction(make_palindrome).parseString(&quot;lskdj sdlkjf lksd&quot;)) # -&gt; &#39;lskdjsdlkjflksddsklfjkldsjdksl&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">itemseq</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">(</span><span class="n">itemseq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">itemseq</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear all elements and results names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">)</span>
            <span class="n">addoffset</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">offset</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">a</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="n">otheritems</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="n">otherdictitems</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">addoffset</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                              <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">vlist</span> <span class="ow">in</span> <span class="n">otheritems</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">otherdictitems</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ParseResults</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="n">wkref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">__toklist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__accumNames</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># useful for merging many ParseResults using sum() builtin</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this may raise a TypeError - so be it</span>
            <span class="k">return</span> <span class="n">other</span> <span class="o">+</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">)</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>

    <span class="k">def</span> <span class="nf">_asStringList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">and</span> <span class="n">sep</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="n">item</span><span class="o">.</span><span class="n">_asStringList</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">asList</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the parse results as a nested list of matching tokens, all converted to strings.</span>

<span class="sd">        Example::</span>

<span class="sd">            patt = OneOrMore(Word(alphas))</span>
<span class="sd">            result = patt.parseString(&quot;sldkj lsdkj sldkj&quot;)</span>
<span class="sd">            # even though the result prints in string-like form, it is actually a pyparsing ParseResults</span>
<span class="sd">            print(type(result), result) # -&gt; &lt;class &#39;pyparsing.ParseResults&#39;&gt; [&#39;sldkj&#39;, &#39;lsdkj&#39;, &#39;sldkj&#39;]</span>

<span class="sd">            # Use asList() to create an actual list</span>
<span class="sd">            result_list = result.asList()</span>
<span class="sd">            print(type(result_list), result_list) # -&gt; &lt;class &#39;list&#39;&gt; [&#39;sldkj&#39;, &#39;lsdkj&#39;, &#39;sldkj&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">asList</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">)</span> <span class="k">else</span> <span class="n">res</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">asDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the named parse results as a nested dictionary.</span>

<span class="sd">        Example::</span>

<span class="sd">            integer = Word(nums)</span>
<span class="sd">            date_str = integer(&quot;year&quot;) + &#39;/&#39; + integer(&quot;month&quot;) + &#39;/&#39; + integer(&quot;day&quot;)</span>

<span class="sd">            result = date_str.parseString(&#39;12/31/1999&#39;)</span>
<span class="sd">            print(type(result), repr(result)) # -&gt; &lt;class &#39;pyparsing.ParseResults&#39;&gt; ([&#39;12&#39;, &#39;/&#39;, &#39;31&#39;, &#39;/&#39;, &#39;1999&#39;], {&#39;day&#39;: [(&#39;1999&#39;, 4)], &#39;year&#39;: [(&#39;12&#39;, 0)], &#39;month&#39;: [(&#39;31&#39;, 2)]})</span>

<span class="sd">            result_dict = result.asDict()</span>
<span class="sd">            print(type(result_dict), repr(result_dict)) # -&gt; &lt;class &#39;dict&#39;&gt; {&#39;day&#39;: &#39;1999&#39;, &#39;year&#39;: &#39;12&#39;, &#39;month&#39;: &#39;31&#39;}</span>

<span class="sd">            # even though a ParseResults supports dict-like access, sometime you just need to have a dict</span>
<span class="sd">            import json</span>
<span class="sd">            print(json.dumps(result)) # -&gt; Exception: TypeError: ... is not JSON serializable</span>
<span class="sd">            print(json.dumps(result.asDict())) # -&gt; {&quot;month&quot;: &quot;31&quot;, &quot;day&quot;: &quot;1999&quot;, &quot;year&quot;: &quot;12&quot;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">PY_3</span><span class="p">:</span>
            <span class="n">item_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">item_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span>

        <span class="k">def</span> <span class="nf">toItem</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">asDict</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">toItem</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">obj</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">toItem</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">item_fn</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new copy of a :class:`ParseResults` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">__tokdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">__accumNames</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">asXML</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doctag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">namedItemsOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">formatted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (Deprecated) Returns the parse results as XML. Tags are created for tokens and lists that have defined results names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">namedItems</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">vlist</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                          <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">)</span>
        <span class="n">nextLevelIndent</span> <span class="o">=</span> <span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;  &quot;</span>

        <span class="c1"># collapse out indents if formatting is not desired</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">formatted</span><span class="p">:</span>
            <span class="n">indent</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">nextLevelIndent</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">nl</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">selfTag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">doctag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selfTag</span> <span class="o">=</span> <span class="n">doctag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">:</span>
                <span class="n">selfTag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">selfTag</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">namedItemsOnly</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selfTag</span> <span class="o">=</span> <span class="s2">&quot;ITEM&quot;</span>

        <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nl</span><span class="p">,</span> <span class="n">indent</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">selfTag</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">namedItems</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">asXML</span><span class="p">(</span><span class="n">namedItems</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                      <span class="n">namedItemsOnly</span> <span class="ow">and</span> <span class="n">doctag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">nextLevelIndent</span><span class="p">,</span>
                                      <span class="n">formatted</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">asXML</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">namedItemsOnly</span> <span class="ow">and</span> <span class="n">doctag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">nextLevelIndent</span><span class="p">,</span>
                                      <span class="n">formatted</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># individual token, see if there is a name for it</span>
                <span class="n">resTag</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">namedItems</span><span class="p">:</span>
                    <span class="n">resTag</span> <span class="o">=</span> <span class="n">namedItems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">resTag</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">namedItemsOnly</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">resTag</span> <span class="o">=</span> <span class="s2">&quot;ITEM&quot;</span>
                <span class="n">xmlBodyText</span> <span class="o">=</span> <span class="n">_xml_escape</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nl</span><span class="p">,</span> <span class="n">nextLevelIndent</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">resTag</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
                        <span class="n">xmlBodyText</span><span class="p">,</span>
                                                <span class="s2">&quot;&lt;/&quot;</span><span class="p">,</span> <span class="n">resTag</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">]</span>

        <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nl</span><span class="p">,</span> <span class="n">indent</span><span class="p">,</span> <span class="s2">&quot;&lt;/&quot;</span><span class="p">,</span> <span class="n">selfTag</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">vlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sub</span> <span class="ow">is</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">k</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the results name for this token expression. Useful when several</span>
<span class="sd">        different expressions might match at a particular location.</span>

<span class="sd">        Example::</span>

<span class="sd">            integer = Word(nums)</span>
<span class="sd">            ssn_expr = Regex(r&quot;\d\d\d-\d\d-\d\d\d\d&quot;)</span>
<span class="sd">            house_number_expr = Suppress(&#39;#&#39;) + Word(nums, alphanums)</span>
<span class="sd">            user_data = (Group(house_number_expr)(&quot;house_number&quot;)</span>
<span class="sd">                        | Group(ssn_expr)(&quot;ssn&quot;)</span>
<span class="sd">                        | Group(integer)(&quot;age&quot;))</span>
<span class="sd">            user_info = OneOrMore(user_data)</span>

<span class="sd">            result = user_info.parseString(&quot;22 111-22-3333 #221B&quot;)</span>
<span class="sd">            for item in result:</span>
<span class="sd">                print(item.getName(), &#39;:&#39;, item[0])</span>

<span class="sd">        prints::</span>

<span class="sd">            age : 22</span>
<span class="sd">            ssn : 111-22-3333</span>
<span class="sd">            house_number : 221B</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span><span class="p">:</span>
            <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">par</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">par</span><span class="o">.</span><span class="n">__lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
              <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
              <span class="ow">and</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">values</span><span class="p">()))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_list</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Diagnostic method for listing out the contents of</span>
<span class="sd">        a :class:`ParseResults`. Accepts an optional ``indent`` argument so</span>
<span class="sd">        that this string can be embedded in a nested display of other data.</span>

<span class="sd">        Example::</span>

<span class="sd">            integer = Word(nums)</span>
<span class="sd">            date_str = integer(&quot;year&quot;) + &#39;/&#39; + integer(&quot;month&quot;) + &#39;/&#39; + integer(&quot;day&quot;)</span>

<span class="sd">            result = date_str.parseString(&#39;12/31/1999&#39;)</span>
<span class="sd">            print(result.dump())</span>

<span class="sd">        prints::</span>

<span class="sd">            [&#39;12&#39;, &#39;/&#39;, &#39;31&#39;, &#39;/&#39;, &#39;1999&#39;]</span>
<span class="sd">            - day: 1999</span>
<span class="sd">            - month: 31</span>
<span class="sd">            - year: 12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">NL</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="n">include_list</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asList</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
                <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NL</span><span class="p">)</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">- </span><span class="si">%s</span><span class="s2">: &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;  &#39;</span> <span class="o">*</span> <span class="n">_depth</span><span class="p">),</span> <span class="n">k</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">v</span><span class="p">:</span>
                            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">,</span> <span class="n">include_list</span><span class="o">=</span><span class="n">include_list</span><span class="p">,</span> <span class="n">_depth</span><span class="o">=</span><span class="n">_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">)</span> <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]:</span><span class="se">\n</span><span class="si">%s%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span>
                                                            <span class="p">(</span><span class="s1">&#39;  &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">_depth</span><span class="p">)),</span>
                                                            <span class="n">i</span><span class="p">,</span>
                                                            <span class="n">indent</span><span class="p">,</span>
                                                            <span class="p">(</span><span class="s1">&#39;  &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
                                                            <span class="n">vv</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">,</span>
                                                                    <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">,</span>
                                                                    <span class="n">include_list</span><span class="o">=</span><span class="n">include_list</span><span class="p">,</span>
                                                                    <span class="n">_depth</span><span class="o">=</span><span class="n">_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]:</span><span class="se">\n</span><span class="si">%s%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span>
                                                            <span class="p">(</span><span class="s1">&#39;  &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">_depth</span><span class="p">)),</span>
                                                            <span class="n">i</span><span class="p">,</span>
                                                            <span class="n">indent</span><span class="p">,</span>
                                                            <span class="p">(</span><span class="s1">&#39;  &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
                                                            <span class="n">_ustr</span><span class="p">(</span><span class="n">vv</span><span class="p">)))</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty-printer for parsed results as a list, using the</span>
<span class="sd">        `pprint &lt;https://docs.python.org/3/library/pprint.html&gt;`_ module.</span>
<span class="sd">        Accepts additional positional or keyword args as defined for</span>
<span class="sd">        `pprint.pprint &lt;https://docs.python.org/3/library/pprint.html#pprint.pprint&gt;`_ .</span>

<span class="sd">        Example::</span>

<span class="sd">            ident = Word(alphas, alphanums)</span>
<span class="sd">            num = Word(nums)</span>
<span class="sd">            func = Forward()</span>
<span class="sd">            term = ident | num | Group(&#39;(&#39; + func + &#39;)&#39;)</span>
<span class="sd">            func &lt;&lt;= ident + Group(Optional(delimitedList(term)))</span>
<span class="sd">            result = func.parseString(&quot;fna a,b,(fnb c,d,200),100&quot;)</span>
<span class="sd">            result.pprint(width=40)</span>

<span class="sd">        prints::</span>

<span class="sd">            [&#39;fna&#39;,</span>
<span class="sd">             [&#39;a&#39;,</span>
<span class="sd">              &#39;b&#39;,</span>
<span class="sd">              [&#39;(&#39;, &#39;fnb&#39;, [&#39;c&#39;, &#39;d&#39;, &#39;200&#39;], &#39;)&#39;],</span>
<span class="sd">              &#39;100&#39;]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asList</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># add support for pickle protocol</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span><span class="p">()</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">,</span> <span class="n">par</span><span class="p">,</span> <span class="n">inAccumNames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">inAccumNames</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="n">wkref</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__asList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__modal</span>

    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper classmethod to construct a ParseResults from a dict, preserving the</span>
<span class="sd">        name-value relations as results names. If an optional &#39;name&#39; argument is</span>
<span class="sd">        given, a nested ParseResults will be returned</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">is_iterable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">PY_3</span><span class="p">:</span>
                    <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">basestring</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="bp">cls</span><span class="p">([</span><span class="n">v</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">asList</span><span class="o">=</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">([</span><span class="n">ret</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

<span class="n">MutableMapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ParseResults</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">col</span> <span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">strg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns current column within a string, counting newlines as line separators.</span>
<span class="sd">   The first column is number 1.</span>

<span class="sd">   Note: the default parsing behavior is to expand tabs in the input string</span>
<span class="sd">   before starting the parsing process.  See</span>
<span class="sd">   :class:`ParserElement.parseString` for more</span>
<span class="sd">   information on parsing strings containing ``&lt;TAB&gt;`` s, and suggested</span>
<span class="sd">   methods to maintain a consistent view of the parsed string, the parse</span>
<span class="sd">   location, and line and column positions within the parsed string.</span>
<span class="sd">   &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">strg</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">loc</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="k">else</span> <span class="n">loc</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lineno</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">strg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns current line number within a string, counting newlines as line separators.</span>
<span class="sd">    The first line is number 1.</span>

<span class="sd">    Note - the default parsing behavior is to expand tabs in the input string</span>
<span class="sd">    before starting the parsing process.  See :class:`ParserElement.parseString`</span>
<span class="sd">    for more information on parsing strings containing ``&lt;TAB&gt;`` s, and</span>
<span class="sd">    suggested methods to maintain a consistent view of the parsed string, the</span>
<span class="sd">    parse location, and line and column positions within the parsed string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">strg</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">line</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">strg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the line of text containing loc within a string, counting newlines as line separators.</span>
<span class="sd">       &quot;&quot;&quot;</span>
    <span class="n">lastCR</span> <span class="o">=</span> <span class="n">strg</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
    <span class="n">nextCR</span> <span class="o">=</span> <span class="n">strg</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nextCR</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">strg</span><span class="p">[</span><span class="n">lastCR</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">nextCR</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">strg</span><span class="p">[</span><span class="n">lastCR</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">_defaultStartDebugAction</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;Match &quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; at loc &quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lineno</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">),</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">))))</span>

<span class="k">def</span> <span class="nf">_defaultSuccessDebugAction</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">startloc</span><span class="p">,</span> <span class="n">endloc</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">toks</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Matched &quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; -&gt; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">toks</span><span class="o">.</span><span class="n">asList</span><span class="p">()))</span>

<span class="k">def</span> <span class="nf">_defaultExceptionDebugAction</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exception raised:&quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">nullDebugAction</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&#39;Do-nothing&#39; debug action, to suppress debugging output during parsing.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="c1"># Only works on Python 3.x - nonlocal is toxic to Python 2 installs</span>
<span class="c1">#~ &#39;decorator to trim function calls to match the arity of the target&#39;</span>
<span class="c1">#~ def _trim_arity(func, maxargs=3):</span>
    <span class="c1">#~ if func in singleArgBuiltins:</span>
        <span class="c1">#~ return lambda s,l,t: func(t)</span>
    <span class="c1">#~ limit = 0</span>
    <span class="c1">#~ foundArity = False</span>
    <span class="c1">#~ def wrapper(*args):</span>
        <span class="c1">#~ nonlocal limit,foundArity</span>
        <span class="c1">#~ while 1:</span>
            <span class="c1">#~ try:</span>
                <span class="c1">#~ ret = func(*args[limit:])</span>
                <span class="c1">#~ foundArity = True</span>
                <span class="c1">#~ return ret</span>
            <span class="c1">#~ except TypeError:</span>
                <span class="c1">#~ if limit == maxargs or foundArity:</span>
                    <span class="c1">#~ raise</span>
                <span class="c1">#~ limit += 1</span>
                <span class="c1">#~ continue</span>
    <span class="c1">#~ return wrapper</span>

<span class="c1"># this version is Python 2.x-3.x cross-compatible</span>
<span class="s1">&#39;decorator to trim function calls to match the arity of the target&#39;</span>
<span class="k">def</span> <span class="nf">_trim_arity</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">maxargs</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">singleArgBuiltins</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">foundArity</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>

    <span class="c1"># traceback return data structure changed in Py3.5 - normalize back to plain tuples</span>
    <span class="k">if</span> <span class="n">system_version</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="c1"># special handling for Python 3.5.0 - extra deep call stack by 1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span> <span class="k">if</span> <span class="n">system_version</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">2</span>
            <span class="n">frame_summary</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=-</span><span class="n">offset</span> <span class="o">+</span> <span class="n">limit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="n">offset</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">frame_summary</span><span class="p">[:</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">def</span> <span class="nf">extract_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="n">frame_summary</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">frame_summary</span><span class="p">[:</span><span class="mi">2</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extract_stack</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span>
        <span class="n">extract_tb</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_tb</span>

    <span class="c1"># synthesize what would be returned by traceback.extract_stack at the call to</span>
    <span class="c1"># user&#39;s parse action &#39;func&#39;, so that we don&#39;t incur call penalty at parse time</span>

    <span class="n">LINE_DIFF</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="c1"># IF ANY CODE CHANGES, EVEN JUST COMMENTS OR BLANK LINES, BETWEEN THE NEXT LINE AND</span>
    <span class="c1"># THE CALL TO FUNC INSIDE WRAPPER, LINE_DIFF MUST BE MODIFIED!!!!</span>
    <span class="n">this_line</span> <span class="o">=</span> <span class="n">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pa_call_line_synth</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this_line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">LINE_DIFF</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">]:])</span>
                <span class="n">foundArity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># re-raise TypeErrors if they did not come from our arity testing</span>
                <span class="k">if</span> <span class="n">foundArity</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">extract_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">pa_call_line_synth</span><span class="p">:</span>
                            <span class="k">raise</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">tb</span>
                        <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                            <span class="k">pass</span>

                <span class="k">if</span> <span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">maxargs</span><span class="p">:</span>
                    <span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">raise</span>

    <span class="c1"># copy func name to wrapper for sensible debug output</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="s2">&quot;&lt;parse action&gt;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span>
                            <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__class__&#39;</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">func_name</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">class</span> <span class="nc">ParserElement</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract base level parser element class.&quot;&quot;&quot;</span>
    <span class="n">DEFAULT_WHITE_CHARS</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="se">\n\t\r</span><span class="s2">&quot;</span>
    <span class="n">verbose_stacktrace</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">setDefaultWhitespaceChars</span><span class="p">(</span><span class="n">chars</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides the default whitespace chars</span>

<span class="sd">        Example::</span>

<span class="sd">            # default whitespace chars are space, &lt;TAB&gt; and newline</span>
<span class="sd">            OneOrMore(Word(alphas)).parseString(&quot;abc def\nghi jkl&quot;)  # -&gt; [&#39;abc&#39;, &#39;def&#39;, &#39;ghi&#39;, &#39;jkl&#39;]</span>

<span class="sd">            # change to just treat newline as significant</span>
<span class="sd">            ParserElement.setDefaultWhitespaceChars(&quot; \t&quot;)</span>
<span class="sd">            OneOrMore(Word(alphas)).parseString(&quot;abc def\nghi jkl&quot;)  # -&gt; [&#39;abc&#39;, &#39;def&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span> <span class="o">=</span> <span class="n">chars</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">inlineLiteralsUsing</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set class to be used for inclusion of string literals into a parser.</span>

<span class="sd">        Example::</span>

<span class="sd">            # default literal class used is Literal</span>
<span class="sd">            integer = Word(nums)</span>
<span class="sd">            date_str = integer(&quot;year&quot;) + &#39;/&#39; + integer(&quot;month&quot;) + &#39;/&#39; + integer(&quot;day&quot;)</span>

<span class="sd">            date_str.parseString(&quot;1999/12/31&quot;)  # -&gt; [&#39;1999&#39;, &#39;/&#39;, &#39;12&#39;, &#39;/&#39;, &#39;31&#39;]</span>


<span class="sd">            # change to Suppress</span>
<span class="sd">            ParserElement.inlineLiteralsUsing(Suppress)</span>
<span class="sd">            date_str = integer(&quot;year&quot;) + &#39;/&#39; + integer(&quot;month&quot;) + &#39;/&#39; + integer(&quot;day&quot;)</span>

<span class="sd">            date_str.parseString(&quot;1999/12/31&quot;)  # -&gt; [&#39;1999&#39;, &#39;12&#39;, &#39;31&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span> <span class="o">=</span> <span class="bp">cls</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_trim_traceback</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">tb</span><span class="o">.</span><span class="n">tb_next</span><span class="p">:</span>
            <span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">tb_next</span>
        <span class="k">return</span> <span class="n">tb</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># ~ self.name = &quot;&lt;unknown&gt;&quot;  # don&#39;t define self.name, let subclasses try/except upcall</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="n">savelist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># used when checking for left-recursion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># used to optimize exception handling for subclasses that don&#39;t advance parse index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># used to mark results names as modal (report only last) or cumulative (list all)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># custom debug actions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># used to avoid redundant calls to preParse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of this :class:`ParserElement`.  Useful for defining</span>
<span class="sd">        different parse actions for the same parsing pattern, using copies of</span>
<span class="sd">        the original parse element.</span>

<span class="sd">        Example::</span>

<span class="sd">            integer = Word(nums).setParseAction(lambda toks: int(toks[0]))</span>
<span class="sd">            integerK = integer.copy().addParseAction(lambda toks: toks[0] * 1024) + Suppress(&quot;K&quot;)</span>
<span class="sd">            integerM = integer.copy().addParseAction(lambda toks: toks[0] * 1024 * 1024) + Suppress(&quot;M&quot;)</span>

<span class="sd">            print(OneOrMore(integerK | integerM | integer).parseString(&quot;5K 100 640K 256M&quot;))</span>

<span class="sd">        prints::</span>

<span class="sd">            [5120, 100, 655360, 268435456]</span>

<span class="sd">        Equivalent form of ``expr.copy()`` is just ``expr()``::</span>

<span class="sd">            integerM = integer().addParseAction(lambda toks: toks[0] * 1024 * 1024) + Suppress(&quot;M&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">cpy</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="p">[:]</span>
        <span class="n">cpy</span><span class="o">.</span><span class="n">ignoreExprs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span><span class="p">:</span>
            <span class="n">cpy</span><span class="o">.</span><span class="n">whiteChars</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span>
        <span class="k">return</span> <span class="n">cpy</span>

    <span class="k">def</span> <span class="nf">setName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define name for this expression, makes debugging and exception messages clearer.</span>

<span class="sd">        Example::</span>

<span class="sd">            Word(nums).parseString(&quot;ABC&quot;)  # -&gt; Exception: Expected W:(0123...) (at char 0), (line:1, col:1)</span>
<span class="sd">            Word(nums).setName(&quot;integer&quot;).parseString(&quot;ABC&quot;)  # -&gt; Exception: Expected integer (at char 0), (line:1, col:1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">__diag__</span><span class="o">.</span><span class="n">enable_debug_on_named_expressions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setDebug</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define name for referencing matching tokens as a nested attribute</span>
<span class="sd">        of the returned parse results.</span>
<span class="sd">        NOTE: this returns a *copy* of the original :class:`ParserElement` object;</span>
<span class="sd">        this is so that the client can define a basic element, such as an</span>
<span class="sd">        integer, and reference it in multiple places with different names.</span>

<span class="sd">        You can also set results names using the abbreviated syntax,</span>
<span class="sd">        ``expr(&quot;name&quot;)`` in place of ``expr.setResultsName(&quot;name&quot;)``</span>
<span class="sd">        - see :class:`__call__`.</span>

<span class="sd">        Example::</span>

<span class="sd">            date_str = (integer.setResultsName(&quot;year&quot;) + &#39;/&#39;</span>
<span class="sd">                        + integer.setResultsName(&quot;month&quot;) + &#39;/&#39;</span>
<span class="sd">                        + integer.setResultsName(&quot;day&quot;))</span>

<span class="sd">            # equivalent form:</span>
<span class="sd">            date_str = integer(&quot;year&quot;) + &#39;/&#39; + integer(&quot;month&quot;) + &#39;/&#39; + integer(&quot;day&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">newself</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">listAllMatches</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">newself</span><span class="o">.</span><span class="n">resultsName</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">newself</span><span class="o">.</span><span class="n">modalResults</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">listAllMatches</span>
        <span class="k">return</span> <span class="n">newself</span>

    <span class="k">def</span> <span class="nf">setBreak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">breakFlag</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to invoke the Python pdb debugger when this element is</span>
<span class="sd">           about to be parsed. Set ``breakFlag`` to True to enable, False to</span>
<span class="sd">           disable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">breakFlag</span><span class="p">:</span>
            <span class="n">_parseMethod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span>
            <span class="k">def</span> <span class="nf">breaker</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">pdb</span>
                <span class="c1"># this call to pdb.set_trace() is intentional, not a checkin error</span>
                <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">_parseMethod</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="p">)</span>
            <span class="n">breaker</span><span class="o">.</span><span class="n">_originalParseMethod</span> <span class="o">=</span> <span class="n">_parseMethod</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span> <span class="o">=</span> <span class="n">breaker</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">,</span> <span class="s2">&quot;_originalParseMethod&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="o">.</span><span class="n">_originalParseMethod</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">setParseAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fns</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define one or more actions to perform when successfully matching parse element definition.</span>
<span class="sd">        Parse action fn is a callable method with 0-3 arguments, called as ``fn(s, loc, toks)`` ,</span>
<span class="sd">        ``fn(loc, toks)`` , ``fn(toks)`` , or just ``fn()`` , where:</span>

<span class="sd">        - s   = the original string being parsed (see note below)</span>
<span class="sd">        - loc = the location of the matching substring</span>
<span class="sd">        - toks = a list of the matched tokens, packaged as a :class:`ParseResults` object</span>

<span class="sd">        If the functions in fns modify the tokens, they can return them as the return</span>
<span class="sd">        value from fn, and the modified list of tokens will replace the original.</span>
<span class="sd">        Otherwise, fn does not need to return any value.</span>

<span class="sd">        If None is passed as the parse action, all previously added parse actions for this</span>
<span class="sd">        expression are cleared.</span>

<span class="sd">        Optional keyword arguments:</span>
<span class="sd">        - callDuringTry = (default= ``False``) indicate if parse action should be run during lookaheads and alternate testing</span>

<span class="sd">        Note: the default parsing behavior is to expand tabs in the input string</span>
<span class="sd">        before starting the parsing process.  See :class:`parseString for more</span>
<span class="sd">        information on parsing strings containing ``&lt;TAB&gt;`` s, and suggested</span>
<span class="sd">        methods to maintain a consistent view of the parsed string, the parse</span>
<span class="sd">        location, and line and column positions within the parsed string.</span>

<span class="sd">        Example::</span>

<span class="sd">            integer = Word(nums)</span>
<span class="sd">            date_str = integer + &#39;/&#39; + integer + &#39;/&#39; + integer</span>

<span class="sd">            date_str.parseString(&quot;1999/12/31&quot;)  # -&gt; [&#39;1999&#39;, &#39;/&#39;, &#39;12&#39;, &#39;/&#39;, &#39;31&#39;]</span>

<span class="sd">            # use parse action to convert to ints at parse time</span>
<span class="sd">            integer = Word(nums).setParseAction(lambda toks: int(toks[0]))</span>
<span class="sd">            date_str = integer + &#39;/&#39; + integer + &#39;/&#39; + integer</span>

<span class="sd">            # note that integer fields are now ints, not strings</span>
<span class="sd">            date_str.parseString(&quot;1999/12/31&quot;)  # -&gt; [1999, &#39;/&#39;, 12, &#39;/&#39;, 31]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">fns</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="kc">None</span><span class="p">,]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;parse actions must be callable&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_trim_arity</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">fns</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">addParseAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fns</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add one or more parse actions to expression&#39;s list of parse actions. See :class:`setParseAction`.</span>

<span class="sd">        See examples in :class:`copy`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_trim_arity</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">fns</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">addCondition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fns</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a boolean predicate function to expression&#39;s list of parse actions. See</span>
<span class="sd">        :class:`setParseAction` for function call signatures. Unlike ``setParseAction``,</span>
<span class="sd">        functions passed to ``addCondition`` need to return boolean success/fail of the condition.</span>

<span class="sd">        Optional keyword arguments:</span>
<span class="sd">        - message = define a custom message to be used in the raised exception</span>
<span class="sd">        - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException</span>

<span class="sd">        Example::</span>

<span class="sd">            integer = Word(nums).setParseAction(lambda toks: int(toks[0]))</span>
<span class="sd">            year_int = integer.copy()</span>
<span class="sd">            year_int.addCondition(lambda toks: toks[0] &gt;= 2000, message=&quot;Only support years 2000 and later&quot;)</span>
<span class="sd">            date_str = year_int + &#39;/&#39; + integer + &#39;/&#39; + integer</span>

<span class="sd">            result = date_str.parseString(&quot;1999/12/31&quot;)  # -&gt; Exception: Only support years 2000 and later (at char 0), (line:1, col:1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conditionAsParseAction</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">),</span>
                                                           <span class="n">fatal</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fatal&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">setFailAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define action to perform if parsing fails at this expression.</span>
<span class="sd">           Fail acton fn is a callable function that takes the arguments</span>
<span class="sd">           ``fn(s, loc, expr, err)`` where:</span>
<span class="sd">           - s = string being parsed</span>
<span class="sd">           - loc = location where expression match was attempted and failed</span>
<span class="sd">           - expr = the parse expression that failed</span>
<span class="sd">           - err = the exception thrown</span>
<span class="sd">           The function returns no value.  It may throw :class:`ParseFatalException`</span>
<span class="sd">           if it is desired to stop parsing immediately.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span> <span class="o">=</span> <span class="n">fn</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_skipIgnorables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="n">exprsFound</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">exprsFound</span><span class="p">:</span>
            <span class="n">exprsFound</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">loc</span><span class="p">,</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                        <span class="n">exprsFound</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">except</span> <span class="n">ParseException</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">preParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipIgnorables</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span><span class="p">:</span>
            <span class="n">wt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span>
            <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">wt</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tokenlist</span>

    <span class="c1"># ~ @profile</span>
    <span class="k">def</span> <span class="nf">_parseNoCache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">TRY</span><span class="p">,</span> <span class="n">MATCH</span><span class="p">,</span> <span class="n">FAIL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
        <span class="n">debugging</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">)</span>  <span class="c1"># and doActions)</span>

        <span class="k">if</span> <span class="n">debugging</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span><span class="p">:</span>
            <span class="c1"># ~ print (&quot;Match&quot;, self, &quot;at loc&quot;, loc, &quot;(%d, %d)&quot; % (lineno(loc, instring), col(loc, instring)))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="n">TRY</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="n">TRY</span><span class="p">](</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">callPreParse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span><span class="p">:</span>
                    <span class="n">preloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">preloc</span> <span class="o">=</span> <span class="n">loc</span>
                <span class="n">tokensStart</span> <span class="o">=</span> <span class="n">preloc</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="ow">or</span> <span class="n">preloc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="c1"># ~ print (&quot;Exception raised:&quot;, err)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="n">FAIL</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="n">FAIL</span><span class="p">](</span><span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
                <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callPreParse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span><span class="p">:</span>
                <span class="n">preloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">preloc</span> <span class="o">=</span> <span class="n">loc</span>
            <span class="n">tokensStart</span> <span class="o">=</span> <span class="n">preloc</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="ow">or</span> <span class="n">preloc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>

        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span><span class="p">)</span>

        <span class="n">retTokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span> <span class="n">asList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span><span class="p">,</span> <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="ow">and</span> <span class="p">(</span><span class="n">doActions</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">debugging</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">tokens</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="n">retTokens</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">parse_action_exc</span><span class="p">:</span>
                            <span class="n">exc</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span><span class="s2">&quot;exception raised in parse action&quot;</span><span class="p">)</span>
                            <span class="n">exc</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">parse_action_exc</span>
                            <span class="k">raise</span> <span class="n">exc</span>

                        <span class="k">if</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">retTokens</span><span class="p">:</span>
                            <span class="n">retTokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span>
                                                      <span class="n">asList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="p">(</span><span class="n">ParseResults</span><span class="p">,</span> <span class="nb">list</span><span class="p">)),</span>
                                                      <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="c1"># ~ print &quot;Exception raised in user parse action:&quot;, err</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="n">FAIL</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="n">FAIL</span><span class="p">](</span><span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
                    <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">tokens</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="n">retTokens</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">parse_action_exc</span><span class="p">:</span>
                        <span class="n">exc</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span><span class="s2">&quot;exception raised in parse action&quot;</span><span class="p">)</span>
                        <span class="n">exc</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">parse_action_exc</span>
                        <span class="k">raise</span> <span class="n">exc</span>

                    <span class="k">if</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">retTokens</span><span class="p">:</span>
                        <span class="n">retTokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span>
                                                  <span class="n">asList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="p">(</span><span class="n">ParseResults</span><span class="p">,</span> <span class="nb">list</span><span class="p">)),</span>
                                                  <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debugging</span><span class="p">:</span>
            <span class="c1"># ~ print (&quot;Matched&quot;, self, &quot;-&gt;&quot;, retTokens.asList())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="n">MATCH</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="n">MATCH</span><span class="p">](</span><span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">retTokens</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">retTokens</span>

    <span class="k">def</span> <span class="nf">tryParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="n">ParseFatalException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">canParseNext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tryParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">class</span> <span class="nc">_UnboundedCache</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">not_in_cache</span> <span class="o">=</span> <span class="n">not_in_cache</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">not_in_cache</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">cache_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">clear</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">cache_len</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_OrderedDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">class</span> <span class="nc">_FifoCache</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">not_in_cache</span> <span class="o">=</span> <span class="n">not_in_cache</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

                <span class="n">cache</span> <span class="o">=</span> <span class="n">_OrderedDict</span><span class="p">()</span>

                <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">not_in_cache</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">cache</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">pass</span>

                <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

                <span class="k">def</span> <span class="nf">cache_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clear</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">clear</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">cache_len</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">class</span> <span class="nc">_FifoCache</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">not_in_cache</span> <span class="o">=</span> <span class="n">not_in_cache</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

                <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">key_fifo</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([],</span> <span class="n">size</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">not_in_cache</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_fifo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">:</span>
                        <span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key_fifo</span><span class="o">.</span><span class="n">popleft</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">key_fifo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="n">key_fifo</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

                <span class="k">def</span> <span class="nf">cache_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">get</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clear</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">clear</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">cache_len</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c1"># argument cache for optimizing repeated calls when backtracking through recursive expressions</span>
    <span class="n">packrat_cache</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># this is set later by enabledPackrat(); this is here so that resetCache() doesn&#39;t fail</span>
    <span class="n">packrat_cache_lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>
    <span class="n">packrat_cache_stats</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># this method gets repeatedly called during backtracking with the same arguments -</span>
    <span class="c1"># we can cache these arguments and save ourselves the trouble of re-parsing the contained expression</span>
    <span class="k">def</span> <span class="nf">_parseCache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">HIT</span><span class="p">,</span> <span class="n">MISS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
        <span class="n">lookup</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">callPreParse</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache_lock</span><span class="p">:</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">cache</span><span class="o">.</span><span class="n">not_in_cache</span><span class="p">:</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache_stats</span><span class="p">[</span><span class="n">MISS</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parseNoCache</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">pe</span><span class="p">:</span>
                    <span class="c1"># cache a copy of the exception, without the traceback</span>
                    <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">lookup</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">pe</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
                    <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">lookup</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()))</span>
                    <span class="k">return</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache_stats</span><span class="p">[</span><span class="n">HIT</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">value</span>
                <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_parse</span> <span class="o">=</span> <span class="n">_parseNoCache</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">resetCache</span><span class="p">():</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache_stats</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache_stats</span><span class="p">)</span>

    <span class="n">_packratEnabled</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">enablePackrat</span><span class="p">(</span><span class="n">cache_size_limit</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enables &quot;packrat&quot; parsing, which adds memoizing to the parsing logic.</span>
<span class="sd">           Repeated parse attempts at the same string location (which happens</span>
<span class="sd">           often in many complex grammars) can immediately return a cached value,</span>
<span class="sd">           instead of re-executing parsing/validating code.  Memoizing is done of</span>
<span class="sd">           both valid results and parsing exceptions.</span>

<span class="sd">           Parameters:</span>

<span class="sd">           - cache_size_limit - (default= ``128``) - if an integer value is provided</span>
<span class="sd">             will limit the size of the packrat cache; if None is passed, then</span>
<span class="sd">             the cache size will be unbounded; if 0 is passed, the cache will</span>
<span class="sd">             be effectively disabled.</span>

<span class="sd">           This speedup may break existing programs that use parse actions that</span>
<span class="sd">           have side-effects.  For this reason, packrat parsing is disabled when</span>
<span class="sd">           you first import pyparsing.  To activate the packrat feature, your</span>
<span class="sd">           program must call the class method :class:`ParserElement.enablePackrat`.</span>
<span class="sd">           For best results, call ``enablePackrat()`` immediately after</span>
<span class="sd">           importing pyparsing.</span>

<span class="sd">           Example::</span>

<span class="sd">               import pyparsing</span>
<span class="sd">               pyparsing.ParserElement.enablePackrat()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_packratEnabled</span><span class="p">:</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">_packratEnabled</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">cache_size_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_UnboundedCache</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_FifoCache</span><span class="p">(</span><span class="n">cache_size_limit</span><span class="p">)</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">_parse</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_parseCache</span>

    <span class="k">def</span> <span class="nf">parseString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the parse expression with the given string.</span>
<span class="sd">        This is the main interface to the client code, once the complete</span>
<span class="sd">        expression has been built.</span>

<span class="sd">        Returns the parsed data as a :class:`ParseResults` object, which may be</span>
<span class="sd">        accessed as a list, or as a dict or object with attributes if the given parser</span>
<span class="sd">        includes results names.</span>

<span class="sd">        If you want the grammar to require that the entire input string be</span>
<span class="sd">        successfully parsed, then set ``parseAll`` to True (equivalent to ending</span>
<span class="sd">        the grammar with ``StringEnd()``).</span>

<span class="sd">        Note: ``parseString`` implicitly calls ``expandtabs()`` on the input string,</span>
<span class="sd">        in order to report proper column numbers in parse actions.</span>
<span class="sd">        If the input string contains tabs and</span>
<span class="sd">        the grammar uses parse actions that use the ``loc`` argument to index into the</span>
<span class="sd">        string being parsed, you can ensure you have a consistent view of the input</span>
<span class="sd">        string by:</span>

<span class="sd">        - calling ``parseWithTabs`` on your grammar before calling ``parseString``</span>
<span class="sd">          (see :class:`parseWithTabs`)</span>
<span class="sd">        - define your parse action using the full ``(s, loc, toks)`` signature, and</span>
<span class="sd">          reference the input string using the parse action&#39;s ``s`` argument</span>
<span class="sd">        - explictly expand the tabs in your input string before calling</span>
<span class="sd">          ``parseString``</span>

<span class="sd">        Example::</span>

<span class="sd">            Word(&#39;a&#39;).parseString(&#39;aaaaabaaa&#39;)  # -&gt; [&#39;aaaaa&#39;]</span>
<span class="sd">            Word(&#39;a&#39;).parseString(&#39;aaaaabaaa&#39;, parseAll=True)  # -&gt; Exception: Expected end of text</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">resetCache</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
            <span class="c1"># ~ self.saveAsList = True</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span><span class="p">:</span>
            <span class="n">instring</span> <span class="o">=</span> <span class="n">instring</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parseAll</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                <span class="n">se</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span> <span class="o">+</span> <span class="n">StringEnd</span><span class="p">()</span>
                <span class="n">se</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="s1">&#39;__traceback__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim_traceback</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">exc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="nf">scanString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">maxMatches</span><span class="o">=</span><span class="n">_MAX_INT</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scan the input string for expression matches.  Each match will return the</span>
<span class="sd">        matching tokens, start location, and end location.  May be called with optional</span>
<span class="sd">        ``maxMatches`` argument, to clip scanning after &#39;n&#39; matches are found.  If</span>
<span class="sd">        ``overlap`` is specified, then overlapping matches will be reported.</span>

<span class="sd">        Note that the start and end locations are reported relative to the string</span>
<span class="sd">        being parsed.  See :class:`parseString` for more information on parsing</span>
<span class="sd">        strings with embedded tabs.</span>

<span class="sd">        Example::</span>

<span class="sd">            source = &quot;sldjf123lsdjjkf345sldkjf879lkjsfd987&quot;</span>
<span class="sd">            print(source)</span>
<span class="sd">            for tokens, start, end in Word(alphas).scanString(source):</span>
<span class="sd">                print(&#39; &#39;*start + &#39;^&#39;*(end-start))</span>
<span class="sd">                print(&#39; &#39;*start + tokens[0])</span>

<span class="sd">        prints::</span>

<span class="sd">            sldjf123lsdjjkf345sldkjf879lkjsfd987</span>
<span class="sd">            ^^^^^</span>
<span class="sd">            sldjf</span>
<span class="sd">                    ^^^^^^^</span>
<span class="sd">                    lsdjjkf</span>
<span class="sd">                              ^^^^^^</span>
<span class="sd">                              sldkjf</span>
<span class="sd">                                       ^^^^^^</span>
<span class="sd">                                       lkjsfd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span><span class="p">:</span>
            <span class="n">instring</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">preparseFn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span>
        <span class="n">parseFn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">resetCache</span><span class="p">()</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;=</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">matches</span> <span class="o">&lt;</span> <span class="n">maxMatches</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">preloc</span> <span class="o">=</span> <span class="n">preparseFn</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                    <span class="n">nextLoc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">parseFn</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseException</span><span class="p">:</span>
                    <span class="n">loc</span> <span class="o">=</span> <span class="n">preloc</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nextLoc</span> <span class="o">&gt;</span> <span class="n">loc</span><span class="p">:</span>
                        <span class="n">matches</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">yield</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">nextLoc</span>
                        <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
                            <span class="n">nextloc</span> <span class="o">=</span> <span class="n">preparseFn</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">nextloc</span> <span class="o">&gt;</span> <span class="n">loc</span><span class="p">:</span>
                                <span class="n">loc</span> <span class="o">=</span> <span class="n">nextLoc</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">loc</span> <span class="o">=</span> <span class="n">nextLoc</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">loc</span> <span class="o">=</span> <span class="n">preloc</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="s1">&#39;__traceback__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim_traceback</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">exc</span>

    <span class="k">def</span> <span class="nf">transformString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extension to :class:`scanString`, to modify matching text with modified tokens that may</span>
<span class="sd">        be returned from a parse action.  To use ``transformString``, define a grammar and</span>
<span class="sd">        attach a parse action to it that modifies the returned token list.</span>
<span class="sd">        Invoking ``transformString()`` on a target string will then scan for matches,</span>
<span class="sd">        and replace the matched text patterns according to the logic in the parse</span>
<span class="sd">        action.  ``transformString()`` returns the resulting transformed string.</span>

<span class="sd">        Example::</span>

<span class="sd">            wd = Word(alphas)</span>
<span class="sd">            wd.setParseAction(lambda toks: toks[0].title())</span>

<span class="sd">            print(wd.transformString(&quot;now is the winter of our discontent made glorious summer by this sun of york.&quot;))</span>

<span class="sd">        prints::</span>

<span class="sd">            Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lastE</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># force preservation of &lt;TAB&gt;s, to minimize unwanted transformation of string, and to</span>
        <span class="c1"># keep string locs straight between transformString and scanString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scanString</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">lastE</span><span class="p">:</span><span class="n">s</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
                        <span class="n">out</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">asList</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">out</span> <span class="o">+=</span> <span class="n">t</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">lastE</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">lastE</span><span class="p">:])</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out</span> <span class="k">if</span> <span class="n">o</span><span class="p">]</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_ustr</span><span class="p">,</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">out</span><span class="p">)))</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="s1">&#39;__traceback__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim_traceback</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">exc</span>

    <span class="k">def</span> <span class="nf">searchString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">maxMatches</span><span class="o">=</span><span class="n">_MAX_INT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Another extension to :class:`scanString`, simplifying the access to the tokens found</span>
<span class="sd">        to match the given parse expression.  May be called with optional</span>
<span class="sd">        ``maxMatches`` argument, to clip searching after &#39;n&#39; matches are found.</span>

<span class="sd">        Example::</span>

<span class="sd">            # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters</span>
<span class="sd">            cap_word = Word(alphas.upper(), alphas.lower())</span>

<span class="sd">            print(cap_word.searchString(&quot;More than Iron, more than Lead, more than Gold I need Electricity&quot;))</span>

<span class="sd">            # the sum() builtin can be used to merge results into a single ParseResults object</span>
<span class="sd">            print(sum(cap_word.searchString(&quot;More than Iron, more than Lead, more than Gold I need Electricity&quot;)))</span>

<span class="sd">        prints::</span>

<span class="sd">            [[&#39;More&#39;], [&#39;Iron&#39;], [&#39;Lead&#39;], [&#39;Gold&#39;], [&#39;I&#39;], [&#39;Electricity&#39;]]</span>
<span class="sd">            [&#39;More&#39;, &#39;Iron&#39;, &#39;Lead&#39;, &#39;Gold&#39;, &#39;I&#39;, &#39;Electricity&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ParseResults</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scanString</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">maxMatches</span><span class="p">)])</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="s1">&#39;__traceback__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim_traceback</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">exc</span>

    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="n">_MAX_INT</span><span class="p">,</span> <span class="n">includeSeparators</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator method to split a string using the given expression as a separator.</span>
<span class="sd">        May be called with optional ``maxsplit`` argument, to limit the number of splits;</span>
<span class="sd">        and the optional ``includeSeparators`` argument (default= ``False``), if the separating</span>
<span class="sd">        matching text should be included in the split results.</span>

<span class="sd">        Example::</span>

<span class="sd">            punc = oneOf(list(&quot;.,;:/-!?&quot;))</span>
<span class="sd">            print(list(punc.split(&quot;This, this?, this sentence, is badly punctuated!&quot;)))</span>

<span class="sd">        prints::</span>

<span class="sd">            [&#39;This&#39;, &#39; this&#39;, &#39;&#39;, &#39; this sentence&#39;, &#39; is badly punctuated&#39;, &#39;&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scanString</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">maxMatches</span><span class="o">=</span><span class="n">maxsplit</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">instring</span><span class="p">[</span><span class="n">last</span><span class="p">:</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">includeSeparators</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">e</span>
        <span class="k">yield</span> <span class="n">instring</span><span class="p">[</span><span class="n">last</span><span class="p">:]</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of + operator - returns :class:`And`. Adding strings to a ParserElement</span>
<span class="sd">        converts them to :class:`Literal`s by default.</span>

<span class="sd">        Example::</span>

<span class="sd">            greet = Word(alphas) + &quot;,&quot; + Word(alphas) + &quot;!&quot;</span>
<span class="sd">            hello = &quot;Hello, World!&quot;</span>
<span class="sd">            print (hello, &quot;-&gt;&quot;, greet.parseString(hello))</span>

<span class="sd">        prints::</span>

<span class="sd">            Hello, World! -&gt; [&#39;Hello&#39;, &#39;,&#39;, &#39;World&#39;, &#39;!&#39;]</span>

<span class="sd">        ``...`` may be used as a parse expression as a short form of :class:`SkipTo`.</span>

<span class="sd">            Literal(&#39;start&#39;) + ... + Literal(&#39;end&#39;)</span>

<span class="sd">        is equivalent to:</span>

<span class="sd">            Literal(&#39;start&#39;) + SkipTo(&#39;end&#39;)(&quot;_skipped*&quot;) + Literal(&#39;end&#39;)</span>

<span class="sd">        Note that the skipped text is returned with &#39;_skipped&#39; as a results name,</span>
<span class="sd">        and to support having multiple skips in the same parser, the value returned is</span>
<span class="sd">        a list of all skipped text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_PendingSkip</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">And</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of + operator when left operand is not a :class:`ParserElement`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SkipTo</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="s2">&quot;_skipped*&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">+</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of - operator, returns :class:`And` with error stop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">And</span><span class="o">.</span><span class="n">_ErrorStop</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of - operator when left operand is not a :class:`ParserElement`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">-</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of * operator, allows use of ``expr * 3`` in place of</span>
<span class="sd">        ``expr + expr + expr``.  Expressions may also me multiplied by a 2-integer</span>
<span class="sd">        tuple, similar to ``{min, max}`` multipliers in regular expressions.  Tuples</span>
<span class="sd">        may also include ``None`` as in:</span>
<span class="sd">         - ``expr*(n, None)`` or ``expr*(n, )`` is equivalent</span>
<span class="sd">              to ``expr*n + ZeroOrMore(expr)``</span>
<span class="sd">              (read as &quot;at least n instances of ``expr``&quot;)</span>
<span class="sd">         - ``expr*(None, n)`` is equivalent to ``expr*(0, n)``</span>
<span class="sd">              (read as &quot;0 to n instances of ``expr``&quot;)</span>
<span class="sd">         - ``expr*(None, None)`` is equivalent to ``ZeroOrMore(expr)``</span>
<span class="sd">         - ``expr*(1, None)`` is equivalent to ``OneOrMore(expr)``</span>

<span class="sd">        Note that ``expr*(None, n)`` does not raise an exception if</span>
<span class="sd">        more than n exprs exist in the input stream; that is,</span>
<span class="sd">        ``expr*(None, n)`` does not enforce a maximum number of expr</span>
<span class="sd">        occurrences.  If this behavior is desired, then write</span>
<span class="sd">        ``expr*(None, n) + ~expr``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,))[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">minElements</span><span class="p">,</span> <span class="n">optElements</span> <span class="o">=</span> <span class="n">other</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">o</span> <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">Ellipsis</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">other</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">minElements</span><span class="p">,</span> <span class="n">optElements</span> <span class="o">=</span> <span class="n">other</span>
                <span class="n">optElements</span> <span class="o">-=</span> <span class="n">minElements</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot multiply &#39;ParserElement&#39; and (&#39;</span><span class="si">%s</span><span class="s2">&#39;, &#39;</span><span class="si">%s</span><span class="s2">&#39;) objects&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot multiply &#39;ParserElement&#39; and &#39;</span><span class="si">%s</span><span class="s2">&#39; objects&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">minElements</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot multiply ParserElement by negative value&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optElements</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;second tuple value must be greater or equal to first tuple value&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minElements</span> <span class="o">==</span> <span class="n">optElements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot multiply ParserElement by 0 or (0, 0)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">optElements</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">makeOptionalList</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Optional</span><span class="p">(</span><span class="bp">self</span> <span class="o">+</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Optional</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">minElements</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">minElements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">optElements</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">And</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">*</span> <span class="n">minElements</span><span class="p">)</span> <span class="o">+</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">optElements</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">optElements</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">minElements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">And</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">*</span> <span class="n">minElements</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of | operator - returns :class:`MatchFirst`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_PendingSkip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">must_skip</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">MatchFirst</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of | operator when left operand is not a :class:`ParserElement`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">|</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ^ operator - returns :class:`Or`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Or</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ^ operator when left operand is not a :class:`ParserElement`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">^</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of &amp; operator - returns :class:`Each`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Each</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of &amp; operator when left operand is not a :class:`ParserElement`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">&amp;</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ~ operator - returns :class:`NotAny`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">NotAny</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># must implement __iter__ to override legacy use of sequential access to __getitem__ to</span>
        <span class="c1"># iterate over a sequence</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1"> object is not iterable&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        use ``[]`` indexing notation as a short form for expression repetition:</span>
<span class="sd">         - ``expr[n]`` is equivalent to ``expr*n``</span>
<span class="sd">         - ``expr[m, n]`` is equivalent to ``expr*(m, n)``</span>
<span class="sd">         - ``expr[n, ...]`` or ``expr[n,]`` is equivalent</span>
<span class="sd">              to ``expr*n + ZeroOrMore(expr)``</span>
<span class="sd">              (read as &quot;at least n instances of ``expr``&quot;)</span>
<span class="sd">         - ``expr[..., n]`` is equivalent to ``expr*(0, n)``</span>
<span class="sd">              (read as &quot;0 to n instances of ``expr``&quot;)</span>
<span class="sd">         - ``expr[...]`` and ``expr[0, ...]`` are equivalent to ``ZeroOrMore(expr)``</span>
<span class="sd">         - ``expr[1, ...]`` is equivalent to ``OneOrMore(expr)``</span>
<span class="sd">         ``None`` may be used in place of ``...``.</span>

<span class="sd">        Note that ``expr[..., n]`` and ``expr[m, n]``do not raise an exception</span>
<span class="sd">        if more than ``n`` ``expr``s exist in the input stream.  If this behavior is</span>
<span class="sd">        desired, then write ``expr[..., n] + ~expr``.</span>
<span class="sd">       &quot;&quot;&quot;</span>

        <span class="c1"># convert single arg keys to tuples</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;only 1 or 2 index arguments supported (</span><span class="si">{0}{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span>
                                                                                <span class="s1">&#39;... [</span><span class="si">{0}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
                                                                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>

        <span class="c1"># clip to 2 elements</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">*</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shortcut for :class:`setResultsName`, with ``listAllMatches=False``.</span>

<span class="sd">        If ``name`` is given with a trailing ``&#39;*&#39;`` character, then ``listAllMatches`` will be</span>
<span class="sd">        passed as ``True``.</span>

<span class="sd">        If ``name` is omitted, same as calling :class:`copy`.</span>

<span class="sd">        Example::</span>

<span class="sd">            # these are equivalent</span>
<span class="sd">            userdata = Word(alphas).setResultsName(&quot;name&quot;) + Word(nums + &quot;-&quot;).setResultsName(&quot;socsecno&quot;)</span>
<span class="sd">            userdata = Word(alphas)(&quot;name&quot;) + Word(nums + &quot;-&quot;)(&quot;socsecno&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">suppress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Suppresses the output of this :class:`ParserElement`; useful to keep punctuation from</span>
<span class="sd">        cluttering up returned output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Suppress</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">leaveWhitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disables the skipping of whitespace before matching the characters in the</span>
<span class="sd">        :class:`ParserElement`&#39;s defined pattern.  This is normally only used internally by</span>
<span class="sd">        the pyparsing module, but may be needed in some whitespace-sensitive grammars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">setWhitespaceChars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides the default whitespace chars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span> <span class="o">=</span> <span class="n">chars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parseWithTabs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides default behavior to expand ``&lt;TAB&gt;``s to spaces before parsing the input string.</span>
<span class="sd">        Must be called before ``parseString`` when the input grammar contains elements that</span>
<span class="sd">        match ``&lt;TAB&gt;`` characters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define expression to be ignored (e.g., comments) while doing pattern</span>
<span class="sd">        matching; may be called repeatedly, to define multiple comment or other</span>
<span class="sd">        ignorable patterns.</span>

<span class="sd">        Example::</span>

<span class="sd">            patt = OneOrMore(Word(alphas))</span>
<span class="sd">            patt.parseString(&#39;ablaj /* comment */ lskjd&#39;) # -&gt; [&#39;ablaj&#39;]</span>

<span class="sd">            patt.ignore(cStyleComment)</span>
<span class="sd">            patt.parseString(&#39;ablaj /* comment */ lskjd&#39;) # -&gt; [&#39;ablaj&#39;, &#39;lskjd&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Suppress</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Suppress</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">setDebugActions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startAction</span><span class="p">,</span> <span class="n">successAction</span><span class="p">,</span> <span class="n">exceptionAction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable display of debugging messages while doing pattern matching.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span> <span class="o">=</span> <span class="p">(</span><span class="n">startAction</span> <span class="ow">or</span> <span class="n">_defaultStartDebugAction</span><span class="p">,</span>
                             <span class="n">successAction</span> <span class="ow">or</span> <span class="n">_defaultSuccessDebugAction</span><span class="p">,</span>
                             <span class="n">exceptionAction</span> <span class="ow">or</span> <span class="n">_defaultExceptionDebugAction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">setDebug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable display of debugging messages while doing pattern matching.</span>
<span class="sd">        Set ``flag`` to True to enable, False to disable.</span>

<span class="sd">        Example::</span>

<span class="sd">            wd = Word(alphas).setName(&quot;alphaword&quot;)</span>
<span class="sd">            integer = Word(nums).setName(&quot;numword&quot;)</span>
<span class="sd">            term = wd | integer</span>

<span class="sd">            # turn on debugging for wd</span>
<span class="sd">            wd.setDebug()</span>

<span class="sd">            OneOrMore(term).parseString(&quot;abc 123 xyz 890&quot;)</span>

<span class="sd">        prints::</span>

<span class="sd">            Match alphaword at loc 0(1,1)</span>
<span class="sd">            Matched alphaword -&gt; [&#39;abc&#39;]</span>
<span class="sd">            Match alphaword at loc 3(1,4)</span>
<span class="sd">            Exception raised:Expected alphaword (at char 4), (line:1, col:5)</span>
<span class="sd">            Match alphaword at loc 7(1,8)</span>
<span class="sd">            Matched alphaword -&gt; [&#39;xyz&#39;]</span>
<span class="sd">            Match alphaword at loc 11(1,12)</span>
<span class="sd">            Exception raised:Expected alphaword (at char 12), (line:1, col:13)</span>
<span class="sd">            Match alphaword at loc 15(1,16)</span>
<span class="sd">            Exception raised:Expected alphaword (at char 15), (line:1, col:16)</span>

<span class="sd">        The output shown is that produced by the default debug actions - custom debug actions can be</span>
<span class="sd">        specified using :class:`setDebugActions`. Prior to attempting</span>
<span class="sd">        to match the ``wd`` expression, the debugging message ``&quot;Match &lt;exprname&gt; at loc &lt;n&gt;(&lt;line&gt;,&lt;col&gt;)&quot;``</span>
<span class="sd">        is shown. Then if the parse succeeds, a ``&quot;Matched&quot;`` message is shown, or an ``&quot;Exception raised&quot;``</span>
<span class="sd">        message is shown. Also note the use of :class:`setName` to assign a human-readable name to the expression,</span>
<span class="sd">        which makes debugging and exception messages easier to understand - for instance, the default</span>
<span class="sd">        name created for the :class:`Word` expression without calling ``setName`` is ``&quot;W:(ABCD...)&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setDebugActions</span><span class="p">(</span><span class="n">_defaultStartDebugAction</span><span class="p">,</span> <span class="n">_defaultSuccessDebugAction</span><span class="p">,</span> <span class="n">_defaultExceptionDebugAction</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check defined expressions for valid structure, check for infinite recursive definitions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">parseFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_or_filename</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the parse expression on the given file or filename.</span>
<span class="sd">        If a filename is specified (instead of a file object),</span>
<span class="sd">        the entire file is opened, read, and closed before parsing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">file_contents</span> <span class="o">=</span> <span class="n">file_or_filename</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_or_filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">file_contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">file_contents</span><span class="p">,</span> <span class="n">parseAll</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="s1">&#39;__traceback__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim_traceback</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">exc</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">vars</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__req__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__rne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testString</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for quick testing of a parser against a test string. Good for simple</span>
<span class="sd">        inline microtests of sub expressions while building up larger parser.</span>

<span class="sd">        Parameters:</span>
<span class="sd">         - testString - to test against this expression for a match</span>
<span class="sd">         - parseAll - (default= ``True``) - flag to pass to :class:`parseString` when running tests</span>

<span class="sd">        Example::</span>

<span class="sd">            expr = Word(nums)</span>
<span class="sd">            assert expr.matches(&quot;100&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">testString</span><span class="p">),</span> <span class="n">parseAll</span><span class="o">=</span><span class="n">parseAll</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">runTests</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tests</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span>
                 <span class="n">fullDump</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">printResults</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">failureTests</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">postParse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the parse expression on a series of test strings, showing each</span>
<span class="sd">        test, the parsed results or where the parse failed. Quick and easy way to</span>
<span class="sd">        run a parse expression against a list of sample strings.</span>

<span class="sd">        Parameters:</span>
<span class="sd">         - tests - a list of separate test strings, or a multiline string of test strings</span>
<span class="sd">         - parseAll - (default= ``True``) - flag to pass to :class:`parseString` when running tests</span>
<span class="sd">         - comment - (default= ``&#39;#&#39;``) - expression for indicating embedded comments in the test</span>
<span class="sd">              string; pass None to disable comment filtering</span>
<span class="sd">         - fullDump - (default= ``True``) - dump results as list followed by results names in nested outline;</span>
<span class="sd">              if False, only dump nested list</span>
<span class="sd">         - printResults - (default= ``True``) prints test output to stdout</span>
<span class="sd">         - failureTests - (default= ``False``) indicates if these tests are expected to fail parsing</span>
<span class="sd">         - postParse - (default= ``None``) optional callback for successful parse results; called as</span>
<span class="sd">              `fn(test_string, parse_results)` and returns a string to be added to the test output</span>
<span class="sd">         - file - (default=``None``) optional file-like object to which test output will be written;</span>
<span class="sd">              if None, will default to ``sys.stdout``</span>

<span class="sd">        Returns: a (success, results) tuple, where success indicates that all tests succeeded</span>
<span class="sd">        (or failed if ``failureTests`` is True), and the results contain a list of lines of each</span>
<span class="sd">        test&#39;s output</span>

<span class="sd">        Example::</span>

<span class="sd">            number_expr = pyparsing_common.number.copy()</span>

<span class="sd">            result = number_expr.runTests(&#39;&#39;&#39;</span>
<span class="sd">                # unsigned integer</span>
<span class="sd">                100</span>
<span class="sd">                # negative integer</span>
<span class="sd">                -100</span>
<span class="sd">                # float with scientific notation</span>
<span class="sd">                6.02e23</span>
<span class="sd">                # integer with scientific notation</span>
<span class="sd">                1e-12</span>
<span class="sd">                &#39;&#39;&#39;)</span>
<span class="sd">            print(&quot;Success&quot; if result[0] else &quot;Failed!&quot;)</span>

<span class="sd">            result = number_expr.runTests(&#39;&#39;&#39;</span>
<span class="sd">                # stray character</span>
<span class="sd">                100Z</span>
<span class="sd">                # missing leading digit before &#39;.&#39;</span>
<span class="sd">                -.100</span>
<span class="sd">                # too many &#39;.&#39;</span>
<span class="sd">                3.14.159</span>
<span class="sd">                &#39;&#39;&#39;, failureTests=True)</span>
<span class="sd">            print(&quot;Success&quot; if result[0] else &quot;Failed!&quot;)</span>

<span class="sd">        prints::</span>

<span class="sd">            # unsigned integer</span>
<span class="sd">            100</span>
<span class="sd">            [100]</span>

<span class="sd">            # negative integer</span>
<span class="sd">            -100</span>
<span class="sd">            [-100]</span>

<span class="sd">            # float with scientific notation</span>
<span class="sd">            6.02e23</span>
<span class="sd">            [6.02e+23]</span>

<span class="sd">            # integer with scientific notation</span>
<span class="sd">            1e-12</span>
<span class="sd">            [1e-12]</span>

<span class="sd">            Success</span>

<span class="sd">            # stray character</span>
<span class="sd">            100Z</span>
<span class="sd">               ^</span>
<span class="sd">            FAIL: Expected end of text (at char 3), (line:1, col:4)</span>

<span class="sd">            # missing leading digit before &#39;.&#39;</span>
<span class="sd">            -.100</span>
<span class="sd">            ^</span>
<span class="sd">            FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)</span>

<span class="sd">            # too many &#39;.&#39;</span>
<span class="sd">            3.14.159</span>
<span class="sd">                ^</span>
<span class="sd">            FAIL: Expected end of text (at char 4), (line:1, col:5)</span>

<span class="sd">            Success</span>

<span class="sd">        Each test string must be on a single line. If you want to test a string that spans multiple</span>
<span class="sd">        lines, create a test like this::</span>

<span class="sd">            expr.runTest(r&quot;this is a test\\n of strings that spans \\n 3 lines&quot;)</span>

<span class="sd">        (Note that this is a raw string literal, you must include the leading &#39;r&#39;.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tests</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">tests</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">strip</span><span class="p">,</span> <span class="n">tests</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comment</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
        <span class="n">print_</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">write</span>

        <span class="n">allResults</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">NL</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">replaceWith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">quotedString</span><span class="p">)</span>
        <span class="n">BOM</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\ufeff</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">comment</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">comments</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">comments</span><span class="p">)</span> <span class="k">if</span> <span class="n">comments</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
            <span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># convert newline marks to actual newlines, and strip leading BOM if present</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">NL</span><span class="o">.</span><span class="n">transformString</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="n">BOM</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="n">parseAll</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">pe</span><span class="p">:</span>
                <span class="n">fatal</span> <span class="o">=</span> <span class="s2">&quot;(FATAL)&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="n">ParseFatalException</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">(</span><span class="n">pe</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="n">pe</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="n">fatal</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">pe</span><span class="o">.</span><span class="n">loc</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="n">fatal</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FAIL: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">pe</span><span class="p">))</span>
                <span class="n">success</span> <span class="o">=</span> <span class="n">success</span> <span class="ow">and</span> <span class="n">failureTests</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">pe</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FAIL-EXCEPTION: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
                <span class="n">success</span> <span class="o">=</span> <span class="n">success</span> <span class="ow">and</span> <span class="n">failureTests</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">exc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">success</span> <span class="o">=</span> <span class="n">success</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">failureTests</span>
                <span class="k">if</span> <span class="n">postParse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">pp_value</span> <span class="o">=</span> <span class="n">postParse</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">pp_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pp_value</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
                                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp_value</span><span class="o">.</span><span class="n">dump</span><span class="p">())</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">pp_value</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dump</span><span class="p">())</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">full</span><span class="o">=</span><span class="n">fullDump</span><span class="p">))</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> failed: </span><span class="si">{1}</span><span class="s2">: </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">postParse</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">full</span><span class="o">=</span><span class="n">fullDump</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">printResults</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fullDump</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">print_</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>

            <span class="n">allResults</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">allResults</span>


<span class="k">class</span> <span class="nc">_PendingSkip</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">):</span>
    <span class="c1"># internal placeholder class to hold a place were &#39;...&#39; is added to a parser element,</span>
    <span class="c1"># once another ParserElement is added, this placeholder will be replaced with a SkipTo</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">must_skip</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_PendingSkip</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span> <span class="o">+</span> <span class="n">Empty</span><span class="p">())</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;Empty&#39;</span><span class="p">,</span> <span class="s1">&#39;...&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anchor</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">must_skip</span> <span class="o">=</span> <span class="n">must_skip</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">skipper</span> <span class="o">=</span> <span class="n">SkipTo</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)(</span><span class="s2">&quot;_skipped*&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">must_skip</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">must_skip</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">_skipped</span> <span class="ow">or</span> <span class="n">t</span><span class="o">.</span><span class="n">_skipped</span><span class="o">.</span><span class="n">asList</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_skipped&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">show_skip</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">_skipped</span><span class="o">.</span><span class="n">asList</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]:</span>
                    <span class="n">skipped</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_skipped&#39;</span><span class="p">)</span>
                    <span class="n">t</span><span class="p">[</span><span class="s1">&#39;_skipped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;missing &lt;&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor</span> <span class="o">+</span> <span class="n">skipper</span><span class="p">()</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">must_skip</span><span class="p">)</span>
                    <span class="o">|</span> <span class="n">skipper</span><span class="p">()</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">show_skip</span><span class="p">))</span> <span class="o">+</span> <span class="n">other</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">anchor</span> <span class="o">+</span> <span class="n">skipper</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;use of `...` expression without following SkipTo target expression&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Token</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract :class:`ParserElement` subclass, for defining atomic</span>
<span class="sd">    matching patterns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Token</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Empty</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An empty token, will always match.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Empty</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Empty&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">NoMatch</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A token that will never match.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NoMatch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;NoMatch&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Unmatchable token&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Literal</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token to exactly match a specified string.</span>

<span class="sd">    Example::</span>

<span class="sd">        Literal(&#39;blah&#39;).parseString(&#39;blah&#39;)  # -&gt; [&#39;blah&#39;]</span>
<span class="sd">        Literal(&#39;blah&#39;).parseString(&#39;blahfooblah&#39;)  # -&gt; [&#39;blah&#39;]</span>
<span class="sd">        Literal(&#39;blah&#39;).parseString(&#39;bla&#39;)  # -&gt; Exception: Expected &quot;blah&quot;</span>

<span class="sd">    For case-insensitive matching, use :class:`CaselessLiteral`.</span>

<span class="sd">    For keyword matching (force word break before and after the matched string),</span>
<span class="sd">    use :class:`Keyword` or :class:`CaselessKeyword`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matchString</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">matchString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchString</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span> <span class="o">=</span> <span class="n">matchString</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;null string passed to Literal; use Empty() instead&quot;</span><span class="p">,</span>
                            <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">Empty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Performance tuning: modify __class__ to select</span>
        <span class="c1"># a parseImpl optimized for single-character check</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Literal</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">_SingleCharLiteral</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span> <span class="ow">and</span> <span class="n">instring</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_SingleCharLiteral</span><span class="p">(</span><span class="n">Literal</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<span class="n">_L</span> <span class="o">=</span> <span class="n">Literal</span>
<span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span> <span class="o">=</span> <span class="n">Literal</span>

<span class="k">class</span> <span class="nc">Keyword</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token to exactly match a specified string as a keyword, that is,</span>
<span class="sd">    it must be immediately followed by a non-keyword character.  Compare</span>
<span class="sd">    with :class:`Literal`:</span>

<span class="sd">     - ``Literal(&quot;if&quot;)`` will match the leading ``&#39;if&#39;`` in</span>
<span class="sd">       ``&#39;ifAndOnlyIf&#39;``.</span>
<span class="sd">     - ``Keyword(&quot;if&quot;)`` will not; it will only match the leading</span>
<span class="sd">       ``&#39;if&#39;`` in ``&#39;if x=1&#39;``, or ``&#39;if(y==2)&#39;``</span>

<span class="sd">    Accepts two optional constructor arguments in addition to the</span>
<span class="sd">    keyword string:</span>

<span class="sd">     - ``identChars`` is a string of characters that would be valid</span>
<span class="sd">       identifier characters, defaulting to all alphanumerics + &quot;_&quot; and</span>
<span class="sd">       &quot;$&quot;</span>
<span class="sd">     - ``caseless`` allows case-insensitive matching, default is ``False``.</span>

<span class="sd">    Example::</span>

<span class="sd">        Keyword(&quot;start&quot;).parseString(&quot;start&quot;)  # -&gt; [&#39;start&#39;]</span>
<span class="sd">        Keyword(&quot;start&quot;).parseString(&quot;starting&quot;)  # -&gt; Exception</span>

<span class="sd">    For case-insensitive matching, use :class:`CaselessKeyword`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DEFAULT_KEYWORD_CHARS</span> <span class="o">=</span> <span class="n">alphanums</span> <span class="o">+</span> <span class="s2">&quot;_$&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matchString</span><span class="p">,</span> <span class="n">identChars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">caseless</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Keyword</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">identChars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">identChars</span> <span class="o">=</span> <span class="n">Keyword</span><span class="o">.</span><span class="n">DEFAULT_KEYWORD_CHARS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">matchString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchString</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span> <span class="o">=</span> <span class="n">matchString</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;null string passed to Keyword; use Empty() instead&quot;</span><span class="p">,</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">caseless</span> <span class="o">=</span> <span class="n">caseless</span>
        <span class="k">if</span> <span class="n">caseless</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">caselessmatch</span> <span class="o">=</span> <span class="n">matchString</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">identChars</span> <span class="o">=</span> <span class="n">identChars</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">identChars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">caseless</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">:</span><span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">caselessmatch</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">loc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span>
                         <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="mi">0</span>
                         <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">instring</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="n">loc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span>
                             <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>

        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Keyword</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">identChars</span> <span class="o">=</span> <span class="n">Keyword</span><span class="o">.</span><span class="n">DEFAULT_KEYWORD_CHARS</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">setDefaultKeywordChars</span><span class="p">(</span><span class="n">chars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overrides the default Keyword chars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Keyword</span><span class="o">.</span><span class="n">DEFAULT_KEYWORD_CHARS</span> <span class="o">=</span> <span class="n">chars</span>

<span class="k">class</span> <span class="nc">CaselessLiteral</span><span class="p">(</span><span class="n">Literal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token to match a specified string, ignoring case of letters.</span>
<span class="sd">    Note: the matched results will always be in the case of the given</span>
<span class="sd">    match string, NOT the case of the input text.</span>

<span class="sd">    Example::</span>

<span class="sd">        OneOrMore(CaselessLiteral(&quot;CMD&quot;)).parseString(&quot;cmd CMD Cmd10&quot;) # -&gt; [&#39;CMD&#39;, &#39;CMD&#39;, &#39;CMD&#39;]</span>

<span class="sd">    (Contrast with example for :class:`CaselessKeyword`.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matchString</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CaselessLiteral</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">matchString</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="c1"># Preserve the defining literal.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">returnString</span> <span class="o">=</span> <span class="n">matchString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">returnString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">:</span><span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">returnString</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">CaselessKeyword</span><span class="p">(</span><span class="n">Keyword</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Caseless version of :class:`Keyword`.</span>

<span class="sd">    Example::</span>

<span class="sd">        OneOrMore(CaselessKeyword(&quot;CMD&quot;)).parseString(&quot;cmd CMD Cmd10&quot;) # -&gt; [&#39;CMD&#39;, &#39;CMD&#39;]</span>

<span class="sd">    (Contrast with example for :class:`CaselessLiteral`.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matchString</span><span class="p">,</span> <span class="n">identChars</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CaselessKeyword</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">matchString</span><span class="p">,</span> <span class="n">identChars</span><span class="p">,</span> <span class="n">caseless</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">CloseMatch</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A variation on :class:`Literal` which matches &quot;close&quot; matches,</span>
<span class="sd">    that is, strings with at most &#39;n&#39; mismatching characters.</span>
<span class="sd">    :class:`CloseMatch` takes parameters:</span>

<span class="sd">     - ``match_string`` - string to be matched</span>
<span class="sd">     - ``maxMismatches`` - (``default=1``) maximum number of</span>
<span class="sd">       mismatches allowed to count as a match</span>

<span class="sd">    The results from a successful parse will contain the matched text</span>
<span class="sd">    from the input string and the following named results:</span>

<span class="sd">     - ``mismatches`` - a list of the positions within the</span>
<span class="sd">       match_string where mismatches were found</span>
<span class="sd">     - ``original`` - the original match_string used to compare</span>
<span class="sd">       against the input string</span>

<span class="sd">    If ``mismatches`` is an empty list, then the match was an exact</span>
<span class="sd">    match.</span>

<span class="sd">    Example::</span>

<span class="sd">        patt = CloseMatch(&quot;ATCATCGAATGGA&quot;)</span>
<span class="sd">        patt.parseString(&quot;ATCATCGAAXGGA&quot;) # -&gt; ([&#39;ATCATCGAAXGGA&#39;], {&#39;mismatches&#39;: [[9]], &#39;original&#39;: [&#39;ATCATCGAATGGA&#39;]})</span>
<span class="sd">        patt.parseString(&quot;ATCAXCGAAXGGA&quot;) # -&gt; Exception: Expected &#39;ATCATCGAATGGA&#39; (with up to 1 mismatches) (at char 0), (line:1, col:1)</span>

<span class="sd">        # exact match</span>
<span class="sd">        patt.parseString(&quot;ATCATCGAATGGA&quot;) # -&gt; ([&#39;ATCATCGAATGGA&#39;], {&#39;mismatches&#39;: [[]], &#39;original&#39;: [&#39;ATCATCGAATGGA&#39;]})</span>

<span class="sd">        # close match allowing up to 2 mismatches</span>
<span class="sd">        patt = CloseMatch(&quot;ATCATCGAATGGA&quot;, maxMismatches=2)</span>
<span class="sd">        patt.parseString(&quot;ATCAXCGAAXGGA&quot;) # -&gt; ([&#39;ATCAXCGAAXGGA&#39;], {&#39;mismatches&#39;: [[4, 9]], &#39;original&#39;: [&#39;ATCATCGAATGGA&#39;]})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match_string</span><span class="p">,</span> <span class="n">maxMismatches</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CloseMatch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">match_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_string</span> <span class="o">=</span> <span class="n">match_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxMismatches</span> <span class="o">=</span> <span class="n">maxMismatches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected </span><span class="si">%r</span><span class="s2"> (with up to </span><span class="si">%d</span><span class="s2"> mismatches)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match_string</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxMismatches</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match_string</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maxloc</span> <span class="o">&lt;=</span> <span class="n">instrlen</span><span class="p">:</span>
            <span class="n">match_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_string</span>
            <span class="n">match_stringloc</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">mismatches</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">maxMismatches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxMismatches</span>

            <span class="k">for</span> <span class="n">match_stringloc</span><span class="p">,</span> <span class="n">s_m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">:</span><span class="n">maxloc</span><span class="p">],</span> <span class="n">match_string</span><span class="p">)):</span>
                <span class="n">src</span><span class="p">,</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">s_m</span>
                <span class="k">if</span> <span class="n">src</span> <span class="o">!=</span> <span class="n">mat</span><span class="p">:</span>
                    <span class="n">mismatches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match_stringloc</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mismatches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxMismatches</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">match_stringloc</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">([</span><span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">loc</span><span class="p">]])</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;original&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_string</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;mismatches&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mismatches</span>
                <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">results</span>

        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Word</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token for matching words composed of allowed character sets.</span>
<span class="sd">    Defined with string containing all allowed initial characters, an</span>
<span class="sd">    optional string containing allowed body characters (if omitted,</span>
<span class="sd">    defaults to the initial character set), and an optional minimum,</span>
<span class="sd">    maximum, and/or exact length.  The default value for ``min`` is</span>
<span class="sd">    1 (a minimum value &lt; 1 is not valid); the default values for</span>
<span class="sd">    ``max`` and ``exact`` are 0, meaning no maximum or exact</span>
<span class="sd">    length restriction. An optional ``excludeChars`` parameter can</span>
<span class="sd">    list characters that might be found in the input ``bodyChars``</span>
<span class="sd">    string; useful to define a word of all printables except for one or</span>
<span class="sd">    two characters, for instance.</span>

<span class="sd">    :class:`srange` is useful for defining custom character set strings</span>
<span class="sd">    for defining ``Word`` expressions, using range notation from</span>
<span class="sd">    regular expression character sets.</span>

<span class="sd">    A common mistake is to use :class:`Word` to match a specific literal</span>
<span class="sd">    string, as in ``Word(&quot;Address&quot;)``. Remember that :class:`Word`</span>
<span class="sd">    uses the string argument to define *sets* of matchable characters.</span>
<span class="sd">    This expression would match &quot;Add&quot;, &quot;AAA&quot;, &quot;dAred&quot;, or any other word</span>
<span class="sd">    made up of the characters &#39;A&#39;, &#39;d&#39;, &#39;r&#39;, &#39;e&#39;, and &#39;s&#39;. To match an</span>
<span class="sd">    exact literal string, use :class:`Literal` or :class:`Keyword`.</span>

<span class="sd">    pyparsing includes helper strings for building Words:</span>

<span class="sd">     - :class:`alphas`</span>
<span class="sd">     - :class:`nums`</span>
<span class="sd">     - :class:`alphanums`</span>
<span class="sd">     - :class:`hexnums`</span>
<span class="sd">     - :class:`alphas8bit` (alphabetic characters in ASCII range 128-255</span>
<span class="sd">       - accented, tilded, umlauted, etc.)</span>
<span class="sd">     - :class:`punc8bit` (non-alphabetic characters in ASCII range</span>
<span class="sd">       128-255 - currency, symbols, superscripts, diacriticals, etc.)</span>
<span class="sd">     - :class:`printables` (any non-whitespace character)</span>

<span class="sd">    Example::</span>

<span class="sd">        # a word composed of digits</span>
<span class="sd">        integer = Word(nums) # equivalent to Word(&quot;0123456789&quot;) or Word(srange(&quot;0-9&quot;))</span>

<span class="sd">        # a word with a leading capital, and zero or more lowercase</span>
<span class="sd">        capital_word = Word(alphas.upper(), alphas.lower())</span>

<span class="sd">        # hostnames are alphanumeric, with leading alpha, and &#39;-&#39;</span>
<span class="sd">        hostname = Word(alphas, alphanums + &#39;-&#39;)</span>

<span class="sd">        # roman numeral (not a strict parser, accepts invalid mix of characters)</span>
<span class="sd">        roman = Word(&quot;IVXLCDM&quot;)</span>

<span class="sd">        # any string of non-whitespace characters, except for &#39;,&#39;</span>
<span class="sd">        csv_value = Word(printables, excludeChars=&quot;,&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initChars</span><span class="p">,</span> <span class="n">bodyChars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">asKeyword</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">excludeChars</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Word</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">excludeChars</span><span class="p">:</span>
            <span class="n">excludeChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">excludeChars</span><span class="p">)</span>
            <span class="n">initChars</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">initChars</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excludeChars</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bodyChars</span><span class="p">:</span>
                <span class="n">bodyChars</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bodyChars</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excludeChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span> <span class="o">=</span> <span class="n">initChars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">initChars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bodyChars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span> <span class="o">=</span> <span class="n">bodyChars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bodyChars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span> <span class="o">=</span> <span class="n">initChars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">initChars</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maxSpecified</span> <span class="o">=</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">min</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot specify a minimum length &lt; 1; use Optional(Word()) if zero-length word is permitted&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="nb">min</span>

        <span class="k">if</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">_MAX_INT</span>

        <span class="k">if</span> <span class="n">exact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">exact</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="n">exact</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asKeyword</span> <span class="o">=</span> <span class="n">asKeyword</span>

        <span class="k">if</span> <span class="s1">&#39; &#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">min</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">max</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">exact</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]+&quot;</span> <span class="o">%</span> <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[</span><span class="si">%s</span><span class="s2">]*&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">),</span>
                                             <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span><span class="p">),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">][</span><span class="si">%s</span><span class="s2">]*&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">),</span>
                                               <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span><span class="p">),)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asKeyword</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\b&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\b&quot;</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reString</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">match</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">_WordRegex</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initChars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="n">bodychars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">maxloc</span><span class="p">,</span> <span class="n">instrlen</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">maxloc</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">throwException</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">:</span>
            <span class="n">throwException</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxSpecified</span> <span class="ow">and</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span><span class="p">:</span>
            <span class="n">throwException</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">asKeyword</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span>
                    <span class="ow">or</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span><span class="p">):</span>
                <span class="n">throwException</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">throwException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Word</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">charsAsStr</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">s</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;...&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">s</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;W:(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">charsAsStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">),</span> <span class="n">charsAsStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;W:(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">charsAsStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

<span class="k">class</span> <span class="nc">_WordRegex</span><span class="p">(</span><span class="n">Word</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Char</span><span class="p">(</span><span class="n">_WordRegex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A short-cut class for defining ``Word(characters, exact=1)``,</span>
<span class="sd">    when defining a match of any single character in a string of</span>
<span class="sd">    characters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">charset</span><span class="p">,</span> <span class="n">asKeyword</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">excludeChars</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Char</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">charset</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">asKeyword</span><span class="o">=</span><span class="n">asKeyword</span><span class="p">,</span> <span class="n">excludeChars</span><span class="o">=</span><span class="n">excludeChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initChars</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">asKeyword</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\b</span><span class="si">%s</span><span class="s2">\b&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">reString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reString</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">match</span>


<span class="k">class</span> <span class="nc">Regex</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Token for matching strings that match a given regular</span>
<span class="sd">    expression. Defined with string specifying the regular expression in</span>
<span class="sd">    a form recognized by the stdlib Python  `re module &lt;https://docs.python.org/3/library/re.html&gt;`_.</span>
<span class="sd">    If the given regex contains named groups (defined using ``(?P&lt;name&gt;...)``),</span>
<span class="sd">    these will be preserved as named parse results.</span>

<span class="sd">    If instead of the Python stdlib re module you wish to use a different RE module</span>
<span class="sd">    (such as the `regex` module), you can replace it by either building your</span>
<span class="sd">    Regex object with a compiled RE that was compiled using regex:</span>

<span class="sd">    Example::</span>

<span class="sd">        realnum = Regex(r&quot;[+-]?\d+\.\d*&quot;)</span>
<span class="sd">        date = Regex(r&#39;(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d\d?)-(?P&lt;day&gt;\d\d?)&#39;)</span>
<span class="sd">        # ref: https://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression</span>
<span class="sd">        roman = Regex(r&quot;M{0,4}(CM|CD|D?{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})&quot;)</span>

<span class="sd">        # use regex module instead of stdlib re module to construct a Regex using</span>
<span class="sd">        # a compiled regular expression</span>
<span class="sd">        import regex</span>
<span class="sd">        parser = pp.Regex(regex.compile(r&#39;[0-9]&#39;))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">asGroupList</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">asMatch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The parameters ``pattern`` and ``flags`` are passed</span>
<span class="sd">        to the ``re.compile()`` function as-is. See the Python</span>
<span class="sd">        `re module &lt;https://docs.python.org/3/library/re.html&gt;`_ module for an</span>
<span class="sd">        explanation of the acceptable patterns and flags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Regex</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;null string passed to Regex; use Empty() instead&quot;</span><span class="p">,</span>
                              <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span>
            <span class="k">except</span> <span class="n">sre_constants</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;invalid pattern (</span><span class="si">%s</span><span class="s2">) passed to Regex&quot;</span> <span class="o">%</span> <span class="n">pattern</span><span class="p">,</span>
                              <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">raise</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="s1">&#39;pattern&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="s1">&#39;match&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Regex may only be constructed with a string or a compiled RE object&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">match</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asGroupList</span> <span class="o">=</span> <span class="n">asGroupList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asMatch</span> <span class="o">=</span> <span class="n">asMatch</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asGroupList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImplAsGroupList</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asMatch</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImplAsMatch</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">parseImplAsGroupList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">parseImplAsMatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Regex</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;Re:(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repl</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Regex with an attached parse action to transform the parsed</span>
<span class="sd">        result as if called using `re.sub(expr, repl, string) &lt;https://docs.python.org/3/library/re.html#re.sub&gt;`_.</span>

<span class="sd">        Example::</span>

<span class="sd">            make_html = Regex(r&quot;(\w+):(.*?):&quot;).sub(r&quot;&lt;\1&gt;\2&lt;/\1&gt;&quot;)</span>
<span class="sd">            print(make_html.transformString(&quot;h1:main title:&quot;))</span>
<span class="sd">            # prints &quot;&lt;h1&gt;main title&lt;/h1&gt;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asGroupList</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;cannot use sub() with Regex(asGroupList=True)&quot;</span><span class="p">,</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asMatch</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">repl</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;cannot use sub() with a callable with Regex(asMatch=True)&quot;</span><span class="p">,</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asMatch</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">repl</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">repl</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">QuotedString</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Token for matching strings that are delimited by quoting characters.</span>

<span class="sd">    Defined with the following parameters:</span>

<span class="sd">        - quoteChar - string of one or more characters defining the</span>
<span class="sd">          quote delimiting string</span>
<span class="sd">        - escChar - character to escape quotes, typically backslash</span>
<span class="sd">          (default= ``None``)</span>
<span class="sd">        - escQuote - special quote sequence to escape an embedded quote</span>
<span class="sd">          string (such as SQL&#39;s ``&quot;&quot;`` to escape an embedded ``&quot;``)</span>
<span class="sd">          (default= ``None``)</span>
<span class="sd">        - multiline - boolean indicating whether quotes can span</span>
<span class="sd">          multiple lines (default= ``False``)</span>
<span class="sd">        - unquoteResults - boolean indicating whether the matched text</span>
<span class="sd">          should be unquoted (default= ``True``)</span>
<span class="sd">        - endQuoteChar - string of one or more characters defining the</span>
<span class="sd">          end of the quote delimited string (default= ``None``  =&gt; same as</span>
<span class="sd">          quoteChar)</span>
<span class="sd">        - convertWhitespaceEscapes - convert escaped whitespace</span>
<span class="sd">          (``&#39;\t&#39;``, ``&#39;\n&#39;``, etc.) to actual whitespace</span>
<span class="sd">          (default= ``True``)</span>

<span class="sd">    Example::</span>

<span class="sd">        qs = QuotedString(&#39;&quot;&#39;)</span>
<span class="sd">        print(qs.searchString(&#39;lsjdf &quot;This is the quote&quot; sldjf&#39;))</span>
<span class="sd">        complex_qs = QuotedString(&#39;{{&#39;, endQuoteChar=&#39;}}&#39;)</span>
<span class="sd">        print(complex_qs.searchString(&#39;lsjdf {{This is the &quot;quote&quot;}} sldjf&#39;))</span>
<span class="sd">        sql_qs = QuotedString(&#39;&quot;&#39;, escQuote=&#39;&quot;&quot;&#39;)</span>
<span class="sd">        print(sql_qs.searchString(&#39;lsjdf &quot;This is the quote with &quot;&quot;embedded&quot;&quot; quotes&quot; sldjf&#39;))</span>

<span class="sd">    prints::</span>

<span class="sd">        [[&#39;This is the quote&#39;]]</span>
<span class="sd">        [[&#39;This is the &quot;quote&quot;&#39;]]</span>
<span class="sd">        [[&#39;This is the quote with &quot;embedded&quot; quotes&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quoteChar</span><span class="p">,</span> <span class="n">escChar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">escQuote</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiline</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">unquoteResults</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">endQuoteChar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convertWhitespaceEscapes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">QuotedString</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># remove white space from quote chars - wont work anyway</span>
        <span class="n">quoteChar</span> <span class="o">=</span> <span class="n">quoteChar</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">quoteChar</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;quoteChar cannot be the empty string&quot;</span><span class="p">,</span> <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">endQuoteChar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endQuoteChar</span> <span class="o">=</span> <span class="n">quoteChar</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endQuoteChar</span> <span class="o">=</span> <span class="n">endQuoteChar</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">endQuoteChar</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;endQuoteChar cannot be the empty string&quot;</span><span class="p">,</span> <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span> <span class="o">=</span> <span class="n">quoteChar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quoteCharLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quoteChar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firstQuoteChar</span> <span class="o">=</span> <span class="n">quoteChar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span> <span class="o">=</span> <span class="n">endQuoteChar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteCharLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">endQuoteChar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">escChar</span> <span class="o">=</span> <span class="n">escChar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">escQuote</span> <span class="o">=</span> <span class="n">escQuote</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unquoteResults</span> <span class="o">=</span> <span class="n">unquoteResults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convertWhitespaceEscapes</span> <span class="o">=</span> <span class="n">convertWhitespaceEscapes</span>

        <span class="k">if</span> <span class="n">multiline</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(?:[^</span><span class="si">%s%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span><span class="p">),</span>
                                              <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                              <span class="p">(</span><span class="n">escChar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="n">escChar</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(?:[^</span><span class="si">%s</span><span class="s1">\n\r</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span><span class="p">),</span>
                                                  <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                  <span class="p">(</span><span class="n">escChar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="n">escChar</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s1">&#39;|(?:&#39;</span> <span class="o">+</span> <span class="s1">&#39;)|(?:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[^</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[:</span><span class="n">i</span><span class="p">]),</span>
                                                   <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">escQuote</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">+=</span> <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;|(?:</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">escQuote</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">escChar</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">+=</span> <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;|(?:</span><span class="si">%s</span><span class="s1">.)&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">escChar</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">escCharReplacePattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">escChar</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;(.)&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">+=</span> <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;)*</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">match</span>
        <span class="k">except</span> <span class="n">sre_constants</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;invalid pattern (</span><span class="si">%s</span><span class="s2">) passed to Regex&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span>
                          <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">raise</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstQuoteChar</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unquoteResults</span><span class="p">:</span>

            <span class="c1"># strip off quotes</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteCharLen</span><span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteCharLen</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
                <span class="c1"># replace escaped whitespace</span>
                <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">ret</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertWhitespaceEscapes</span><span class="p">:</span>
                    <span class="n">ws_map</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="sa">r</span><span class="s1">&#39;\t&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="sa">r</span><span class="s1">&#39;\n&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="sa">r</span><span class="s1">&#39;\f&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\f</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="sa">r</span><span class="s1">&#39;\r&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="p">}</span>
                    <span class="k">for</span> <span class="n">wslit</span><span class="p">,</span> <span class="n">wschar</span> <span class="ow">in</span> <span class="n">ws_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">wslit</span><span class="p">,</span> <span class="n">wschar</span><span class="p">)</span>

                <span class="c1"># replace escaped characters</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">escChar</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">escCharReplacePattern</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\g&lt;1&gt;&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>

                <span class="c1"># replace escaped quotes</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">escQuote</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">escQuote</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">QuotedString</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;quoted string, starting with </span><span class="si">%s</span><span class="s2"> ending with </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>


<span class="k">class</span> <span class="nc">CharsNotIn</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token for matching words composed of characters *not* in a given</span>
<span class="sd">    set (will include whitespace in matched characters if not listed in</span>
<span class="sd">    the provided exclusion set - see example). Defined with string</span>
<span class="sd">    containing all disallowed characters, and an optional minimum,</span>
<span class="sd">    maximum, and/or exact length.  The default value for ``min`` is</span>
<span class="sd">    1 (a minimum value &lt; 1 is not valid); the default values for</span>
<span class="sd">    ``max`` and ``exact`` are 0, meaning no maximum or exact</span>
<span class="sd">    length restriction.</span>

<span class="sd">    Example::</span>

<span class="sd">        # define a comma-separated-value as anything that is not a &#39;,&#39;</span>
<span class="sd">        csv_value = CharsNotIn(&#39;,&#39;)</span>
<span class="sd">        print(delimitedList(csv_value).parseString(&quot;dkls,lsdkjf,s12 34,@!#,213&quot;))</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;dkls&#39;, &#39;lsdkjf&#39;, &#39;s12 34&#39;, &#39;@!#&#39;, &#39;213&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">notChars</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CharsNotIn</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notChars</span> <span class="o">=</span> <span class="n">notChars</span>

        <span class="k">if</span> <span class="nb">min</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot specify a minimum length &lt; 1; use &quot;</span>
                             <span class="s2">&quot;Optional(CharsNotIn()) if zero-length char group is permitted&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="nb">min</span>

        <span class="k">if</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">_MAX_INT</span>

        <span class="k">if</span> <span class="n">exact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">exact</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="n">exact</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notChars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">notchars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">notChars</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">maxlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">notchars</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">loc</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CharsNotIn</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notChars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;!W:(</span><span class="si">%s</span><span class="s2">...)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">notChars</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;!W:(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">notChars</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

<span class="k">class</span> <span class="nc">White</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Special matching class for matching whitespace.  Normally,</span>
<span class="sd">    whitespace is ignored by pyparsing grammars.  This class is included</span>
<span class="sd">    when some whitespace structures are significant.  Define with</span>
<span class="sd">    a string containing the whitespace characters to be matched; default</span>
<span class="sd">    is ``&quot; \\t\\r\\n&quot;``.  Also takes optional ``min``,</span>
<span class="sd">    ``max``, and ``exact`` arguments, as defined for the</span>
<span class="sd">    :class:`Word` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">whiteStrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39; &#39;</span> <span class="p">:</span> <span class="s1">&#39;&lt;SP&gt;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;TAB&gt;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;LF&gt;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;CR&gt;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;</span><span class="se">\f</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;FF&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u00A0</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;NBSP&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u1680</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;OGHAM_SPACE_MARK&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u180E</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;MONGOLIAN_VOWEL_SEPARATOR&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u2000</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;EN_QUAD&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u2001</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;EM_QUAD&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u2002</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;EN_SPACE&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u2003</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;EM_SPACE&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u2004</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;THREE-PER-EM_SPACE&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u2005</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;FOUR-PER-EM_SPACE&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u2006</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;SIX-PER-EM_SPACE&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u2007</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;FIGURE_SPACE&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u2008</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;PUNCTUATION_SPACE&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u2009</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;THIN_SPACE&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u200A</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;HAIR_SPACE&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u200B</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;ZERO_WIDTH_SPACE&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u202F</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;NNBSP&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u205F</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;MMSP&gt;&#39;</span><span class="p">,</span>
        <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u3000</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;IDEOGRAPHIC_SPACE&gt;&#39;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ws</span><span class="o">=</span><span class="s2">&quot; </span><span class="se">\t\r\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">White</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span> <span class="o">=</span> <span class="n">ws</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">))</span>
        <span class="c1"># ~ self.leaveWhitespace()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">White</span><span class="o">.</span><span class="n">whiteStrs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="nb">min</span>

        <span class="k">if</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">_MAX_INT</span>

        <span class="k">if</span> <span class="n">exact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">exact</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="n">exact</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">maxloc</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">maxloc</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">loc</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_PositionToken</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">class</span> <span class="nc">GoToColumn</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token to advance to a specific column of input text; useful for</span>
<span class="sd">    tabular report scraping.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colno</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GoToColumn</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">colno</span>

    <span class="k">def</span> <span class="nf">preParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
            <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipIgnorables</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">thiscol</span> <span class="o">=</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">thiscol</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;Text not in expected column&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">newloc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">-</span> <span class="n">thiscol</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">:</span> <span class="n">newloc</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">newloc</span><span class="p">,</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">LineStart</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Matches if current position is at the beginning of a line within</span>
<span class="sd">    the parse string</span>

<span class="sd">    Example::</span>

<span class="sd">        test = &#39;&#39;&#39;\</span>
<span class="sd">        AAA this line</span>
<span class="sd">        AAA and this line</span>
<span class="sd">          AAA but not this one</span>
<span class="sd">        B AAA and definitely not this one</span>
<span class="sd">        &#39;&#39;&#39;</span>

<span class="sd">        for t in (LineStart() + &#39;AAA&#39; + restOfLine).searchString(test):</span>
<span class="sd">            print(t)</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;AAA&#39;, &#39; this line&#39;]</span>
<span class="sd">        [&#39;AAA&#39;, &#39; and this line&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LineStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected start of line&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LineEnd</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches if current position is at the end of a line within the</span>
<span class="sd">    parse string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LineEnd</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected end of line&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">StringStart</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches if current position is at the beginning of the parse</span>
<span class="sd">    string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StringStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected start of text&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># see if entire string up to here is just whitespace and ignoreables</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

<span class="k">class</span> <span class="nc">StringEnd</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches if current position is at the end of the parse string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StringEnd</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected end of text&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">WordStart</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches if the current position is at the beginning of a Word,</span>
<span class="sd">    and is not preceded by any character in a given set of</span>
<span class="sd">    ``wordChars`` (default= ``printables``). To emulate the</span>
<span class="sd">    ``\b`` behavior of regular expressions, use</span>
<span class="sd">    ``WordStart(alphanums)``. ``WordStart`` will also match at</span>
<span class="sd">    the beginning of the string being parsed, or at the beginning of</span>
<span class="sd">    a line.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordChars</span><span class="o">=</span><span class="n">printables</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WordStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wordChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Not at the start of a word&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span>
                    <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

<span class="k">class</span> <span class="nc">WordEnd</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches if the current position is at the end of a Word, and is</span>
<span class="sd">    not followed by any character in a given set of ``wordChars``</span>
<span class="sd">    (default= ``printables``). To emulate the ``\b`` behavior of</span>
<span class="sd">    regular expressions, use ``WordEnd(alphanums)``. ``WordEnd``</span>
<span class="sd">    will also match at the end of the string being parsed, or at the end</span>
<span class="sd">    of a line.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordChars</span><span class="o">=</span><span class="n">printables</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WordEnd</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wordChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Not at the end of a word&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">instrlen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span> <span class="ow">or</span>
                    <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">ParseExpression</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract subclass of ParserElement, for combining and</span>
<span class="sd">    post-processing parsed tokens.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">_generatorType</span><span class="p">):</span>
            <span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">exprs</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">exprs</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
            <span class="c1"># if sequence of strings provided, wrap with Literal</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">basestring</span><span class="p">)</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">):</span>
                <span class="n">exprs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">basestring</span><span class="p">)</span> <span class="k">else</span> <span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">exprs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">leaveWhitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extends ``leaveWhitespace`` defined in base class, and also invokes ``leaveWhitespace`` on</span>
<span class="sd">           all contained expressions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Suppress</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>

        <span class="c1"># collapse nested And&#39;s of the form And(And(And(a, b), c), d) to And(a, b, c, d)</span>
        <span class="c1"># but only if there are no parse actions or resultsNames on the nested And&#39;s</span>
        <span class="c1"># (likewise for Or&#39;s and MatchFirst&#39;s)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">parseAction</span>
                    <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">resultsName</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">debug</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span>  <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayIndexError</span>

            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">parseAction</span>
                    <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">resultsName</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">debug</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span>  <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayIndexError</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">validateTrace</span> <span class="k">if</span> <span class="n">validateTrace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[])[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_ungrouped_named_tokens_in_collection</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">resultsName</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: setting results name </span><span class="si">{1!r}</span><span class="s2"> on </span><span class="si">{2}</span><span class="s2"> expression &quot;</span>
                                  <span class="s2">&quot;collides with </span><span class="si">{3!r}</span><span class="s2"> on contained expression&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;warn_ungrouped_named_tokens_in_collection&quot;</span><span class="p">,</span>
                                                                                       <span class="n">name</span><span class="p">,</span>
                                                                                       <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                                                       <span class="n">e</span><span class="o">.</span><span class="n">resultsName</span><span class="p">),</span>
                                  <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">And</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires all given :class:`ParseExpression` s to be found in the given order.</span>
<span class="sd">    Expressions may be separated by whitespace.</span>
<span class="sd">    May be constructed using the ``&#39;+&#39;`` operator.</span>
<span class="sd">    May also be constructed using the ``&#39;-&#39;`` operator, which will</span>
<span class="sd">    suppress backtracking.</span>

<span class="sd">    Example::</span>

<span class="sd">        integer = Word(nums)</span>
<span class="sd">        name_expr = OneOrMore(Word(alphas))</span>

<span class="sd">        expr = And([integer(&quot;id&quot;), name_expr(&quot;name&quot;), integer(&quot;age&quot;)])</span>
<span class="sd">        # more easily written as:</span>
<span class="sd">        expr = integer(&quot;id&quot;) + name_expr(&quot;name&quot;) + integer(&quot;age&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">_ErrorStop</span><span class="p">(</span><span class="n">Empty</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">And</span><span class="o">.</span><span class="n">_ErrorStop</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exprs</span> <span class="ow">and</span> <span class="bp">Ellipsis</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exprs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">skipto_arg</span> <span class="o">=</span> <span class="p">(</span><span class="n">Empty</span><span class="p">()</span> <span class="o">+</span> <span class="n">exprs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SkipTo</span><span class="p">(</span><span class="n">skipto_arg</span><span class="p">)(</span><span class="s2">&quot;_skipped*&quot;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;cannot construct And with sequence ending in ...&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="n">exprs</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">And</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">whiteChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">skipWhitespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># collapse any _PendingSkip&#39;s</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ParseExpression</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">exprs</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">_PendingSkip</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ParseExpression</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">exprs</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">_PendingSkip</span><span class="p">)):</span>
                        <span class="n">e</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">And</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># pass False as last arg to _parse for first element, since we already</span>
        <span class="c1"># pre-parsed the string as part of our And pre-parsing</span>
        <span class="n">loc</span><span class="p">,</span> <span class="n">resultlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">errorStop</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">And</span><span class="o">.</span><span class="n">_ErrorStop</span><span class="p">):</span>
                <span class="n">errorStop</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">errorStop</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">loc</span><span class="p">,</span> <span class="n">exprtokens</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseSyntaxException</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">pe</span><span class="p">:</span>
                    <span class="n">pe</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">raise</span> <span class="n">ParseSyntaxException</span><span class="o">.</span><span class="n">_from_exception</span><span class="p">(</span><span class="n">pe</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseSyntaxException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span><span class="p">,</span> <span class="n">exprtokens</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exprtokens</span> <span class="ow">or</span> <span class="n">exprtokens</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
                <span class="n">resultlist</span> <span class="o">+=</span> <span class="n">exprtokens</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">resultlist</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  <span class="c1"># And([self, other])</span>

    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span><span class="p">):</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span><span class="n">subRecCheckList</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>


<span class="k">class</span> <span class="nc">Or</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Requires that at least one :class:`ParseExpression` is found. If</span>
<span class="sd">    two expressions match, the expression that matches the longest</span>
<span class="sd">    string will be used. May be constructed using the ``&#39;^&#39;``</span>
<span class="sd">    operator.</span>

<span class="sd">    Example::</span>

<span class="sd">        # construct Or using &#39;^&#39; operator</span>

<span class="sd">        number = Word(nums) ^ Combine(Word(nums) + &#39;.&#39; + Word(nums))</span>
<span class="sd">        print(number.searchString(&quot;123 3.1416 789&quot;))</span>

<span class="sd">    prints::</span>

<span class="sd">        [[&#39;123&#39;], [&#39;3.1416&#39;], [&#39;789&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Or</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Or</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">__compat__</span><span class="o">.</span><span class="n">collect_all_And_tokens</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">saveAsList</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">maxException</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">loc2</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">tryParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">err</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                    <span class="n">maxException</span> <span class="o">=</span> <span class="n">err</span>
                    <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                    <span class="n">maxException</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span> <span class="n">e</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                    <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># save match among all matches, to retry longest to shortest</span>
                <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">loc2</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">matches</span><span class="p">:</span>
            <span class="c1"># re-evaluate all matches in descending order of length of match, in case attached actions</span>
            <span class="c1"># might change whether or how much they match of the input.</span>
            <span class="n">matches</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">doActions</span><span class="p">:</span>
                <span class="c1"># no further conditions or parse actions to change the selection of</span>
                <span class="c1"># alternative, so the first match will be the best match</span>
                <span class="n">best_expr</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">best_expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>

            <span class="n">longest</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">loc1</span><span class="p">,</span> <span class="n">expr1</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">loc1</span> <span class="o">&lt;=</span> <span class="n">longest</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># already have a longer match than this one will deliver, we are done</span>
                    <span class="k">return</span> <span class="n">longest</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">loc2</span><span class="p">,</span> <span class="n">toks</span> <span class="o">=</span> <span class="n">expr1</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="n">err</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                        <span class="n">maxException</span> <span class="o">=</span> <span class="n">err</span>
                        <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">loc2</span> <span class="o">&gt;=</span> <span class="n">loc1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">loc2</span><span class="p">,</span> <span class="n">toks</span>
                    <span class="c1"># didn&#39;t match as much as before</span>
                    <span class="k">elif</span> <span class="n">loc2</span> <span class="o">&gt;</span> <span class="n">longest</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">longest</span> <span class="o">=</span> <span class="n">loc2</span><span class="p">,</span> <span class="n">toks</span>

            <span class="k">if</span> <span class="n">longest</span> <span class="o">!=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">longest</span>

        <span class="k">if</span> <span class="n">maxException</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxException</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span>
            <span class="k">raise</span> <span class="n">maxException</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;no defined alternatives to match&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


    <span class="k">def</span> <span class="fm">__ixor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  <span class="c1"># Or([self, other])</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot; ^ &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span><span class="p">):</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span><span class="n">subRecCheckList</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">__compat__</span><span class="o">.</span><span class="n">collect_all_And_tokens</span>
                <span class="ow">and</span> <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_multiple_tokens_in_named_alternation</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">And</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: setting results name </span><span class="si">{1!r}</span><span class="s2"> on </span><span class="si">{2}</span><span class="s2"> expression &quot;</span>
                              <span class="s2">&quot;may only return a single token for an And alternative, &quot;</span>
                              <span class="s2">&quot;in future will return the full list of tokens&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;warn_multiple_tokens_in_named_alternation&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Or</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MatchFirst</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Requires that at least one :class:`ParseExpression` is found. If</span>
<span class="sd">    two expressions match, the first one listed is the one that will</span>
<span class="sd">    match. May be constructed using the ``&#39;|&#39;`` operator.</span>

<span class="sd">    Example::</span>

<span class="sd">        # construct MatchFirst using &#39;|&#39; operator</span>

<span class="sd">        # watch the order of expressions to match</span>
<span class="sd">        number = Word(nums) | Combine(Word(nums) + &#39;.&#39; + Word(nums))</span>
<span class="sd">        print(number.searchString(&quot;123 3.1416 789&quot;)) #  Fail! -&gt; [[&#39;123&#39;], [&#39;3&#39;], [&#39;1416&#39;], [&#39;789&#39;]]</span>

<span class="sd">        # put more selective expression first</span>
<span class="sd">        number = Combine(Word(nums) + &#39;.&#39; + Word(nums)) | Word(nums)</span>
<span class="sd">        print(number.searchString(&quot;123 3.1416 789&quot;)) #  Better -&gt; [[&#39;123&#39;], [&#39;3.1416&#39;], [&#39;789&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MatchFirst</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MatchFirst</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">__compat__</span><span class="o">.</span><span class="n">collect_all_And_tokens</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">saveAsList</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">maxException</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                    <span class="n">maxException</span> <span class="o">=</span> <span class="n">err</span>
                    <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                    <span class="n">maxException</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span> <span class="n">e</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                    <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>

        <span class="c1"># only got here if no expression matched, raise exception for match that made it the furthest</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">maxException</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">maxException</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span>
                <span class="k">raise</span> <span class="n">maxException</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;no defined alternatives to match&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ior__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  <span class="c1"># MatchFirst([self, other])</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot; | &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span><span class="p">):</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span><span class="n">subRecCheckList</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">__compat__</span><span class="o">.</span><span class="n">collect_all_And_tokens</span>
                <span class="ow">and</span> <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_multiple_tokens_in_named_alternation</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">And</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: setting results name </span><span class="si">{1!r}</span><span class="s2"> on </span><span class="si">{2}</span><span class="s2"> expression &quot;</span>
                              <span class="s2">&quot;may only return a single token for an And alternative, &quot;</span>
                              <span class="s2">&quot;in future will return the full list of tokens&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;warn_multiple_tokens_in_named_alternation&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MatchFirst</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Each</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Requires all given :class:`ParseExpression` s to be found, but in</span>
<span class="sd">    any order. Expressions may be separated by whitespace.</span>

<span class="sd">    May be constructed using the ``&#39;&amp;&#39;`` operator.</span>

<span class="sd">    Example::</span>

<span class="sd">        color = oneOf(&quot;RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN&quot;)</span>
<span class="sd">        shape_type = oneOf(&quot;SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON&quot;)</span>
<span class="sd">        integer = Word(nums)</span>
<span class="sd">        shape_attr = &quot;shape:&quot; + shape_type(&quot;shape&quot;)</span>
<span class="sd">        posn_attr = &quot;posn:&quot; + Group(integer(&quot;x&quot;) + &#39;,&#39; + integer(&quot;y&quot;))(&quot;posn&quot;)</span>
<span class="sd">        color_attr = &quot;color:&quot; + color(&quot;color&quot;)</span>
<span class="sd">        size_attr = &quot;size:&quot; + integer(&quot;size&quot;)</span>

<span class="sd">        # use Each (using operator &#39;&amp;&#39;) to accept attributes in any order</span>
<span class="sd">        # (shape and posn are required, color and size are optional)</span>
<span class="sd">        shape_spec = shape_attr &amp; posn_attr &amp; Optional(color_attr) &amp; Optional(size_attr)</span>

<span class="sd">        shape_spec.runTests(&#39;&#39;&#39;</span>
<span class="sd">            shape: SQUARE color: BLACK posn: 100, 120</span>
<span class="sd">            shape: CIRCLE size: 50 color: BLUE posn: 50,80</span>
<span class="sd">            color:GREEN size:20 shape:TRIANGLE posn:20,40</span>
<span class="sd">            &#39;&#39;&#39;</span>
<span class="sd">            )</span>

<span class="sd">    prints::</span>

<span class="sd">        shape: SQUARE color: BLACK posn: 100, 120</span>
<span class="sd">        [&#39;shape:&#39;, &#39;SQUARE&#39;, &#39;color:&#39;, &#39;BLACK&#39;, &#39;posn:&#39;, [&#39;100&#39;, &#39;,&#39;, &#39;120&#39;]]</span>
<span class="sd">        - color: BLACK</span>
<span class="sd">        - posn: [&#39;100&#39;, &#39;,&#39;, &#39;120&#39;]</span>
<span class="sd">          - x: 100</span>
<span class="sd">          - y: 120</span>
<span class="sd">        - shape: SQUARE</span>


<span class="sd">        shape: CIRCLE size: 50 color: BLUE posn: 50,80</span>
<span class="sd">        [&#39;shape:&#39;, &#39;CIRCLE&#39;, &#39;size:&#39;, &#39;50&#39;, &#39;color:&#39;, &#39;BLUE&#39;, &#39;posn:&#39;, [&#39;50&#39;, &#39;,&#39;, &#39;80&#39;]]</span>
<span class="sd">        - color: BLUE</span>
<span class="sd">        - posn: [&#39;50&#39;, &#39;,&#39;, &#39;80&#39;]</span>
<span class="sd">          - x: 50</span>
<span class="sd">          - y: 80</span>
<span class="sd">        - shape: CIRCLE</span>
<span class="sd">        - size: 50</span>


<span class="sd">        color: GREEN size: 20 shape: TRIANGLE posn: 20,40</span>
<span class="sd">        [&#39;color:&#39;, &#39;GREEN&#39;, &#39;size:&#39;, &#39;20&#39;, &#39;shape:&#39;, &#39;TRIANGLE&#39;, &#39;posn:&#39;, [&#39;20&#39;, &#39;,&#39;, &#39;40&#39;]]</span>
<span class="sd">        - color: GREEN</span>
<span class="sd">        - posn: [&#39;20&#39;, &#39;,&#39;, &#39;40&#39;]</span>
<span class="sd">          - x: 20</span>
<span class="sd">          - y: 40</span>
<span class="sd">        - shape: TRIANGLE</span>
<span class="sd">        - size: 20</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Each</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initExprGroups</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Each</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initExprGroups</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opt1map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">id</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">expr</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Optional</span><span class="p">))</span>
            <span class="n">opt1</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Optional</span><span class="p">)]</span>
            <span class="n">opt2</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">Optional</span><span class="p">,</span> <span class="n">Regex</span><span class="p">))]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optionals</span> <span class="o">=</span> <span class="n">opt1</span> <span class="o">+</span> <span class="n">opt2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multioptionals</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ZeroOrMore</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multirequired</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">OneOrMore</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">Optional</span><span class="p">,</span> <span class="n">ZeroOrMore</span><span class="p">,</span> <span class="n">OneOrMore</span><span class="p">))]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">required</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multirequired</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initExprGroups</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">tmpLoc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">tmpReqd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">required</span><span class="p">[:]</span>
        <span class="n">tmpOpt</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optionals</span><span class="p">[:]</span>
        <span class="n">matchOrder</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">keepMatching</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">keepMatching</span><span class="p">:</span>
            <span class="n">tmpExprs</span> <span class="o">=</span> <span class="n">tmpReqd</span> <span class="o">+</span> <span class="n">tmpOpt</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">multioptionals</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">multirequired</span>
            <span class="n">failed</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpExprs</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">tmpLoc</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">tryParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tmpLoc</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseException</span><span class="p">:</span>
                    <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">matchOrder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt1map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">e</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpReqd</span><span class="p">:</span>
                        <span class="n">tmpReqd</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpOpt</span><span class="p">:</span>
                        <span class="n">tmpOpt</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmpExprs</span><span class="p">):</span>
                <span class="n">keepMatching</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">tmpReqd</span><span class="p">:</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpReqd</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;Missing one or more required elements (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">missing</span><span class="p">)</span>

        <span class="c1"># add any unmatched Optionals, in case they have default values defined</span>
        <span class="n">matchOrder</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Optional</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">expr</span> <span class="ow">in</span> <span class="n">tmpOpt</span><span class="p">]</span>

        <span class="n">resultlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">matchOrder</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">results</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
            <span class="n">resultlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="n">finalResults</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">resultlist</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">([]))</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">finalResults</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span><span class="p">):</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span><span class="n">subRecCheckList</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ParseElementEnhance</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract subclass of :class:`ParserElement`, for combining and</span>
<span class="sd">    post-processing parsed tokens.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">,</span> <span class="n">Token</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">Literal</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">mayIndexError</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">whiteChars</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">skipWhitespace</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">saveAsList</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">callPreparse</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">leaveWhitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Suppress</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">parseElementList</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveGrammarException</span><span class="p">(</span><span class="n">parseElementList</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">])</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span><span class="n">subRecCheckList</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">validateTrace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validateTrace</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">validateTrace</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">([])</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>


<span class="k">class</span> <span class="nc">FollowedBy</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lookahead matching of the given parse expression.</span>
<span class="sd">    ``FollowedBy`` does *not* advance the parsing position within</span>
<span class="sd">    the input string, it only verifies that the specified parse</span>
<span class="sd">    expression matches at the current position.  ``FollowedBy``</span>
<span class="sd">    always returns a null token list. If any results names are defined</span>
<span class="sd">    in the lookahead expression, those *will* be returned for access by</span>
<span class="sd">    name.</span>

<span class="sd">    Example::</span>

<span class="sd">        # use FollowedBy to match a label only if it is followed by a &#39;:&#39;</span>
<span class="sd">        data_word = Word(alphas)</span>
<span class="sd">        label = data_word + FollowedBy(&#39;:&#39;)</span>
<span class="sd">        attr_expr = Group(label + Suppress(&#39;:&#39;) + OneOrMore(data_word, stopOn=label).setParseAction(&#39; &#39;.join))</span>

<span class="sd">        OneOrMore(attr_expr).parseString(&quot;shape: SQUARE color: BLACK posn: upper left&quot;).pprint()</span>

<span class="sd">    prints::</span>

<span class="sd">        [[&#39;shape&#39;, &#39;SQUARE&#39;], [&#39;color&#39;, &#39;BLACK&#39;], [&#39;posn&#39;, &#39;upper left&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FollowedBy</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># by using self._expr.parse and deleting the contents of the returned ParseResults list</span>
        <span class="c1"># we keep any named results that were defined in the FollowedBy expression</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="n">doActions</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ret</span><span class="p">[:]</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">PrecededBy</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lookbehind matching of the given parse expression.</span>
<span class="sd">    ``PrecededBy`` does not advance the parsing position within the</span>
<span class="sd">    input string, it only verifies that the specified parse expression</span>
<span class="sd">    matches prior to the current position.  ``PrecededBy`` always</span>
<span class="sd">    returns a null token list, but if a results name is defined on the</span>
<span class="sd">    given expression, it is returned.</span>

<span class="sd">    Parameters:</span>

<span class="sd">     - expr - expression that must match prior to the current parse</span>
<span class="sd">       location</span>
<span class="sd">     - retreat - (default= ``None``) - (int) maximum number of characters</span>
<span class="sd">       to lookbehind prior to the current parse location</span>

<span class="sd">    If the lookbehind expression is a string, Literal, Keyword, or</span>
<span class="sd">    a Word or CharsNotIn with a specified exact or maximum length, then</span>
<span class="sd">    the retreat parameter is not required. Otherwise, retreat must be</span>
<span class="sd">    specified to give a maximum number of characters to look back from</span>
<span class="sd">    the current parse position for a lookbehind match.</span>

<span class="sd">    Example::</span>

<span class="sd">        # VB-style variable names with type prefixes</span>
<span class="sd">        int_var = PrecededBy(&quot;#&quot;) + pyparsing_common.identifier</span>
<span class="sd">        str_var = PrecededBy(&quot;$&quot;) + pyparsing_common.identifier</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">retreat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PrecededBy</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">()</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exact</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">retreat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exact</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="n">Keyword</span><span class="p">)):</span>
            <span class="n">retreat</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">matchLen</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exact</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">Word</span><span class="p">,</span> <span class="n">CharsNotIn</span><span class="p">))</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">!=</span> <span class="n">_MAX_INT</span><span class="p">:</span>
            <span class="n">retreat</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">maxLen</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exact</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">_PositionToken</span><span class="p">):</span>
            <span class="n">retreat</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exact</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retreat</span> <span class="o">=</span> <span class="n">retreat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;not preceded by &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exact</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">retreat</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">retreat</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># retreat specified a maximum lookbehind window, iterate</span>
            <span class="n">test_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">+</span> <span class="n">StringEnd</span><span class="p">()</span>
            <span class="n">instring_slice</span> <span class="o">=</span> <span class="n">instring</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">loc</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">retreat</span><span class="p">):</span><span class="n">loc</span><span class="p">]</span>
            <span class="n">last_expr</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">retreat</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># print(&#39;trying&#39;, offset, instring_slice, repr(instring_slice[loc - offset:]))</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">test_expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring_slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring_slice</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">pbe</span><span class="p">:</span>
                    <span class="n">last_expr</span> <span class="o">=</span> <span class="n">pbe</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">last_expr</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">NotAny</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lookahead to disallow matching with the given parse expression.</span>
<span class="sd">    ``NotAny`` does *not* advance the parsing position within the</span>
<span class="sd">    input string, it only verifies that the specified parse expression</span>
<span class="sd">    does *not* match at the current position.  Also, ``NotAny`` does</span>
<span class="sd">    *not* skip over leading whitespace. ``NotAny`` always returns</span>
<span class="sd">    a null token list.  May be constructed using the &#39;~&#39; operator.</span>

<span class="sd">    Example::</span>

<span class="sd">        AND, OR, NOT = map(CaselessKeyword, &quot;AND OR NOT&quot;.split())</span>

<span class="sd">        # take care not to mistake keywords for identifiers</span>
<span class="sd">        ident = ~(AND | OR | NOT) + Word(alphas)</span>
<span class="sd">        boolean_term = Optional(NOT) + ident</span>

<span class="sd">        # very crude boolean expression - to support parenthesis groups and</span>
<span class="sd">        # operation hierarchy, use infixNotation</span>
<span class="sd">        boolean_expr = boolean_term + ZeroOrMore((AND | OR) + boolean_term)</span>

<span class="sd">        # integers that are followed by &quot;.&quot; are actually floats</span>
<span class="sd">        integer = Word(nums) + ~Char(&quot;.&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NotAny</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="c1"># ~ self.leaveWhitespace()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># do NOT use self.leaveWhitespace(), don&#39;t want to propagate to exprs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Found unwanted token, &quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">canParseNext</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;~{&quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

<span class="k">class</span> <span class="nc">_MultipleMatch</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">stopOn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_MultipleMatch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ender</span> <span class="o">=</span> <span class="n">stopOn</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ender</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">ender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">ender</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stopOn</span><span class="p">(</span><span class="n">ender</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stopOn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ender</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ender</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">ender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">ender</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">not_ender</span> <span class="o">=</span> <span class="o">~</span><span class="n">ender</span> <span class="k">if</span> <span class="n">ender</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">self_expr_parse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span>
        <span class="n">self_skip_ignorables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipIgnorables</span>
        <span class="n">check_ender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_ender</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">check_ender</span><span class="p">:</span>
            <span class="n">try_not_ender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_ender</span><span class="o">.</span><span class="n">tryParse</span>

        <span class="c1"># must be at least one (but first see if we are the stopOn sentinel;</span>
        <span class="c1"># if so, fail)</span>
        <span class="k">if</span> <span class="n">check_ender</span><span class="p">:</span>
            <span class="n">try_not_ender</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">self_expr_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hasIgnoreExprs</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">)</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">check_ender</span><span class="p">:</span>
                    <span class="n">try_not_ender</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">hasIgnoreExprs</span><span class="p">:</span>
                    <span class="n">preloc</span> <span class="o">=</span> <span class="n">self_skip_ignorables</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">preloc</span> <span class="o">=</span> <span class="n">loc</span>
                <span class="n">loc</span><span class="p">,</span> <span class="n">tmptokens</span> <span class="o">=</span> <span class="n">self_expr_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tmptokens</span> <span class="ow">or</span> <span class="n">tmptokens</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
                    <span class="n">tokens</span> <span class="o">+=</span> <span class="n">tmptokens</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_ungrouped_named_tokens_in_collection</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">]</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;exprs&#39;</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">resultsName</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: setting results name </span><span class="si">{1!r}</span><span class="s2"> on </span><span class="si">{2}</span><span class="s2"> expression &quot;</span>
                                  <span class="s2">&quot;collides with </span><span class="si">{3!r}</span><span class="s2"> on contained expression&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;warn_ungrouped_named_tokens_in_collection&quot;</span><span class="p">,</span>
                                                                                       <span class="n">name</span><span class="p">,</span>
                                                                                       <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                                                       <span class="n">e</span><span class="o">.</span><span class="n">resultsName</span><span class="p">),</span>
                                  <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_MultipleMatch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OneOrMore</span><span class="p">(</span><span class="n">_MultipleMatch</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Repetition of one or more of the given expression.</span>

<span class="sd">    Parameters:</span>
<span class="sd">     - expr - expression that must match one or more times</span>
<span class="sd">     - stopOn - (default= ``None``) - expression for a terminating sentinel</span>
<span class="sd">          (only required if the sentinel would ordinarily match the repetition</span>
<span class="sd">          expression)</span>

<span class="sd">    Example::</span>

<span class="sd">        data_word = Word(alphas)</span>
<span class="sd">        label = data_word + FollowedBy(&#39;:&#39;)</span>
<span class="sd">        attr_expr = Group(label + Suppress(&#39;:&#39;) + OneOrMore(data_word).setParseAction(&#39; &#39;.join))</span>

<span class="sd">        text = &quot;shape: SQUARE posn: upper left color: BLACK&quot;</span>
<span class="sd">        OneOrMore(attr_expr).parseString(text).pprint()  # Fail! read &#39;color&#39; as data instead of next label -&gt; [[&#39;shape&#39;, &#39;SQUARE color&#39;]]</span>

<span class="sd">        # use stopOn attribute for OneOrMore to avoid reading label string as part of the data</span>
<span class="sd">        attr_expr = Group(label + Suppress(&#39;:&#39;) + OneOrMore(data_word, stopOn=label).setParseAction(&#39; &#39;.join))</span>
<span class="sd">        OneOrMore(attr_expr).parseString(text).pprint() # Better -&gt; [[&#39;shape&#39;, &#39;SQUARE&#39;], [&#39;posn&#39;, &#39;upper left&#39;], [&#39;color&#39;, &#39;BLACK&#39;]]</span>

<span class="sd">        # could also be written as</span>
<span class="sd">        (attr_expr * (1,)).parseString(text).pprint()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}...&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

<span class="k">class</span> <span class="nc">ZeroOrMore</span><span class="p">(</span><span class="n">_MultipleMatch</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optional repetition of zero or more of the given expression.</span>

<span class="sd">    Parameters:</span>
<span class="sd">     - expr - expression that must match zero or more times</span>
<span class="sd">     - stopOn - (default= ``None``) - expression for a terminating sentinel</span>
<span class="sd">          (only required if the sentinel would ordinarily match the repetition</span>
<span class="sd">          expression)</span>

<span class="sd">    Example: similar to :class:`OneOrMore`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">stopOn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ZeroOrMore</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">stopOn</span><span class="o">=</span><span class="n">stopOn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ZeroOrMore</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]...&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>


<span class="k">class</span> <span class="nc">_NullToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">class</span> <span class="nc">Optional</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optional matching of the given expression.</span>

<span class="sd">    Parameters:</span>
<span class="sd">     - expr - expression that must match zero or more times</span>
<span class="sd">     - default (optional) - value to be returned if the optional expression is not found.</span>

<span class="sd">    Example::</span>

<span class="sd">        # US postal code can be a 5-digit zip, plus optional 4-digit qualifier</span>
<span class="sd">        zip = Combine(Word(nums, exact=5) + Optional(&#39;-&#39; + Word(nums, exact=4)))</span>
<span class="sd">        zip.runTests(&#39;&#39;&#39;</span>
<span class="sd">            # traditional ZIP code</span>
<span class="sd">            12345</span>

<span class="sd">            # ZIP+4 form</span>
<span class="sd">            12101-0001</span>

<span class="sd">            # invalid ZIP</span>
<span class="sd">            98765-</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">    prints::</span>

<span class="sd">        # traditional ZIP code</span>
<span class="sd">        12345</span>
<span class="sd">        [&#39;12345&#39;]</span>

<span class="sd">        # ZIP+4 form</span>
<span class="sd">        12101-0001</span>
<span class="sd">        [&#39;12101-0001&#39;]</span>

<span class="sd">        # invalid ZIP</span>
<span class="sd">        98765-</span>
<span class="sd">             ^</span>
<span class="sd">        FAIL: Expected end of text (at char 5), (line:1, col:6)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__optionalNotMatched</span> <span class="o">=</span> <span class="n">_NullToken</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">__optionalNotMatched</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Optional</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">saveAsList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span> <span class="o">=</span> <span class="n">default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__optionalNotMatched</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">resultsName</span><span class="p">:</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span><span class="p">])</span>
                    <span class="n">tokens</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">resultsName</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

<span class="k">class</span> <span class="nc">SkipTo</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token for skipping over all undefined text until the matched</span>
<span class="sd">    expression is found.</span>

<span class="sd">    Parameters:</span>
<span class="sd">     - expr - target expression marking the end of the data to be skipped</span>
<span class="sd">     - include - (default= ``False``) if True, the target expression is also parsed</span>
<span class="sd">          (the skipped text and target expression are returned as a 2-element list).</span>
<span class="sd">     - ignore - (default= ``None``) used to define grammars (typically quoted strings and</span>
<span class="sd">          comments) that might contain false matches to the target expression</span>
<span class="sd">     - failOn - (default= ``None``) define expressions that are not allowed to be</span>
<span class="sd">          included in the skipped test; if found before the target expression is found,</span>
<span class="sd">          the SkipTo is not a match</span>

<span class="sd">    Example::</span>

<span class="sd">        report = &#39;&#39;&#39;</span>
<span class="sd">            Outstanding Issues Report - 1 Jan 2000</span>

<span class="sd">               # | Severity | Description                               |  Days Open</span>
<span class="sd">            -----+----------+-------------------------------------------+-----------</span>
<span class="sd">             101 | Critical | Intermittent system crash                 |          6</span>
<span class="sd">              94 | Cosmetic | Spelling error on Login (&#39;log|n&#39;)         |         14</span>
<span class="sd">              79 | Minor    | System slow when running too many reports |         47</span>
<span class="sd">            &#39;&#39;&#39;</span>
<span class="sd">        integer = Word(nums)</span>
<span class="sd">        SEP = Suppress(&#39;|&#39;)</span>
<span class="sd">        # use SkipTo to simply match everything up until the next SEP</span>
<span class="sd">        # - ignore quoted strings, so that a &#39;|&#39; character inside a quoted string does not match</span>
<span class="sd">        # - parse action will call token.strip() for each matched token, i.e., the description body</span>
<span class="sd">        string_data = SkipTo(SEP, ignore=quotedString)</span>
<span class="sd">        string_data.setParseAction(tokenMap(str.strip))</span>
<span class="sd">        ticket_expr = (integer(&quot;issue_num&quot;) + SEP</span>
<span class="sd">                      + string_data(&quot;sev&quot;) + SEP</span>
<span class="sd">                      + string_data(&quot;desc&quot;) + SEP</span>
<span class="sd">                      + integer(&quot;days_open&quot;))</span>

<span class="sd">        for tkt in ticket_expr.searchString(report):</span>
<span class="sd">            print tkt.dump()</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;101&#39;, &#39;Critical&#39;, &#39;Intermittent system crash&#39;, &#39;6&#39;]</span>
<span class="sd">        - days_open: 6</span>
<span class="sd">        - desc: Intermittent system crash</span>
<span class="sd">        - issue_num: 101</span>
<span class="sd">        - sev: Critical</span>
<span class="sd">        [&#39;94&#39;, &#39;Cosmetic&#39;, &quot;Spelling error on Login (&#39;log|n&#39;)&quot;, &#39;14&#39;]</span>
<span class="sd">        - days_open: 14</span>
<span class="sd">        - desc: Spelling error on Login (&#39;log|n&#39;)</span>
<span class="sd">        - issue_num: 94</span>
<span class="sd">        - sev: Cosmetic</span>
<span class="sd">        [&#39;79&#39;, &#39;Minor&#39;, &#39;System slow when running too many reports&#39;, &#39;47&#39;]</span>
<span class="sd">        - days_open: 47</span>
<span class="sd">        - desc: System slow when running too many reports</span>
<span class="sd">        - issue_num: 79</span>
<span class="sd">        - sev: Minor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">failOn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SkipTo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExpr</span> <span class="o">=</span> <span class="n">ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">includeMatch</span> <span class="o">=</span> <span class="n">include</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">failOn</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">failOn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span> <span class="o">=</span> <span class="n">failOn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;No match found for &quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">startloc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span>
        <span class="n">expr_parse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span>
        <span class="n">self_failOn_canParseNext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span><span class="o">.</span><span class="n">canParseNext</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">self_ignoreExpr_tryParse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExpr</span><span class="o">.</span><span class="n">tryParse</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">tmploc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">while</span> <span class="n">tmploc</span> <span class="o">&lt;=</span> <span class="n">instrlen</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self_failOn_canParseNext</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># break if failOn expression matches</span>
                <span class="k">if</span> <span class="n">self_failOn_canParseNext</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tmploc</span><span class="p">):</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">self_ignoreExpr_tryParse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># advance past ignore expressions</span>
                <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">tmploc</span> <span class="o">=</span> <span class="n">self_ignoreExpr_tryParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tmploc</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">ParseBaseException</span><span class="p">:</span>
                        <span class="k">break</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">expr_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tmploc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                <span class="c1"># no match, advance loc in string</span>
                <span class="n">tmploc</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># matched skipto expr, done</span>
                <span class="k">break</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ran off the end of the input string without matching skipto expr, fail</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># build up return values</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">tmploc</span>
        <span class="n">skiptext</span> <span class="o">=</span> <span class="n">instring</span><span class="p">[</span><span class="n">startloc</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>
        <span class="n">skipresult</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">skiptext</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">includeMatch</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">expr_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">skipresult</span> <span class="o">+=</span> <span class="n">mat</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">skipresult</span>

<span class="k">class</span> <span class="nc">Forward</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Forward declaration of an expression to be defined later -</span>
<span class="sd">    used for recursive grammars, such as algebraic infix notation.</span>
<span class="sd">    When the expression is known, it is assigned to the ``Forward``</span>
<span class="sd">    variable using the &#39;&lt;&lt;&#39; operator.</span>

<span class="sd">    Note: take care when assigning to ``Forward`` not to overlook</span>
<span class="sd">    precedence of operators.</span>

<span class="sd">    Specifically, &#39;|&#39; has a lower precedence than &#39;&lt;&lt;&#39;, so that::</span>

<span class="sd">        fwdExpr &lt;&lt; a | b | c</span>

<span class="sd">    will actually be evaluated as::</span>

<span class="sd">        (fwdExpr &lt;&lt; a) | b | c</span>

<span class="sd">    thereby leaving b and c out as parseable alternatives.  It is recommended that you</span>
<span class="sd">    explicitly group the values inserted into the ``Forward``::</span>

<span class="sd">        fwdExpr &lt;&lt; (a | b | c)</span>

<span class="sd">    Converting to use the &#39;&lt;&lt;=&#39; operator instead will avoid this problem.</span>

<span class="sd">    See :class:`ParseResults.pprint` for an example of a recursive</span>
<span class="sd">    parser created using ``Forward``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Forward</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">other</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">mayIndexError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">whiteChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">skipWhitespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">saveAsList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__ilshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&lt;&lt;</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">leaveWhitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">validateTrace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validateTrace</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">validateTrace</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">validateTrace</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">([])</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

        <span class="c1"># Avoid infinite recursion by setting a temporary strRepr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;: ...&quot;</span>

        <span class="c1"># Use the string representation of main expression.</span>
        <span class="n">retString</span> <span class="o">=</span> <span class="s1">&#39;...&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">retString</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)[:</span><span class="mi">1000</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retString</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="n">retString</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Forward</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
            <span class="n">ret</span> <span class="o">&lt;&lt;=</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_name_set_on_empty_Forward</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: setting results name </span><span class="si">{0!r}</span><span class="s2"> on </span><span class="si">{1}</span><span class="s2"> expression &quot;</span>
                              <span class="s2">&quot;that has no contained expression&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;warn_name_set_on_empty_Forward&quot;</span><span class="p">,</span>
                                                                        <span class="n">name</span><span class="p">,</span>
                                                                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
                              <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Forward</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TokenConverter</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract subclass of :class:`ParseExpression`, for converting parsed results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>  <span class="c1"># , savelist)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">class</span> <span class="nc">Combine</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converter to concatenate all matching tokens to a single string.</span>
<span class="sd">    By default, the matching patterns must also be contiguous in the</span>
<span class="sd">    input string; this can be disabled by specifying</span>
<span class="sd">    ``&#39;adjacent=False&#39;`` in the constructor.</span>

<span class="sd">    Example::</span>

<span class="sd">        real = Word(nums) + &#39;.&#39; + Word(nums)</span>
<span class="sd">        print(real.parseString(&#39;3.1416&#39;)) # -&gt; [&#39;3&#39;, &#39;.&#39;, &#39;1416&#39;]</span>
<span class="sd">        # will also erroneously match the following</span>
<span class="sd">        print(real.parseString(&#39;3. 1416&#39;)) # -&gt; [&#39;3&#39;, &#39;.&#39;, &#39;1416&#39;]</span>

<span class="sd">        real = Combine(Word(nums) + &#39;.&#39; + Word(nums))</span>
<span class="sd">        print(real.parseString(&#39;3.1416&#39;)) # -&gt; [&#39;3.1416&#39;]</span>
<span class="sd">        # no match when there are internal spaces</span>
<span class="sd">        print(real.parseString(&#39;3. 1416&#39;)) # -&gt; Exception: Expected W:(0123...)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">joinString</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Combine</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="c1"># suppress whitespace-stripping in contained parse expressions, but re-enable it on the Combine itself</span>
        <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjacent</span> <span class="o">=</span> <span class="n">adjacent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">joinString</span> <span class="o">=</span> <span class="n">joinString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacent</span><span class="p">:</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Combine</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">):</span>
        <span class="n">retToks</span> <span class="o">=</span> <span class="n">tokenlist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">retToks</span><span class="p">[:]</span>
        <span class="n">retToks</span> <span class="o">+=</span> <span class="n">ParseResults</span><span class="p">([</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokenlist</span><span class="o">.</span><span class="n">_asStringList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joinString</span><span class="p">))],</span> <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span> <span class="ow">and</span> <span class="n">retToks</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">retToks</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">retToks</span>

<span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converter to return the matched tokens as a list - useful for</span>
<span class="sd">    returning tokens of :class:`ZeroOrMore` and :class:`OneOrMore` expressions.</span>

<span class="sd">    Example::</span>

<span class="sd">        ident = Word(alphas)</span>
<span class="sd">        num = Word(nums)</span>
<span class="sd">        term = ident | num</span>
<span class="sd">        func = ident + Optional(delimitedList(term))</span>
<span class="sd">        print(func.parseString(&quot;fn a, b, 100&quot;))  # -&gt; [&#39;fn&#39;, &#39;a&#39;, &#39;b&#39;, &#39;100&#39;]</span>

<span class="sd">        func = ident + Group(Optional(delimitedList(term)))</span>
<span class="sd">        print(func.parseString(&quot;fn a, b, 100&quot;))  # -&gt; [&#39;fn&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;100&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tokenlist</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Dict</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converter to return a repetitive expression as a list, but also</span>
<span class="sd">    as a dictionary. Each element can also be referenced using the first</span>
<span class="sd">    token in the expression as its key. Useful for tabular report</span>
<span class="sd">    scraping when the first column can be used as a item key.</span>

<span class="sd">    Example::</span>

<span class="sd">        data_word = Word(alphas)</span>
<span class="sd">        label = data_word + FollowedBy(&#39;:&#39;)</span>
<span class="sd">        attr_expr = Group(label + Suppress(&#39;:&#39;) + OneOrMore(data_word).setParseAction(&#39; &#39;.join))</span>

<span class="sd">        text = &quot;shape: SQUARE posn: upper left color: light blue texture: burlap&quot;</span>
<span class="sd">        attr_expr = (label + Suppress(&#39;:&#39;) + OneOrMore(data_word, stopOn=label).setParseAction(&#39; &#39;.join))</span>

<span class="sd">        # print attributes as plain groups</span>
<span class="sd">        print(OneOrMore(attr_expr).parseString(text).dump())</span>

<span class="sd">        # instead of OneOrMore(expr), parse using Dict(OneOrMore(Group(expr))) - Dict will auto-assign names</span>
<span class="sd">        result = Dict(OneOrMore(Group(attr_expr))).parseString(text)</span>
<span class="sd">        print(result.dump())</span>

<span class="sd">        # access named fields as dict entries, or output as dict</span>
<span class="sd">        print(result[&#39;shape&#39;])</span>
<span class="sd">        print(result.asDict())</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;shape&#39;, &#39;SQUARE&#39;, &#39;posn&#39;, &#39;upper left&#39;, &#39;color&#39;, &#39;light blue&#39;, &#39;texture&#39;, &#39;burlap&#39;]</span>
<span class="sd">        [[&#39;shape&#39;, &#39;SQUARE&#39;], [&#39;posn&#39;, &#39;upper left&#39;], [&#39;color&#39;, &#39;light blue&#39;], [&#39;texture&#39;, &#39;burlap&#39;]]</span>
<span class="sd">        - color: light blue</span>
<span class="sd">        - posn: upper left</span>
<span class="sd">        - shape: SQUARE</span>
<span class="sd">        - texture: burlap</span>
<span class="sd">        SQUARE</span>
<span class="sd">        {&#39;color&#39;: &#39;light blue&#39;, &#39;posn&#39;: &#39;upper left&#39;, &#39;texture&#39;: &#39;burlap&#39;, &#39;shape&#39;: &#39;SQUARE&#39;}</span>

<span class="sd">    See more examples at :class:`ParseResults` of accessing fields by results name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Dict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tok</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tokenlist</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">ikey</span> <span class="o">=</span> <span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ikey</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">ikey</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ParseResults</span><span class="p">):</span>
                <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">tok</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dictvalue</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># ParseResults(i)</span>
                <span class="k">del</span> <span class="n">dictvalue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dictvalue</span><span class="o">.</span><span class="n">haskeys</span><span class="p">()):</span>
                    <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tokenlist</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tokenlist</span>


<span class="k">class</span> <span class="nc">Suppress</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converter for ignoring the results of a parsed expression.</span>

<span class="sd">    Example::</span>

<span class="sd">        source = &quot;a, b, c,d&quot;</span>
<span class="sd">        wd = Word(alphas)</span>
<span class="sd">        wd_list1 = wd + ZeroOrMore(&#39;,&#39; + wd)</span>
<span class="sd">        print(wd_list1.parseString(source))</span>

<span class="sd">        # often, delimiters that are useful during parsing are just in the</span>
<span class="sd">        # way afterward - use Suppress to keep them out of the parsed output</span>
<span class="sd">        wd_list2 = wd + ZeroOrMore(Suppress(&#39;,&#39;) + wd)</span>
<span class="sd">        print(wd_list2.parseString(source))</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;a&#39;, &#39;,&#39;, &#39;b&#39;, &#39;,&#39;, &#39;c&#39;, &#39;,&#39;, &#39;d&#39;]</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>

<span class="sd">    (See also :class:`delimitedList`.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">suppress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">OnlyOnce</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper for parse actions, to ensure they are only called once.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methodCall</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callable</span> <span class="o">=</span> <span class="n">_trim_arity</span><span class="p">(</span><span class="n">methodCall</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">called</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">results</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">traceParseAction</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator for debugging parse actions.</span>

<span class="sd">    When the parse action is called, this decorator will print</span>
<span class="sd">    ``&quot;&gt;&gt; entering method-name(line:&lt;current_source_line&gt;, &lt;parse_location&gt;, &lt;matched_tokens&gt;)&quot;``.</span>
<span class="sd">    When the parse action completes, the decorator will print</span>
<span class="sd">    ``&quot;&lt;&lt;&quot;`` followed by the returned value, or any exception that the parse action raised.</span>

<span class="sd">    Example::</span>

<span class="sd">        wd = Word(alphas)</span>

<span class="sd">        @traceParseAction</span>
<span class="sd">        def remove_duplicate_chars(tokens):</span>
<span class="sd">            return &#39;&#39;.join(sorted(set(&#39;&#39;.join(tokens))))</span>

<span class="sd">        wds = OneOrMore(wd).setParseAction(remove_duplicate_chars)</span>
<span class="sd">        print(wds.parseString(&quot;slkdjs sld sldd sdlf sdljf&quot;))</span>

<span class="sd">    prints::</span>

<span class="sd">        &gt;&gt;entering remove_duplicate_chars(line: &#39;slkdjs sld sldd sdlf sdljf&#39;, 0, ([&#39;slkdjs&#39;, &#39;sld&#39;, &#39;sldd&#39;, &#39;sdlf&#39;, &#39;sdljf&#39;], {}))</span>
<span class="sd">        &lt;&lt;leaving remove_duplicate_chars (ret: &#39;dfjkls&#39;)</span>
<span class="sd">        [&#39;dfjkls&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">_trim_arity</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">z</span><span class="p">(</span><span class="o">*</span><span class="n">paArgs</span><span class="p">):</span>
        <span class="n">thisFunc</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">paArgs</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paArgs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">thisFunc</span> <span class="o">=</span> <span class="n">paArgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">thisFunc</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&gt;&gt;entering </span><span class="si">%s</span><span class="s2">(line: &#39;</span><span class="si">%s</span><span class="s2">&#39;, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">thisFunc</span><span class="p">,</span> <span class="n">line</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">paArgs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;&lt;leaving </span><span class="si">%s</span><span class="s2"> (exception: </span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">thisFunc</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>
            <span class="k">raise</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;&lt;leaving </span><span class="si">%s</span><span class="s2"> (ret: </span><span class="si">%r</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">thisFunc</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">z</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">z</span>

<span class="c1">#</span>
<span class="c1"># global helpers</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">delimitedList</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to define a delimited list of expressions - the delimiter</span>
<span class="sd">    defaults to &#39;,&#39;. By default, the list elements and delimiters can</span>
<span class="sd">    have intervening whitespace, and comments, but this can be</span>
<span class="sd">    overridden by passing ``combine=True`` in the constructor. If</span>
<span class="sd">    ``combine`` is set to ``True``, the matching tokens are</span>
<span class="sd">    returned as a single token string, with the delimiters included;</span>
<span class="sd">    otherwise, the matching tokens are returned as a list of tokens,</span>
<span class="sd">    with the delimiters suppressed.</span>

<span class="sd">    Example::</span>

<span class="sd">        delimitedList(Word(alphas)).parseString(&quot;aa,bb,cc&quot;) # -&gt; [&#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;]</span>
<span class="sd">        delimitedList(Word(hexnums), delim=&#39;:&#39;, combine=True).parseString(&quot;AA:BB:CC:DD:EE&quot;) # -&gt; [&#39;AA:BB:CC:DD:EE&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dlName</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; [&quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">delim</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]...&quot;</span>
    <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Combine</span><span class="p">(</span><span class="n">expr</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">delim</span> <span class="o">+</span> <span class="n">expr</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="n">dlName</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">expr</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="n">delim</span><span class="p">)</span> <span class="o">+</span> <span class="n">expr</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="n">dlName</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">countedArray</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">intExpr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to define a counted list of expressions.</span>

<span class="sd">    This helper defines a pattern of the form::</span>

<span class="sd">        integer expr expr expr...</span>

<span class="sd">    where the leading integer tells how many expr expressions follow.</span>
<span class="sd">    The matched tokens returns the array of expr tokens as a list - the</span>
<span class="sd">    leading count token is suppressed.</span>

<span class="sd">    If ``intExpr`` is specified, it should be a pyparsing expression</span>
<span class="sd">    that produces an integer value.</span>

<span class="sd">    Example::</span>

<span class="sd">        countedArray(Word(alphas)).parseString(&#39;2 ab cd ef&#39;)  # -&gt; [&#39;ab&#39;, &#39;cd&#39;]</span>

<span class="sd">        # in this parser, the leading integer value is given in binary,</span>
<span class="sd">        # &#39;10&#39; indicating that 2 values are in the array</span>
<span class="sd">        binaryConstant = Word(&#39;01&#39;).setParseAction(lambda t: int(t[0], 2))</span>
<span class="sd">        countedArray(Word(alphas), intExpr=binaryConstant).parseString(&#39;10 ab cd ef&#39;)  # -&gt; [&#39;ab&#39;, &#39;cd&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arrayExpr</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">countFieldParseAction</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">arrayExpr</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="ow">and</span> <span class="n">Group</span><span class="p">(</span><span class="n">And</span><span class="p">([</span><span class="n">expr</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="n">Group</span><span class="p">(</span><span class="n">empty</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">intExpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">intExpr</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">intExpr</span> <span class="o">=</span> <span class="n">intExpr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">intExpr</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;arrayLen&quot;</span><span class="p">)</span>
    <span class="n">intExpr</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">countFieldParseAction</span><span class="p">,</span> <span class="n">callDuringTry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">intExpr</span> <span class="o">+</span> <span class="n">arrayExpr</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;(len) &#39;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_flatten</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_flatten</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">matchPreviousLiteral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to define an expression that is indirectly defined from</span>
<span class="sd">    the tokens matched in a previous expression, that is, it looks for</span>
<span class="sd">    a &#39;repeat&#39; of a previous expression.  For example::</span>

<span class="sd">        first = Word(nums)</span>
<span class="sd">        second = matchPreviousLiteral(first)</span>
<span class="sd">        matchExpr = first + &quot;:&quot; + second</span>

<span class="sd">    will match ``&quot;1:1&quot;``, but not ``&quot;1:2&quot;``.  Because this</span>
<span class="sd">    matches a previous literal, will also match the leading</span>
<span class="sd">    ``&quot;1:1&quot;`` in ``&quot;1:10&quot;``. If this is not desired, use</span>
<span class="sd">    :class:`matchPreviousExpr`. Do *not* use with packrat parsing</span>
<span class="sd">    enabled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rep</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">copyTokenToRepeater</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># flatten t tokens</span>
                <span class="n">tflat</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">asList</span><span class="p">())</span>
                <span class="n">rep</span> <span class="o">&lt;&lt;</span> <span class="n">And</span><span class="p">(</span><span class="n">Literal</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tflat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rep</span> <span class="o">&lt;&lt;</span> <span class="n">Empty</span><span class="p">()</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">copyTokenToRepeater</span><span class="p">,</span> <span class="n">callDuringTry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rep</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;(prev) &#39;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rep</span>

<span class="k">def</span> <span class="nf">matchPreviousExpr</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to define an expression that is indirectly defined from</span>
<span class="sd">    the tokens matched in a previous expression, that is, it looks for</span>
<span class="sd">    a &#39;repeat&#39; of a previous expression.  For example::</span>

<span class="sd">        first = Word(nums)</span>
<span class="sd">        second = matchPreviousExpr(first)</span>
<span class="sd">        matchExpr = first + &quot;:&quot; + second</span>

<span class="sd">    will match ``&quot;1:1&quot;``, but not ``&quot;1:2&quot;``.  Because this</span>
<span class="sd">    matches by expressions, will *not* match the leading ``&quot;1:1&quot;``</span>
<span class="sd">    in ``&quot;1:10&quot;``; the expressions are evaluated first, and then</span>
<span class="sd">    compared, so ``&quot;1&quot;`` is compared with ``&quot;10&quot;``. Do *not* use</span>
<span class="sd">    with packrat parsing enabled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rep</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">rep</span> <span class="o">&lt;&lt;=</span> <span class="n">e2</span>
    <span class="k">def</span> <span class="nf">copyTokenToRepeater</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">matchTokens</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">asList</span><span class="p">())</span>
        <span class="k">def</span> <span class="nf">mustMatchTheseTokens</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">theseTokens</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">asList</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">theseTokens</span> <span class="o">!=</span> <span class="n">matchTokens</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">rep</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">mustMatchTheseTokens</span><span class="p">,</span> <span class="n">callDuringTry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">copyTokenToRepeater</span><span class="p">,</span> <span class="n">callDuringTry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rep</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;(prev) &#39;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rep</span>

<span class="k">def</span> <span class="nf">_escapeRegexRangeChars</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="c1"># ~  escape these chars: ^-[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="sa">r</span><span class="s2">&quot;\^-[]&quot;</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">_bslash</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\n&quot;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\t&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">oneOf</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="n">caseless</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useRegex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">asKeyword</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to quickly define a set of alternative Literals, and makes</span>
<span class="sd">    sure to do longest-first testing when there is a conflict,</span>
<span class="sd">    regardless of the input order, but returns</span>
<span class="sd">    a :class:`MatchFirst` for best performance.</span>

<span class="sd">    Parameters:</span>

<span class="sd">     - strs - a string of space-delimited literals, or a collection of</span>
<span class="sd">       string literals</span>
<span class="sd">     - caseless - (default= ``False``) - treat all literals as</span>
<span class="sd">       caseless</span>
<span class="sd">     - useRegex - (default= ``True``) - as an optimization, will</span>
<span class="sd">       generate a Regex object; otherwise, will generate</span>
<span class="sd">       a :class:`MatchFirst` object (if ``caseless=True`` or ``asKeyword=True``, or if</span>
<span class="sd">       creating a :class:`Regex` raises an exception)</span>
<span class="sd">     - asKeyword - (default=``False``) - enforce Keyword-style matching on the</span>
<span class="sd">       generated expressions</span>

<span class="sd">    Example::</span>

<span class="sd">        comp_oper = oneOf(&quot;&lt; = &gt; &lt;= &gt;= !=&quot;)</span>
<span class="sd">        var = Word(alphas)</span>
<span class="sd">        number = Word(nums)</span>
<span class="sd">        term = var | number</span>
<span class="sd">        comparison_expr = term + comp_oper + term</span>
<span class="sd">        print(comparison_expr.searchString(&quot;B = 12  AA=23 B&lt;=AA AA&gt;12&quot;))</span>

<span class="sd">    prints::</span>

<span class="sd">        [[&#39;B&#39;, &#39;=&#39;, &#39;12&#39;], [&#39;AA&#39;, &#39;=&#39;, &#39;23&#39;], [&#39;B&#39;, &#39;&lt;=&#39;, &#39;AA&#39;], [&#39;AA&#39;, &#39;&gt;&#39;, &#39;12&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">caseless</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;More than one string argument passed to oneOf, pass &quot;</span>
                      <span class="s2">&quot;choices as a list or space-delimited string&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">caseless</span><span class="p">:</span>
        <span class="n">isequal</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">upper</span><span class="p">()))</span>
        <span class="n">parseElementClass</span> <span class="o">=</span> <span class="n">CaselessKeyword</span> <span class="k">if</span> <span class="n">asKeyword</span> <span class="k">else</span> <span class="n">CaselessLiteral</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">isequal</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="n">parseElementClass</span> <span class="o">=</span> <span class="n">Keyword</span> <span class="k">if</span> <span class="n">asKeyword</span> <span class="k">else</span> <span class="n">Literal</span>

    <span class="n">symbols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">strs</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Invalid argument to oneOf, expected string or iterable&quot;</span><span class="p">,</span>
                      <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NoMatch</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">asKeyword</span><span class="p">:</span>
        <span class="c1"># if not producing keywords, need to reorder to take care to avoid masking</span>
        <span class="c1"># longer choices with shorter ones</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">other</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]):</span>
                <span class="k">if</span> <span class="n">isequal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">cur</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">symbols</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">masks</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">symbols</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">symbols</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">caseless</span> <span class="ow">or</span> <span class="n">asKeyword</span><span class="p">)</span> <span class="ow">and</span> <span class="n">useRegex</span><span class="p">:</span>
        <span class="c1"># ~ print (strs, &quot;-&gt;&quot;, &quot;|&quot;.join([_escapeRegexChars(sym) for sym in symbols]))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">symbols</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">Regex</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Regex</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Exception creating Regex for oneOf, building MatchFirst&quot;</span><span class="p">,</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># last resort, just use MatchFirst</span>
    <span class="k">return</span> <span class="n">MatchFirst</span><span class="p">(</span><span class="n">parseElementClass</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">dictOf</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to easily and clearly define a dictionary by specifying</span>
<span class="sd">    the respective patterns for the key and value.  Takes care of</span>
<span class="sd">    defining the :class:`Dict`, :class:`ZeroOrMore`, and</span>
<span class="sd">    :class:`Group` tokens in the proper order.  The key pattern</span>
<span class="sd">    can include delimiting markers or punctuation, as long as they are</span>
<span class="sd">    suppressed, thereby leaving the significant key text.  The value</span>
<span class="sd">    pattern can include named results, so that the :class:`Dict` results</span>
<span class="sd">    can include named token fields.</span>

<span class="sd">    Example::</span>

<span class="sd">        text = &quot;shape: SQUARE posn: upper left color: light blue texture: burlap&quot;</span>
<span class="sd">        attr_expr = (label + Suppress(&#39;:&#39;) + OneOrMore(data_word, stopOn=label).setParseAction(&#39; &#39;.join))</span>
<span class="sd">        print(OneOrMore(attr_expr).parseString(text).dump())</span>

<span class="sd">        attr_label = label</span>
<span class="sd">        attr_value = Suppress(&#39;:&#39;) + OneOrMore(data_word, stopOn=label).setParseAction(&#39; &#39;.join)</span>

<span class="sd">        # similar to Dict, but simpler call format</span>
<span class="sd">        result = dictOf(attr_label, attr_value).parseString(text)</span>
<span class="sd">        print(result.dump())</span>
<span class="sd">        print(result[&#39;shape&#39;])</span>
<span class="sd">        print(result.shape)  # object attribute access works too</span>
<span class="sd">        print(result.asDict())</span>

<span class="sd">    prints::</span>

<span class="sd">        [[&#39;shape&#39;, &#39;SQUARE&#39;], [&#39;posn&#39;, &#39;upper left&#39;], [&#39;color&#39;, &#39;light blue&#39;], [&#39;texture&#39;, &#39;burlap&#39;]]</span>
<span class="sd">        - color: light blue</span>
<span class="sd">        - posn: upper left</span>
<span class="sd">        - shape: SQUARE</span>
<span class="sd">        - texture: burlap</span>
<span class="sd">        SQUARE</span>
<span class="sd">        SQUARE</span>
<span class="sd">        {&#39;color&#39;: &#39;light blue&#39;, &#39;shape&#39;: &#39;SQUARE&#39;, &#39;posn&#39;: &#39;upper left&#39;, &#39;texture&#39;: &#39;burlap&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Dict</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="n">Group</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="n">value</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">originalTextFor</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">asString</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to return the original, untokenized text for a given</span>
<span class="sd">    expression.  Useful to restore the parsed fields of an HTML start</span>
<span class="sd">    tag into the raw tag text itself, or to revert separate tokens with</span>
<span class="sd">    intervening whitespace back to the original matching input text. By</span>
<span class="sd">    default, returns astring containing the original parsed text.</span>

<span class="sd">    If the optional ``asString`` argument is passed as</span>
<span class="sd">    ``False``, then the return value is</span>
<span class="sd">    a :class:`ParseResults` containing any results names that</span>
<span class="sd">    were originally matched, and a single token containing the original</span>
<span class="sd">    matched text from the input string.  So if the expression passed to</span>
<span class="sd">    :class:`originalTextFor` contains expressions with defined</span>
<span class="sd">    results names, you must set ``asString`` to ``False`` if you</span>
<span class="sd">    want to preserve those results name values.</span>

<span class="sd">    Example::</span>

<span class="sd">        src = &quot;this is test &lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt; normal text &quot;</span>
<span class="sd">        for tag in (&quot;b&quot;, &quot;i&quot;):</span>
<span class="sd">            opener, closer = makeHTMLTags(tag)</span>
<span class="sd">            patt = originalTextFor(opener + SkipTo(closer) + closer)</span>
<span class="sd">            print(patt.searchString(src)[0])</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;&lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt;&#39;]</span>
<span class="sd">        [&#39;&lt;i&gt;text&lt;/i&gt;&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">locMarker</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">loc</span><span class="p">)</span>
    <span class="n">endlocMarker</span> <span class="o">=</span> <span class="n">locMarker</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">endlocMarker</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">locMarker</span><span class="p">(</span><span class="s2">&quot;_original_start&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">expr</span> <span class="o">+</span> <span class="n">endlocMarker</span><span class="p">(</span><span class="s2">&quot;_original_end&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">asString</span><span class="p">:</span>
        <span class="n">extractText</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">_original_start</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">_original_end</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">extractText</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">t</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_original_start&#39;</span><span class="p">):</span><span class="n">t</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_original_end&#39;</span><span class="p">)]]</span>
    <span class="n">matchExpr</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">extractText</span><span class="p">)</span>
    <span class="n">matchExpr</span><span class="o">.</span><span class="n">ignoreExprs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">ignoreExprs</span>
    <span class="k">return</span> <span class="n">matchExpr</span>

<span class="k">def</span> <span class="nf">ungroup</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to undo pyparsing&#39;s default grouping of And expressions,</span>
<span class="sd">    even if all but one are non-empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">TokenConverter</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">locatedExpr</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to decorate a returned token with its starting and ending</span>
<span class="sd">    locations in the input string.</span>

<span class="sd">    This helper adds the following results names:</span>

<span class="sd">     - locn_start = location where matched expression begins</span>
<span class="sd">     - locn_end = location where matched expression ends</span>
<span class="sd">     - value = the actual parsed results</span>

<span class="sd">    Be careful if the input text contains ``&lt;TAB&gt;`` characters, you</span>
<span class="sd">    may want to call :class:`ParserElement.parseWithTabs`</span>

<span class="sd">    Example::</span>

<span class="sd">        wd = Word(alphas)</span>
<span class="sd">        for match in locatedExpr(wd).searchString(&quot;ljsdf123lksdjjf123lkkjj1222&quot;):</span>
<span class="sd">            print(match)</span>

<span class="sd">    prints::</span>

<span class="sd">        [[0, &#39;ljsdf&#39;, 5]]</span>
<span class="sd">        [[8, &#39;lksdjjf&#39;, 15]]</span>
<span class="sd">        [[18, &#39;lkkjj&#39;, 23]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">locator</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">l</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Group</span><span class="p">(</span><span class="n">locator</span><span class="p">(</span><span class="s2">&quot;locn_start&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">expr</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">locator</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()(</span><span class="s2">&quot;locn_end&quot;</span><span class="p">))</span>


<span class="c1"># convenience constants for positional expressions</span>
<span class="n">empty</span>       <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;empty&quot;</span><span class="p">)</span>
<span class="n">lineStart</span>   <span class="o">=</span> <span class="n">LineStart</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;lineStart&quot;</span><span class="p">)</span>
<span class="n">lineEnd</span>     <span class="o">=</span> <span class="n">LineEnd</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;lineEnd&quot;</span><span class="p">)</span>
<span class="n">stringStart</span> <span class="o">=</span> <span class="n">StringStart</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;stringStart&quot;</span><span class="p">)</span>
<span class="n">stringEnd</span>   <span class="o">=</span> <span class="n">StringEnd</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;stringEnd&quot;</span><span class="p">)</span>

<span class="n">_escapedPunc</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">_bslash</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\[]-*.$+^?()~ &quot;</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="n">_escapedHexChar</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">0?[xX][0-9a-fA-F]+&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">unichr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\0x&#39;</span><span class="p">),</span> <span class="mi">16</span><span class="p">)))</span>
<span class="n">_escapedOctChar</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">0[0-7]+&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">unichr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">8</span><span class="p">)))</span>
<span class="n">_singleChar</span> <span class="o">=</span> <span class="n">_escapedPunc</span> <span class="o">|</span> <span class="n">_escapedHexChar</span> <span class="o">|</span> <span class="n">_escapedOctChar</span> <span class="o">|</span> <span class="n">CharsNotIn</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\]&#39;</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">_charRange</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">_singleChar</span> <span class="o">+</span> <span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">_singleChar</span><span class="p">)</span>
<span class="n">_reBracketExpr</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="s2">&quot;^&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;negate&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="n">_charRange</span> <span class="o">|</span> <span class="n">_singleChar</span><span class="p">))</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;body&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>

<span class="k">def</span> <span class="nf">srange</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Helper to easily define string ranges for use in Word</span>
<span class="sd">    construction. Borrows syntax from regexp &#39;[]&#39; string range</span>
<span class="sd">    definitions::</span>

<span class="sd">        srange(&quot;[0-9]&quot;)   -&gt; &quot;0123456789&quot;</span>
<span class="sd">        srange(&quot;[a-z]&quot;)   -&gt; &quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="sd">        srange(&quot;[a-z$_]&quot;) -&gt; &quot;abcdefghijklmnopqrstuvwxyz$_&quot;</span>

<span class="sd">    The input string must be enclosed in []&#39;s, and the returned string</span>
<span class="sd">    is the expanded character set joined into a single string. The</span>
<span class="sd">    values enclosed in the []&#39;s may be:</span>

<span class="sd">     - a single character</span>
<span class="sd">     - an escaped character with a leading backslash (such as ``\-``</span>
<span class="sd">       or ``\]``)</span>
<span class="sd">     - an escaped hex character with a leading ``&#39;\x&#39;``</span>
<span class="sd">       (``\x21``, which is a ``&#39;!&#39;`` character) (``\0x##``</span>
<span class="sd">       is also supported for backwards compatibility)</span>
<span class="sd">     - an escaped octal character with a leading ``&#39;\0&#39;``</span>
<span class="sd">       (``\041``, which is a ``&#39;!&#39;`` character)</span>
<span class="sd">     - a range of any of the above, separated by a dash (``&#39;a-z&#39;``,</span>
<span class="sd">       etc.)</span>
<span class="sd">     - any combination of the above (``&#39;aeiouy&#39;``,</span>
<span class="sd">       ``&#39;a-zA-Z0-9_$&#39;``, etc.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_expanded</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unichr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">ord</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_expanded</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">_reBracketExpr</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">matchOnlyAtCol</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper method for defining parse actions that require matching at</span>
<span class="sd">    a specific column in the input text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">verifyCol</span><span class="p">(</span><span class="n">strg</span><span class="p">,</span> <span class="n">locn</span><span class="p">,</span> <span class="n">toks</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">col</span><span class="p">(</span><span class="n">locn</span><span class="p">,</span> <span class="n">strg</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">strg</span><span class="p">,</span> <span class="n">locn</span><span class="p">,</span> <span class="s2">&quot;matched token not at column </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">verifyCol</span>

<span class="k">def</span> <span class="nf">replaceWith</span><span class="p">(</span><span class="n">replStr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper method for common parse actions that simply return</span>
<span class="sd">    a literal value.  Especially useful when used with</span>
<span class="sd">    :class:`transformString&lt;ParserElement.transformString&gt;` ().</span>

<span class="sd">    Example::</span>

<span class="sd">        num = Word(nums).setParseAction(lambda toks: int(toks[0]))</span>
<span class="sd">        na = oneOf(&quot;N/A NA&quot;).setParseAction(replaceWith(math.nan))</span>
<span class="sd">        term = na | num</span>

<span class="sd">        OneOrMore(term).parseString(&quot;324 234 N/A 234&quot;) # -&gt; [324, 234, nan, 234]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="p">[</span><span class="n">replStr</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">removeQuotes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper parse action for removing quotation marks from parsed</span>
<span class="sd">    quoted strings.</span>

<span class="sd">    Example::</span>

<span class="sd">        # by default, quotation marks are included in parsed results</span>
<span class="sd">        quotedString.parseString(&quot;&#39;Now is the Winter of our Discontent&#39;&quot;) # -&gt; [&quot;&#39;Now is the Winter of our Discontent&#39;&quot;]</span>

<span class="sd">        # use removeQuotes to strip quotation marks from parsed results</span>
<span class="sd">        quotedString.setParseAction(removeQuotes)</span>
<span class="sd">        quotedString.parseString(&quot;&#39;Now is the Winter of our Discontent&#39;&quot;) # -&gt; [&quot;Now is the Winter of our Discontent&quot;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">tokenMap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to define a parse action by mapping a function to all</span>
<span class="sd">    elements of a ParseResults list. If any additional args are passed,</span>
<span class="sd">    they are forwarded to the given function as additional arguments</span>
<span class="sd">    after the token, as in</span>
<span class="sd">    ``hex_integer = Word(hexnums).setParseAction(tokenMap(int, 16))``,</span>
<span class="sd">    which will convert the parsed data to an integer using base 16.</span>

<span class="sd">    Example (compare the last to example in :class:`ParserElement.transformString`::</span>

<span class="sd">        hex_ints = OneOrMore(Word(hexnums)).setParseAction(tokenMap(int, 16))</span>
<span class="sd">        hex_ints.runTests(&#39;&#39;&#39;</span>
<span class="sd">            00 11 22 aa FF 0a 0d 1a</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">        upperword = Word(alphas).setParseAction(tokenMap(str.upper))</span>
<span class="sd">        OneOrMore(upperword).runTests(&#39;&#39;&#39;</span>
<span class="sd">            my kingdom for a horse</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">        wd = Word(alphas).setParseAction(tokenMap(str.title))</span>
<span class="sd">        OneOrMore(wd).setParseAction(&#39; &#39;.join).runTests(&#39;&#39;&#39;</span>
<span class="sd">            now is the winter of our discontent made glorious summer by this sun of york</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">    prints::</span>

<span class="sd">        00 11 22 aa FF 0a 0d 1a</span>
<span class="sd">        [0, 17, 34, 170, 255, 10, 13, 26]</span>

<span class="sd">        my kingdom for a horse</span>
<span class="sd">        [&#39;MY&#39;, &#39;KINGDOM&#39;, &#39;FOR&#39;, &#39;A&#39;, &#39;HORSE&#39;]</span>

<span class="sd">        now is the winter of our discontent made glorious summer by this sun of york</span>
<span class="sd">        [&#39;Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">tokn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">tokn</span> <span class="ow">in</span> <span class="n">t</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span>
                            <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__class__&#39;</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">pa</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">func_name</span>

    <span class="k">return</span> <span class="n">pa</span>

<span class="n">upcaseTokens</span> <span class="o">=</span> <span class="n">tokenMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
<span class="sd">&quot;&quot;&quot;(Deprecated) Helper parse action to convert tokens to upper case.</span>
<span class="sd">Deprecated in favor of :class:`pyparsing_common.upcaseTokens`&quot;&quot;&quot;</span>

<span class="n">downcaseTokens</span> <span class="o">=</span> <span class="n">tokenMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
<span class="sd">&quot;&quot;&quot;(Deprecated) Helper parse action to convert tokens to lower case.</span>
<span class="sd">Deprecated in favor of :class:`pyparsing_common.downcaseTokens`&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_makeTags</span><span class="p">(</span><span class="n">tagStr</span><span class="p">,</span> <span class="n">xml</span><span class="p">,</span>
              <span class="n">suppress_LT</span><span class="o">=</span><span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">),</span>
              <span class="n">suppress_GT</span><span class="o">=</span><span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Internal helper to construct opening and closing tag expressions, given a tag name&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tagStr</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="n">tagStr</span>
        <span class="n">tagStr</span> <span class="o">=</span> <span class="n">Keyword</span><span class="p">(</span><span class="n">tagStr</span><span class="p">,</span> <span class="n">caseless</span><span class="o">=</span><span class="ow">not</span> <span class="n">xml</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="n">tagStr</span><span class="o">.</span><span class="n">name</span>

    <span class="n">tagAttrName</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="n">alphanums</span> <span class="o">+</span> <span class="s2">&quot;_-:&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xml</span><span class="p">:</span>
        <span class="n">tagAttrValue</span> <span class="o">=</span> <span class="n">dblQuotedString</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">removeQuotes</span><span class="p">)</span>
        <span class="n">openTag</span> <span class="o">=</span> <span class="p">(</span><span class="n">suppress_LT</span>
                   <span class="o">+</span> <span class="n">tagStr</span><span class="p">(</span><span class="s2">&quot;tag&quot;</span><span class="p">)</span>
                   <span class="o">+</span> <span class="n">Dict</span><span class="p">(</span><span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">Group</span><span class="p">(</span><span class="n">tagAttrName</span> <span class="o">+</span> <span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">tagAttrValue</span><span class="p">)))</span>
                   <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">])(</span><span class="s2">&quot;empty&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
                   <span class="o">+</span> <span class="n">suppress_GT</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tagAttrValue</span> <span class="o">=</span> <span class="n">quotedString</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">removeQuotes</span><span class="p">)</span> <span class="o">|</span> <span class="n">Word</span><span class="p">(</span><span class="n">printables</span><span class="p">,</span> <span class="n">excludeChars</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>
        <span class="n">openTag</span> <span class="o">=</span> <span class="p">(</span><span class="n">suppress_LT</span>
                   <span class="o">+</span> <span class="n">tagStr</span><span class="p">(</span><span class="s2">&quot;tag&quot;</span><span class="p">)</span>
                   <span class="o">+</span> <span class="n">Dict</span><span class="p">(</span><span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">Group</span><span class="p">(</span><span class="n">tagAttrName</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">downcaseTokens</span><span class="p">)</span>
                                           <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">tagAttrValue</span><span class="p">))))</span>
                   <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">])(</span><span class="s2">&quot;empty&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span>
                   <span class="o">+</span> <span class="n">suppress_GT</span><span class="p">)</span>
    <span class="n">closeTag</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">_L</span><span class="p">(</span><span class="s2">&quot;&lt;/&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">tagStr</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">openTag</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">resname</span><span class="p">)</span>
    <span class="c1"># add start&lt;tagname&gt; results name in parse action now that ungrouped names are not reported at two levels</span>
    <span class="n">openTag</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="s2">&quot;start&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()),</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">()))</span>
    <span class="n">closeTag</span> <span class="o">=</span> <span class="n">closeTag</span><span class="p">(</span><span class="s2">&quot;end&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;&lt;/</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">resname</span><span class="p">)</span>
    <span class="n">openTag</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">resname</span>
    <span class="n">closeTag</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">resname</span>
    <span class="n">openTag</span><span class="o">.</span><span class="n">tag_body</span> <span class="o">=</span> <span class="n">SkipTo</span><span class="p">(</span><span class="n">closeTag</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">openTag</span><span class="p">,</span> <span class="n">closeTag</span>

<span class="k">def</span> <span class="nf">makeHTMLTags</span><span class="p">(</span><span class="n">tagStr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to construct opening and closing tag expressions for HTML,</span>
<span class="sd">    given a tag name. Matches tags in either upper or lower case,</span>
<span class="sd">    attributes with namespaces and with quoted or unquoted values.</span>

<span class="sd">    Example::</span>

<span class="sd">        text = &#39;&lt;td&gt;More info at the &lt;a href=&quot;https://github.com/pyparsing/pyparsing/wiki&quot;&gt;pyparsing&lt;/a&gt; wiki page&lt;/td&gt;&#39;</span>
<span class="sd">        # makeHTMLTags returns pyparsing expressions for the opening and</span>
<span class="sd">        # closing tags as a 2-tuple</span>
<span class="sd">        a, a_end = makeHTMLTags(&quot;A&quot;)</span>
<span class="sd">        link_expr = a + SkipTo(a_end)(&quot;link_text&quot;) + a_end</span>

<span class="sd">        for link in link_expr.searchString(text):</span>
<span class="sd">            # attributes in the &lt;A&gt; tag (like &quot;href&quot; shown here) are</span>
<span class="sd">            # also accessible as named results</span>
<span class="sd">            print(link.link_text, &#39;-&gt;&#39;, link.href)</span>

<span class="sd">    prints::</span>

<span class="sd">        pyparsing -&gt; https://github.com/pyparsing/pyparsing/wiki</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_makeTags</span><span class="p">(</span><span class="n">tagStr</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">makeXMLTags</span><span class="p">(</span><span class="n">tagStr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to construct opening and closing tag expressions for XML,</span>
<span class="sd">    given a tag name. Matches tags only in the given upper/lower case.</span>

<span class="sd">    Example: similar to :class:`makeHTMLTags`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_makeTags</span><span class="p">(</span><span class="n">tagStr</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">withAttribute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">attrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to create a validating parse action to be used with start</span>
<span class="sd">    tags created with :class:`makeXMLTags` or</span>
<span class="sd">    :class:`makeHTMLTags`. Use ``withAttribute`` to qualify</span>
<span class="sd">    a starting tag with a required attribute value, to avoid false</span>
<span class="sd">    matches on common tags such as ``&lt;TD&gt;`` or ``&lt;DIV&gt;``.</span>

<span class="sd">    Call ``withAttribute`` with a series of attribute names and</span>
<span class="sd">    values. Specify the list of filter attributes names and values as:</span>

<span class="sd">     - keyword arguments, as in ``(align=&quot;right&quot;)``, or</span>
<span class="sd">     - as an explicit dict with ``**`` operator, when an attribute</span>
<span class="sd">       name is also a Python reserved word, as in ``**{&quot;class&quot;:&quot;Customer&quot;, &quot;align&quot;:&quot;right&quot;}``</span>
<span class="sd">     - a list of name-value tuples, as in ``((&quot;ns1:class&quot;, &quot;Customer&quot;), (&quot;ns2:align&quot;, &quot;right&quot;))``</span>

<span class="sd">    For attribute names with a namespace prefix, you must use the second</span>
<span class="sd">    form.  Attribute names are matched insensitive to upper/lower case.</span>

<span class="sd">    If just testing for ``class`` (with or without a namespace), use</span>
<span class="sd">    :class:`withClass`.</span>

<span class="sd">    To verify that the attribute exists, but without specifying a value,</span>
<span class="sd">    pass ``withAttribute.ANY_VALUE`` as the value.</span>

<span class="sd">    Example::</span>

<span class="sd">        html = &#39;&#39;&#39;</span>
<span class="sd">            &lt;div&gt;</span>
<span class="sd">            Some text</span>
<span class="sd">            &lt;div type=&quot;grid&quot;&gt;1 4 0 1 0&lt;/div&gt;</span>
<span class="sd">            &lt;div type=&quot;graph&quot;&gt;1,3 2,3 1,1&lt;/div&gt;</span>
<span class="sd">            &lt;div&gt;this has no type&lt;/div&gt;</span>
<span class="sd">            &lt;/div&gt;</span>

<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        div,div_end = makeHTMLTags(&quot;div&quot;)</span>

<span class="sd">        # only match div tag having a type attribute with value &quot;grid&quot;</span>
<span class="sd">        div_grid = div().setParseAction(withAttribute(type=&quot;grid&quot;))</span>
<span class="sd">        grid_expr = div_grid + SkipTo(div | div_end)(&quot;body&quot;)</span>
<span class="sd">        for grid_header in grid_expr.searchString(html):</span>
<span class="sd">            print(grid_header.body)</span>

<span class="sd">        # construct a match with any div tag having a type attribute, regardless of the value</span>
<span class="sd">        div_any_type = div().setParseAction(withAttribute(type=withAttribute.ANY_VALUE))</span>
<span class="sd">        div_expr = div_any_type + SkipTo(div | div_end)(&quot;body&quot;)</span>
<span class="sd">        for div_header in div_expr.searchString(html):</span>
<span class="sd">            print(div_header.body)</span>

<span class="sd">    prints::</span>

<span class="sd">        1 4 0 1 0</span>

<span class="sd">        1 4 0 1 0</span>
<span class="sd">        1,3 2,3 1,1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">attrDict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">attrName</span><span class="p">,</span> <span class="n">attrValue</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attrName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="s2">&quot;no matching attribute &quot;</span> <span class="o">+</span> <span class="n">attrName</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attrValue</span> <span class="o">!=</span> <span class="n">withAttribute</span><span class="o">.</span><span class="n">ANY_VALUE</span> <span class="ow">and</span> <span class="n">tokens</span><span class="p">[</span><span class="n">attrName</span><span class="p">]</span> <span class="o">!=</span> <span class="n">attrValue</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="s2">&quot;attribute &#39;</span><span class="si">%s</span><span class="s2">&#39; has value &#39;</span><span class="si">%s</span><span class="s2">&#39;, must be &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span>
                                            <span class="p">(</span><span class="n">attrName</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="n">attrName</span><span class="p">],</span> <span class="n">attrValue</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pa</span>
<span class="n">withAttribute</span><span class="o">.</span><span class="n">ANY_VALUE</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">withClass</span><span class="p">(</span><span class="n">classname</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simplified version of :class:`withAttribute` when</span>
<span class="sd">    matching on a div class - made difficult because ``class`` is</span>
<span class="sd">    a reserved word in Python.</span>

<span class="sd">    Example::</span>

<span class="sd">        html = &#39;&#39;&#39;</span>
<span class="sd">            &lt;div&gt;</span>
<span class="sd">            Some text</span>
<span class="sd">            &lt;div class=&quot;grid&quot;&gt;1 4 0 1 0&lt;/div&gt;</span>
<span class="sd">            &lt;div class=&quot;graph&quot;&gt;1,3 2,3 1,1&lt;/div&gt;</span>
<span class="sd">            &lt;div&gt;this &amp;lt;div&amp;gt; has no class&lt;/div&gt;</span>
<span class="sd">            &lt;/div&gt;</span>

<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        div,div_end = makeHTMLTags(&quot;div&quot;)</span>
<span class="sd">        div_grid = div().setParseAction(withClass(&quot;grid&quot;))</span>

<span class="sd">        grid_expr = div_grid + SkipTo(div | div_end)(&quot;body&quot;)</span>
<span class="sd">        for grid_header in grid_expr.searchString(html):</span>
<span class="sd">            print(grid_header.body)</span>

<span class="sd">        div_any_type = div().setParseAction(withClass(withAttribute.ANY_VALUE))</span>
<span class="sd">        div_expr = div_any_type + SkipTo(div | div_end)(&quot;body&quot;)</span>
<span class="sd">        for div_header in div_expr.searchString(html):</span>
<span class="sd">            print(div_header.body)</span>

<span class="sd">    prints::</span>

<span class="sd">        1 4 0 1 0</span>

<span class="sd">        1 4 0 1 0</span>
<span class="sd">        1,3 2,3 1,1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">classattr</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:class&quot;</span> <span class="o">%</span> <span class="n">namespace</span> <span class="k">if</span> <span class="n">namespace</span> <span class="k">else</span> <span class="s2">&quot;class&quot;</span>
    <span class="k">return</span> <span class="n">withAttribute</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">classattr</span><span class="p">:</span> <span class="n">classname</span><span class="p">})</span>

<span class="n">opAssoc</span> <span class="o">=</span> <span class="n">SimpleNamespace</span><span class="p">()</span>
<span class="n">opAssoc</span><span class="o">.</span><span class="n">LEFT</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="n">opAssoc</span><span class="o">.</span><span class="n">RIGHT</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">infixNotation</span><span class="p">(</span><span class="n">baseExpr</span><span class="p">,</span> <span class="n">opList</span><span class="p">,</span> <span class="n">lpar</span><span class="o">=</span><span class="n">Suppress</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">),</span> <span class="n">rpar</span><span class="o">=</span><span class="n">Suppress</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Helper method for constructing grammars of expressions made up of</span>
<span class="sd">    operators working in a precedence hierarchy.  Operators may be unary</span>
<span class="sd">    or binary, left- or right-associative.  Parse actions can also be</span>
<span class="sd">    attached to operator expressions. The generated parser will also</span>
<span class="sd">    recognize the use of parentheses to override operator precedences</span>
<span class="sd">    (see example below).</span>

<span class="sd">    Note: if you define a deep operator list, you may see performance</span>
<span class="sd">    issues when using infixNotation. See</span>
<span class="sd">    :class:`ParserElement.enablePackrat` for a mechanism to potentially</span>
<span class="sd">    improve your parser performance.</span>

<span class="sd">    Parameters:</span>
<span class="sd">     - baseExpr - expression representing the most basic element for the</span>
<span class="sd">       nested</span>
<span class="sd">     - opList - list of tuples, one for each operator precedence level</span>
<span class="sd">       in the expression grammar; each tuple is of the form ``(opExpr,</span>
<span class="sd">       numTerms, rightLeftAssoc, parseAction)``, where:</span>

<span class="sd">       - opExpr is the pyparsing expression for the operator; may also</span>
<span class="sd">         be a string, which will be converted to a Literal; if numTerms</span>
<span class="sd">         is 3, opExpr is a tuple of two expressions, for the two</span>
<span class="sd">         operators separating the 3 terms</span>
<span class="sd">       - numTerms is the number of terms for this operator (must be 1,</span>
<span class="sd">         2, or 3)</span>
<span class="sd">       - rightLeftAssoc is the indicator whether the operator is right</span>
<span class="sd">         or left associative, using the pyparsing-defined constants</span>
<span class="sd">         ``opAssoc.RIGHT`` and ``opAssoc.LEFT``.</span>
<span class="sd">       - parseAction is the parse action to be associated with</span>
<span class="sd">         expressions matching this operator expression (the parse action</span>
<span class="sd">         tuple member may be omitted); if the parse action is passed</span>
<span class="sd">         a tuple or list of functions, this is equivalent to calling</span>
<span class="sd">         ``setParseAction(*fn)``</span>
<span class="sd">         (:class:`ParserElement.setParseAction`)</span>
<span class="sd">     - lpar - expression for matching left-parentheses</span>
<span class="sd">       (default= ``Suppress(&#39;(&#39;)``)</span>
<span class="sd">     - rpar - expression for matching right-parentheses</span>
<span class="sd">       (default= ``Suppress(&#39;)&#39;)``)</span>

<span class="sd">    Example::</span>

<span class="sd">        # simple example of four-function arithmetic with ints and</span>
<span class="sd">        # variable names</span>
<span class="sd">        integer = pyparsing_common.signed_integer</span>
<span class="sd">        varname = pyparsing_common.identifier</span>

<span class="sd">        arith_expr = infixNotation(integer | varname,</span>
<span class="sd">            [</span>
<span class="sd">            (&#39;-&#39;, 1, opAssoc.RIGHT),</span>
<span class="sd">            (oneOf(&#39;* /&#39;), 2, opAssoc.LEFT),</span>
<span class="sd">            (oneOf(&#39;+ -&#39;), 2, opAssoc.LEFT),</span>
<span class="sd">            ])</span>

<span class="sd">        arith_expr.runTests(&#39;&#39;&#39;</span>
<span class="sd">            5+3*6</span>
<span class="sd">            (5+3)*6</span>
<span class="sd">            -2--11</span>
<span class="sd">            &#39;&#39;&#39;, fullDump=False)</span>

<span class="sd">    prints::</span>

<span class="sd">        5+3*6</span>
<span class="sd">        [[5, &#39;+&#39;, [3, &#39;*&#39;, 6]]]</span>

<span class="sd">        (5+3)*6</span>
<span class="sd">        [[[5, &#39;+&#39;, 3], &#39;*&#39;, 6]]</span>

<span class="sd">        -2--11</span>
<span class="sd">        [[[&#39;-&#39;, 2], &#39;-&#39;, [&#39;-&#39;, 11]]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># captive version of FollowedBy that does not do parse actions or capture results names</span>
    <span class="k">class</span> <span class="nc">_FB</span><span class="p">(</span><span class="n">FollowedBy</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">tryParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="n">lastExpr</span> <span class="o">=</span> <span class="n">baseExpr</span> <span class="o">|</span> <span class="p">(</span><span class="n">lpar</span> <span class="o">+</span> <span class="n">ret</span> <span class="o">+</span> <span class="n">rpar</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">operDef</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">opList</span><span class="p">):</span>
        <span class="n">opExpr</span><span class="p">,</span> <span class="n">arity</span><span class="p">,</span> <span class="n">rightLeftAssoc</span><span class="p">,</span> <span class="n">pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">operDef</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">))[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">termName</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> term&quot;</span> <span class="o">%</span> <span class="n">opExpr</span> <span class="k">if</span> <span class="n">arity</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2"> term&quot;</span> <span class="o">%</span> <span class="n">opExpr</span>
        <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">opExpr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">opExpr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;if numterms=3, opExpr must be a tuple or list of two expressions&quot;</span><span class="p">)</span>
            <span class="n">opExpr1</span><span class="p">,</span> <span class="n">opExpr2</span> <span class="o">=</span> <span class="n">opExpr</span>
        <span class="n">thisExpr</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="n">termName</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rightLeftAssoc</span> <span class="o">==</span> <span class="n">opAssoc</span><span class="o">.</span><span class="n">LEFT</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">_FB</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">opExpr</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">_FB</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr</span> <span class="o">+</span> <span class="n">lastExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">opExpr</span> <span class="o">+</span> <span class="n">lastExpr</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">_FB</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">lastExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">lastExpr</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">matchExpr</span> <span class="o">=</span> <span class="p">(</span><span class="n">_FB</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr1</span> <span class="o">+</span> <span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr2</span> <span class="o">+</span> <span class="n">lastExpr</span><span class="p">)</span>
                             <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">opExpr1</span> <span class="o">+</span> <span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr2</span> <span class="o">+</span> <span class="n">lastExpr</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;operator must be unary (1), binary (2), or ternary (3)&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rightLeftAssoc</span> <span class="o">==</span> <span class="n">opAssoc</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># try to avoid LR with this extra test</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">opExpr</span><span class="p">,</span> <span class="n">Optional</span><span class="p">):</span>
                    <span class="n">opExpr</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">(</span><span class="n">opExpr</span><span class="p">)</span>
                <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">_FB</span><span class="p">(</span><span class="n">opExpr</span><span class="o">.</span><span class="n">expr</span> <span class="o">+</span> <span class="n">thisExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">opExpr</span> <span class="o">+</span> <span class="n">thisExpr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">_FB</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr</span> <span class="o">+</span> <span class="n">thisExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">opExpr</span> <span class="o">+</span> <span class="n">thisExpr</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">_FB</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">thisExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">thisExpr</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">matchExpr</span> <span class="o">=</span> <span class="p">(</span><span class="n">_FB</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr1</span> <span class="o">+</span> <span class="n">thisExpr</span> <span class="o">+</span> <span class="n">opExpr2</span> <span class="o">+</span> <span class="n">thisExpr</span><span class="p">)</span>
                             <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr1</span> <span class="o">+</span> <span class="n">thisExpr</span> <span class="o">+</span> <span class="n">opExpr2</span> <span class="o">+</span> <span class="n">thisExpr</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;operator must be unary (1), binary (2), or ternary (3)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;operator must indicate right or left associativity&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pa</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="n">matchExpr</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">matchExpr</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span>
        <span class="n">thisExpr</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">matchExpr</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="n">termName</span><span class="p">)</span> <span class="o">|</span> <span class="n">lastExpr</span><span class="p">)</span>
        <span class="n">lastExpr</span> <span class="o">=</span> <span class="n">thisExpr</span>
    <span class="n">ret</span> <span class="o">&lt;&lt;=</span> <span class="n">lastExpr</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="n">operatorPrecedence</span> <span class="o">=</span> <span class="n">infixNotation</span>
<span class="sd">&quot;&quot;&quot;(Deprecated) Former name of :class:`infixNotation`, will be</span>
<span class="sd">dropped in a future release.&quot;&quot;&quot;</span>

<span class="n">dblQuotedString</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&quot;(?:[^&quot;\n\r</span><span class="se">\\</span><span class="s1">]|(?:&quot;&quot;)|(?:</span><span class="se">\\</span><span class="s1">(?:[^x]|x[0-9a-fA-F]+)))*&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;string enclosed in double quotes&quot;</span><span class="p">)</span>
<span class="n">sglQuotedString</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&#39;(?:[^&#39;\n\r</span><span class="se">\\</span><span class="s2">]|(?:&#39;&#39;)|(?:</span><span class="se">\\</span><span class="s2">(?:[^x]|x[0-9a-fA-F]+)))*&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;string enclosed in single quotes&quot;</span><span class="p">)</span>
<span class="n">quotedString</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&quot;(?:[^&quot;\n\r</span><span class="se">\\</span><span class="s1">]|(?:&quot;&quot;)|(?:</span><span class="se">\\</span><span class="s1">(?:[^x]|x[0-9a-fA-F]+)))*&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span>
                       <span class="o">|</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&#39;(?:[^&#39;\n\r</span><span class="se">\\</span><span class="s2">]|(?:&#39;&#39;)|(?:</span><span class="se">\\</span><span class="s2">(?:[^x]|x[0-9a-fA-F]+)))*&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;quotedString using single or double quotes&quot;</span><span class="p">)</span>
<span class="n">unicodeString</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">_L</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">quotedString</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;unicode string literal&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nestedExpr</span><span class="p">(</span><span class="n">opener</span><span class="o">=</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="n">closer</span><span class="o">=</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignoreExpr</span><span class="o">=</span><span class="n">quotedString</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;Helper method for defining nested lists enclosed in opening and</span>
<span class="sd">    closing delimiters (&quot;(&quot; and &quot;)&quot; are the default).</span>

<span class="sd">    Parameters:</span>
<span class="sd">     - opener - opening character for a nested list</span>
<span class="sd">       (default= ``&quot;(&quot;``); can also be a pyparsing expression</span>
<span class="sd">     - closer - closing character for a nested list</span>
<span class="sd">       (default= ``&quot;)&quot;``); can also be a pyparsing expression</span>
<span class="sd">     - content - expression for items within the nested lists</span>
<span class="sd">       (default= ``None``)</span>
<span class="sd">     - ignoreExpr - expression for ignoring opening and closing</span>
<span class="sd">       delimiters (default= :class:`quotedString`)</span>

<span class="sd">    If an expression is not provided for the content argument, the</span>
<span class="sd">    nested expression will capture all whitespace-delimited content</span>
<span class="sd">    between delimiters as a list of separate values.</span>

<span class="sd">    Use the ``ignoreExpr`` argument to define expressions that may</span>
<span class="sd">    contain opening or closing characters that should not be treated as</span>
<span class="sd">    opening or closing characters for nesting, such as quotedString or</span>
<span class="sd">    a comment expression.  Specify multiple expressions using an</span>
<span class="sd">    :class:`Or` or :class:`MatchFirst`. The default is</span>
<span class="sd">    :class:`quotedString`, but if no expressions are to be ignored, then</span>
<span class="sd">    pass ``None`` for this argument.</span>

<span class="sd">    Example::</span>

<span class="sd">        data_type = oneOf(&quot;void int short long char float double&quot;)</span>
<span class="sd">        decl_data_type = Combine(data_type + Optional(Word(&#39;*&#39;)))</span>
<span class="sd">        ident = Word(alphas+&#39;_&#39;, alphanums+&#39;_&#39;)</span>
<span class="sd">        number = pyparsing_common.number</span>
<span class="sd">        arg = Group(decl_data_type + ident)</span>
<span class="sd">        LPAR, RPAR = map(Suppress, &quot;()&quot;)</span>

<span class="sd">        code_body = nestedExpr(&#39;{&#39;, &#39;}&#39;, ignoreExpr=(quotedString | cStyleComment))</span>

<span class="sd">        c_function = (decl_data_type(&quot;type&quot;)</span>
<span class="sd">                      + ident(&quot;name&quot;)</span>
<span class="sd">                      + LPAR + Optional(delimitedList(arg), [])(&quot;args&quot;) + RPAR</span>
<span class="sd">                      + code_body(&quot;body&quot;))</span>
<span class="sd">        c_function.ignore(cStyleComment)</span>

<span class="sd">        source_code = &#39;&#39;&#39;</span>
<span class="sd">            int is_odd(int x) {</span>
<span class="sd">                return (x%2);</span>
<span class="sd">            }</span>

<span class="sd">            int dec_to_hex(char hchar) {</span>
<span class="sd">                if (hchar &gt;= &#39;0&#39; &amp;&amp; hchar &lt;= &#39;9&#39;) {</span>
<span class="sd">                    return (ord(hchar)-ord(&#39;0&#39;));</span>
<span class="sd">                } else {</span>
<span class="sd">                    return (10+ord(hchar)-ord(&#39;A&#39;));</span>
<span class="sd">                }</span>
<span class="sd">            }</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        for func in c_function.searchString(source_code):</span>
<span class="sd">            print(&quot;%(name)s (%(type)s) args: %(args)s&quot; % func)</span>


<span class="sd">    prints::</span>

<span class="sd">        is_odd (int) args: [[&#39;int&#39;, &#39;x&#39;]]</span>
<span class="sd">        dec_to_hex (int) args: [[&#39;char&#39;, &#39;hchar&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">opener</span> <span class="o">==</span> <span class="n">closer</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;opening and closing strings cannot be the same&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">content</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">opener</span><span class="p">,</span> <span class="n">basestring</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">closer</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">closer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ignoreExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="p">(</span><span class="n">Combine</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="o">~</span><span class="n">ignoreExpr</span>
                                                 <span class="o">+</span> <span class="n">CharsNotIn</span><span class="p">(</span><span class="n">opener</span>
                                                              <span class="o">+</span> <span class="n">closer</span>
                                                              <span class="o">+</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                                 <span class="p">)</span>
                                       <span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="p">(</span><span class="n">empty</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">+</span> <span class="n">CharsNotIn</span><span class="p">(</span><span class="n">opener</span>
                                                         <span class="o">+</span> <span class="n">closer</span>
                                                         <span class="o">+</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span>
                                                         <span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ignoreExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="p">(</span><span class="n">Combine</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="o">~</span><span class="n">ignoreExpr</span>
                                                 <span class="o">+</span> <span class="o">~</span><span class="n">Literal</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span>
                                                 <span class="o">+</span> <span class="o">~</span><span class="n">Literal</span><span class="p">(</span><span class="n">closer</span><span class="p">)</span>
                                                 <span class="o">+</span> <span class="n">CharsNotIn</span><span class="p">(</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                                       <span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="p">(</span><span class="n">Combine</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="o">~</span><span class="n">Literal</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span>
                                                 <span class="o">+</span> <span class="o">~</span><span class="n">Literal</span><span class="p">(</span><span class="n">closer</span><span class="p">)</span>
                                                 <span class="o">+</span> <span class="n">CharsNotIn</span><span class="p">(</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                                       <span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;opening and closing arguments must be strings if no content expression is given&quot;</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ignoreExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">&lt;&lt;=</span> <span class="n">Group</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">ignoreExpr</span> <span class="o">|</span> <span class="n">ret</span> <span class="o">|</span> <span class="n">content</span><span class="p">)</span> <span class="o">+</span> <span class="n">Suppress</span><span class="p">(</span><span class="n">closer</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">&lt;&lt;=</span> <span class="n">Group</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">ret</span> <span class="o">|</span> <span class="n">content</span><span class="p">)</span>  <span class="o">+</span> <span class="n">Suppress</span><span class="p">(</span><span class="n">closer</span><span class="p">))</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;nested </span><span class="si">%s%s</span><span class="s1"> expression&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">opener</span><span class="p">,</span> <span class="n">closer</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">indentedBlock</span><span class="p">(</span><span class="n">blockStatementExpr</span><span class="p">,</span> <span class="n">indentStack</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper method for defining space-delimited indentation blocks,</span>
<span class="sd">    such as those used to define block statements in Python source code.</span>

<span class="sd">    Parameters:</span>

<span class="sd">     - blockStatementExpr - expression defining syntax of statement that</span>
<span class="sd">       is repeated within the indented block</span>
<span class="sd">     - indentStack - list created by caller to manage indentation stack</span>
<span class="sd">       (multiple statementWithIndentedBlock expressions within a single</span>
<span class="sd">       grammar should share a common indentStack)</span>
<span class="sd">     - indent - boolean indicating whether block must be indented beyond</span>
<span class="sd">       the current level; set to False for block of left-most</span>
<span class="sd">       statements (default= ``True``)</span>

<span class="sd">    A valid block must contain at least one ``blockStatement``.</span>

<span class="sd">    Example::</span>

<span class="sd">        data = &#39;&#39;&#39;</span>
<span class="sd">        def A(z):</span>
<span class="sd">          A1</span>
<span class="sd">          B = 100</span>
<span class="sd">          G = A2</span>
<span class="sd">          A2</span>
<span class="sd">          A3</span>
<span class="sd">        B</span>
<span class="sd">        def BB(a,b,c):</span>
<span class="sd">          BB1</span>
<span class="sd">          def BBA():</span>
<span class="sd">            bba1</span>
<span class="sd">            bba2</span>
<span class="sd">            bba3</span>
<span class="sd">        C</span>
<span class="sd">        D</span>
<span class="sd">        def spam(x,y):</span>
<span class="sd">             def eggs(z):</span>
<span class="sd">                 pass</span>
<span class="sd">        &#39;&#39;&#39;</span>


<span class="sd">        indentStack = [1]</span>
<span class="sd">        stmt = Forward()</span>

<span class="sd">        identifier = Word(alphas, alphanums)</span>
<span class="sd">        funcDecl = (&quot;def&quot; + identifier + Group(&quot;(&quot; + Optional(delimitedList(identifier)) + &quot;)&quot;) + &quot;:&quot;)</span>
<span class="sd">        func_body = indentedBlock(stmt, indentStack)</span>
<span class="sd">        funcDef = Group(funcDecl + func_body)</span>

<span class="sd">        rvalue = Forward()</span>
<span class="sd">        funcCall = Group(identifier + &quot;(&quot; + Optional(delimitedList(rvalue)) + &quot;)&quot;)</span>
<span class="sd">        rvalue &lt;&lt; (funcCall | identifier | Word(nums))</span>
<span class="sd">        assignment = Group(identifier + &quot;=&quot; + rvalue)</span>
<span class="sd">        stmt &lt;&lt; (funcDef | assignment | identifier)</span>

<span class="sd">        module_body = OneOrMore(stmt)</span>

<span class="sd">        parseTree = module_body.parseString(data)</span>
<span class="sd">        parseTree.pprint()</span>

<span class="sd">    prints::</span>

<span class="sd">        [[&#39;def&#39;,</span>
<span class="sd">          &#39;A&#39;,</span>
<span class="sd">          [&#39;(&#39;, &#39;z&#39;, &#39;)&#39;],</span>
<span class="sd">          &#39;:&#39;,</span>
<span class="sd">          [[&#39;A1&#39;], [[&#39;B&#39;, &#39;=&#39;, &#39;100&#39;]], [[&#39;G&#39;, &#39;=&#39;, &#39;A2&#39;]], [&#39;A2&#39;], [&#39;A3&#39;]]],</span>
<span class="sd">         &#39;B&#39;,</span>
<span class="sd">         [&#39;def&#39;,</span>
<span class="sd">          &#39;BB&#39;,</span>
<span class="sd">          [&#39;(&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;)&#39;],</span>
<span class="sd">          &#39;:&#39;,</span>
<span class="sd">          [[&#39;BB1&#39;], [[&#39;def&#39;, &#39;BBA&#39;, [&#39;(&#39;, &#39;)&#39;], &#39;:&#39;, [[&#39;bba1&#39;], [&#39;bba2&#39;], [&#39;bba3&#39;]]]]]],</span>
<span class="sd">         &#39;C&#39;,</span>
<span class="sd">         &#39;D&#39;,</span>
<span class="sd">         [&#39;def&#39;,</span>
<span class="sd">          &#39;spam&#39;,</span>
<span class="sd">          [&#39;(&#39;, &#39;x&#39;, &#39;y&#39;, &#39;)&#39;],</span>
<span class="sd">          &#39;:&#39;,</span>
<span class="sd">          [[[&#39;def&#39;, &#39;eggs&#39;, [&#39;(&#39;, &#39;z&#39;, &#39;)&#39;], &#39;:&#39;, [[&#39;pass&#39;]]]]]]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">backup_stack</span> <span class="o">=</span> <span class="n">indentStack</span><span class="p">[:]</span>

    <span class="k">def</span> <span class="nf">reset_stack</span><span class="p">():</span>
        <span class="n">indentStack</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">backup_stack</span>

    <span class="k">def</span> <span class="nf">checkPeerIndent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="k">return</span>
        <span class="n">curCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curCol</span> <span class="o">!=</span> <span class="n">indentStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">curCol</span> <span class="o">&gt;</span> <span class="n">indentStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="s2">&quot;illegal nesting&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="s2">&quot;not a peer entry&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">checkSubIndent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">curCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curCol</span> <span class="o">&gt;</span> <span class="n">indentStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">indentStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curCol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="s2">&quot;not a subentry&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">checkUnindent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="k">return</span>
        <span class="n">curCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">indentStack</span> <span class="ow">and</span> <span class="n">curCol</span> <span class="ow">in</span> <span class="n">indentStack</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="s2">&quot;not an unindent&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curCol</span> <span class="o">&lt;</span> <span class="n">indentStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">indentStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="n">NL</span> <span class="o">=</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">LineEnd</span><span class="p">()</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">suppress</span><span class="p">(),</span> <span class="n">stopOn</span><span class="o">=</span><span class="n">StringEnd</span><span class="p">())</span>
    <span class="n">INDENT</span> <span class="o">=</span> <span class="p">(</span><span class="n">Empty</span><span class="p">()</span> <span class="o">+</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">checkSubIndent</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;INDENT&#39;</span><span class="p">)</span>
    <span class="n">PEER</span>   <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">checkPeerIndent</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">UNDENT</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">checkUnindent</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;UNINDENT&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">indent</span><span class="p">:</span>
        <span class="n">smExpr</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">Optional</span><span class="p">(</span><span class="n">NL</span><span class="p">)</span>
                       <span class="o">+</span> <span class="n">INDENT</span>
                       <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">PEER</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">blockStatementExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">NL</span><span class="p">),</span> <span class="n">stopOn</span><span class="o">=</span><span class="n">StringEnd</span><span class="p">())</span>
                       <span class="o">+</span> <span class="n">UNDENT</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">smExpr</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">Optional</span><span class="p">(</span><span class="n">NL</span><span class="p">)</span>
                       <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">PEER</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">blockStatementExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">NL</span><span class="p">),</span> <span class="n">stopOn</span><span class="o">=</span><span class="n">StringEnd</span><span class="p">())</span>
                       <span class="o">+</span> <span class="n">UNDENT</span><span class="p">)</span>
    <span class="n">smExpr</span><span class="o">.</span><span class="n">setFailAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">reset_stack</span><span class="p">())</span>
    <span class="n">blockStatementExpr</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">_bslash</span> <span class="o">+</span> <span class="n">LineEnd</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">smExpr</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;indented block&#39;</span><span class="p">)</span>

<span class="n">alphas8bit</span> <span class="o">=</span> <span class="n">srange</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]&quot;</span><span class="p">)</span>
<span class="n">punc8bit</span> <span class="o">=</span> <span class="n">srange</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[\0xa1-\0xbf\0xd7\0xf7]&quot;</span><span class="p">)</span>

<span class="n">anyOpenTag</span><span class="p">,</span> <span class="n">anyCloseTag</span> <span class="o">=</span> <span class="n">makeHTMLTags</span><span class="p">(</span><span class="n">Word</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="n">alphanums</span> <span class="o">+</span> <span class="s2">&quot;_:&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;any tag&#39;</span><span class="p">))</span>
<span class="n">_htmlEntityMap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="s2">&quot;gt lt amp nbsp quot apos&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="s1">&#39;&gt;&lt;&amp; &quot;</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="n">commonHTMLEntity</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">&#39;&amp;(?P&lt;entity&gt;&#39;</span> <span class="o">+</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_htmlEntityMap</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span><span class="s2">&quot;);&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;common HTML entity&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">replaceHTMLEntity</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper parser action to replace common HTML entities with their special characters&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_htmlEntityMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">entity</span><span class="p">)</span>

<span class="c1"># it&#39;s easy to get these comment structures wrong - they&#39;re very common, so may as well make them available</span>
<span class="n">cStyleComment</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;/\*(?:[^*]|\*(?!/))*&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;*/&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;C style comment&quot;</span><span class="p">)</span>
<span class="s2">&quot;Comment of the form ``/* ... */``&quot;</span>

<span class="n">htmlComment</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&lt;!--[\s\S]*?--&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;HTML comment&quot;</span><span class="p">)</span>
<span class="s2">&quot;Comment of the form ``&lt;!-- ... --&gt;``&quot;</span>

<span class="n">restOfLine</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;rest of line&quot;</span><span class="p">)</span>
<span class="n">dblSlashComment</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;//(?:</span><span class="se">\\</span><span class="s2">\n|[^\n])*&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;// comment&quot;</span><span class="p">)</span>
<span class="s2">&quot;Comment of the form ``// ... (to end of line)``&quot;</span>

<span class="n">cppStyleComment</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;/\*(?:[^*]|\*(?!/))*&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;*/&#39;</span> <span class="o">|</span> <span class="n">dblSlashComment</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;C++ style comment&quot;</span><span class="p">)</span>
<span class="s2">&quot;Comment of either form :class:`cStyleComment` or :class:`dblSlashComment`&quot;</span>

<span class="n">javaStyleComment</span> <span class="o">=</span> <span class="n">cppStyleComment</span>
<span class="s2">&quot;Same as :class:`cppStyleComment`&quot;</span>

<span class="n">pythonStyleComment</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;#.*&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;Python style comment&quot;</span><span class="p">)</span>
<span class="s2">&quot;Comment of the form ``# ... (to end of line)``&quot;</span>

<span class="n">_commasepitem</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="n">Word</span><span class="p">(</span><span class="n">printables</span><span class="p">,</span> <span class="n">excludeChars</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                                  <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Word</span><span class="p">(</span><span class="s2">&quot; </span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
                                             <span class="o">+</span> <span class="o">~</span><span class="n">Literal</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="o">~</span><span class="n">LineEnd</span><span class="p">())))</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;commaItem&quot;</span><span class="p">)</span>
<span class="n">commaSeparatedList</span> <span class="o">=</span> <span class="n">delimitedList</span><span class="p">(</span><span class="n">Optional</span><span class="p">(</span><span class="n">quotedString</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">|</span> <span class="n">_commasepitem</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;commaSeparatedList&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;(Deprecated) Predefined expression of 1 or more printable words or</span>
<span class="sd">quoted strings, separated by commas.</span>

<span class="sd">This expression is deprecated in favor of :class:`pyparsing_common.comma_separated_list`.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># some other useful expressions - using lower-case class name since we are really using this as a namespace</span>
<span class="k">class</span> <span class="nc">pyparsing_common</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Here are some common low-level expressions that may be useful in</span>
<span class="sd">    jump-starting parser development:</span>

<span class="sd">     - numeric forms (:class:`integers&lt;integer&gt;`, :class:`reals&lt;real&gt;`,</span>
<span class="sd">       :class:`scientific notation&lt;sci_real&gt;`)</span>
<span class="sd">     - common :class:`programming identifiers&lt;identifier&gt;`</span>
<span class="sd">     - network addresses (:class:`MAC&lt;mac_address&gt;`,</span>
<span class="sd">       :class:`IPv4&lt;ipv4_address&gt;`, :class:`IPv6&lt;ipv6_address&gt;`)</span>
<span class="sd">     - ISO8601 :class:`dates&lt;iso8601_date&gt;` and</span>
<span class="sd">       :class:`datetime&lt;iso8601_datetime&gt;`</span>
<span class="sd">     - :class:`UUID&lt;uuid&gt;`</span>
<span class="sd">     - :class:`comma-separated list&lt;comma_separated_list&gt;`</span>

<span class="sd">    Parse actions:</span>

<span class="sd">     - :class:`convertToInteger`</span>
<span class="sd">     - :class:`convertToFloat`</span>
<span class="sd">     - :class:`convertToDate`</span>
<span class="sd">     - :class:`convertToDatetime`</span>
<span class="sd">     - :class:`stripHTMLTags`</span>
<span class="sd">     - :class:`upcaseTokens`</span>
<span class="sd">     - :class:`downcaseTokens`</span>

<span class="sd">    Example::</span>

<span class="sd">        pyparsing_common.number.runTests(&#39;&#39;&#39;</span>
<span class="sd">            # any int or real number, returned as the appropriate type</span>
<span class="sd">            100</span>
<span class="sd">            -100</span>
<span class="sd">            +100</span>
<span class="sd">            3.14159</span>
<span class="sd">            6.02e23</span>
<span class="sd">            1e-12</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">        pyparsing_common.fnumber.runTests(&#39;&#39;&#39;</span>
<span class="sd">            # any int or real number, returned as float</span>
<span class="sd">            100</span>
<span class="sd">            -100</span>
<span class="sd">            +100</span>
<span class="sd">            3.14159</span>
<span class="sd">            6.02e23</span>
<span class="sd">            1e-12</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">        pyparsing_common.hex_integer.runTests(&#39;&#39;&#39;</span>
<span class="sd">            # hex numbers</span>
<span class="sd">            100</span>
<span class="sd">            FF</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">        pyparsing_common.fraction.runTests(&#39;&#39;&#39;</span>
<span class="sd">            # fractions</span>
<span class="sd">            1/2</span>
<span class="sd">            -3/4</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">        pyparsing_common.mixed_integer.runTests(&#39;&#39;&#39;</span>
<span class="sd">            # mixed fractions</span>
<span class="sd">            1</span>
<span class="sd">            1/2</span>
<span class="sd">            -3/4</span>
<span class="sd">            1-3/4</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">        import uuid</span>
<span class="sd">        pyparsing_common.uuid.setParseAction(tokenMap(uuid.UUID))</span>
<span class="sd">        pyparsing_common.uuid.runTests(&#39;&#39;&#39;</span>
<span class="sd">            # uuid</span>
<span class="sd">            12345678-1234-5678-1234-567812345678</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">    prints::</span>

<span class="sd">        # any int or real number, returned as the appropriate type</span>
<span class="sd">        100</span>
<span class="sd">        [100]</span>

<span class="sd">        -100</span>
<span class="sd">        [-100]</span>

<span class="sd">        +100</span>
<span class="sd">        [100]</span>

<span class="sd">        3.14159</span>
<span class="sd">        [3.14159]</span>

<span class="sd">        6.02e23</span>
<span class="sd">        [6.02e+23]</span>

<span class="sd">        1e-12</span>
<span class="sd">        [1e-12]</span>

<span class="sd">        # any int or real number, returned as float</span>
<span class="sd">        100</span>
<span class="sd">        [100.0]</span>

<span class="sd">        -100</span>
<span class="sd">        [-100.0]</span>

<span class="sd">        +100</span>
<span class="sd">        [100.0]</span>

<span class="sd">        3.14159</span>
<span class="sd">        [3.14159]</span>

<span class="sd">        6.02e23</span>
<span class="sd">        [6.02e+23]</span>

<span class="sd">        1e-12</span>
<span class="sd">        [1e-12]</span>

<span class="sd">        # hex numbers</span>
<span class="sd">        100</span>
<span class="sd">        [256]</span>

<span class="sd">        FF</span>
<span class="sd">        [255]</span>

<span class="sd">        # fractions</span>
<span class="sd">        1/2</span>
<span class="sd">        [0.5]</span>

<span class="sd">        -3/4</span>
<span class="sd">        [-0.75]</span>

<span class="sd">        # mixed fractions</span>
<span class="sd">        1</span>
<span class="sd">        [1]</span>

<span class="sd">        1/2</span>
<span class="sd">        [0.5]</span>

<span class="sd">        -3/4</span>
<span class="sd">        [-0.75]</span>

<span class="sd">        1-3/4</span>
<span class="sd">        [1.75]</span>

<span class="sd">        # uuid</span>
<span class="sd">        12345678-1234-5678-1234-567812345678</span>
<span class="sd">        [UUID(&#39;12345678-1234-5678-1234-567812345678&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">convertToInteger</span> <span class="o">=</span> <span class="n">tokenMap</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse action for converting parsed integers to Python int</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">convertToFloat</span> <span class="o">=</span> <span class="n">tokenMap</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse action for converting parsed numbers to Python float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">integer</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;integer&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToInteger</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;expression that parses an unsigned integer, returns an int&quot;&quot;&quot;</span>

    <span class="n">hex_integer</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">hexnums</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;hex integer&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">tokenMap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
    <span class="sd">&quot;&quot;&quot;expression that parses a hexadecimal integer, returns an int&quot;&quot;&quot;</span>

    <span class="n">signed_integer</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[+-]?\d+&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;signed integer&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToInteger</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;expression that parses an integer with optional leading sign, returns an int&quot;&quot;&quot;</span>

    <span class="n">fraction</span> <span class="o">=</span> <span class="p">(</span><span class="n">signed_integer</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToFloat</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">signed_integer</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToFloat</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;fraction&quot;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;fractional expression of an integer divided by an integer, returns a float&quot;&quot;&quot;</span>
    <span class="n">fraction</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">mixed_integer</span> <span class="o">=</span> <span class="p">(</span><span class="n">fraction</span> <span class="o">|</span> <span class="n">signed_integer</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Optional</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">suppress</span><span class="p">()</span> <span class="o">+</span> <span class="n">fraction</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;fraction or mixed integer-fraction&quot;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;mixed integer of the form &#39;integer - fraction&#39;, with optional leading integer, returns float&quot;&quot;&quot;</span>
    <span class="n">mixed_integer</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>

    <span class="n">real</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[+-]?(?:\d+\.\d*|\.\d+)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;real number&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToFloat</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;expression that parses a floating point number and returns a float&quot;&quot;&quot;</span>

    <span class="n">sci_real</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[+-]?(?:\d+(?:[eE][+-]?\d+)|(?:\d+\.\d*|\.\d+)(?:[eE][+-]?\d+)?)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;real number with scientific notation&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToFloat</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;expression that parses a floating point number with optional</span>
<span class="sd">    scientific notation and returns a float&quot;&quot;&quot;</span>

    <span class="c1"># streamlining this expression makes the docs nicer-looking</span>
    <span class="n">number</span> <span class="o">=</span> <span class="p">(</span><span class="n">sci_real</span> <span class="o">|</span> <span class="n">real</span> <span class="o">|</span> <span class="n">signed_integer</span><span class="p">)</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;any numeric expression, returns the corresponding Python type&quot;&quot;&quot;</span>

    <span class="n">fnumber</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[+-]?\d+\.?\d*([eE][+-]?\d+)?&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;fnumber&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToFloat</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;any int or real number, returned as float&quot;&quot;&quot;</span>

    <span class="n">identifier</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">alphas</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">alphanums</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;identifier&quot;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;typical code identifier (leading alpha or &#39;_&#39;, followed by 0 or more alphas, nums, or &#39;_&#39;)&quot;&quot;&quot;</span>

    <span class="n">ipv4_address</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2}))</span><span class="si">{3}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;IPv4 address&quot;</span><span class="p">)</span>
    <span class="s2">&quot;IPv4 address (``0.0.0.0 - 255.255.255.255``)&quot;</span>

    <span class="n">_ipv6_part</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[0-9a-fA-F]{1,4}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;hex_integer&quot;</span><span class="p">)</span>
    <span class="n">_full_ipv6_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">_ipv6_part</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">_ipv6_part</span><span class="p">)</span> <span class="o">*</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;full IPv6 address&quot;</span><span class="p">)</span>
    <span class="n">_short_ipv6_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">Optional</span><span class="p">(</span><span class="n">_ipv6_part</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">_ipv6_part</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
                           <span class="o">+</span> <span class="s2">&quot;::&quot;</span>
                           <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">_ipv6_part</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">_ipv6_part</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
                           <span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;short IPv6 address&quot;</span><span class="p">)</span>
    <span class="n">_short_ipv6_address</span><span class="o">.</span><span class="n">addCondition</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">t</span> <span class="k">if</span> <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">_ipv6_part</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">tt</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">_mixed_ipv6_address</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;::ffff:&quot;</span> <span class="o">+</span> <span class="n">ipv4_address</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;mixed IPv6 address&quot;</span><span class="p">)</span>
    <span class="n">ipv6_address</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">((</span><span class="n">_full_ipv6_address</span> <span class="o">|</span> <span class="n">_mixed_ipv6_address</span> <span class="o">|</span> <span class="n">_short_ipv6_address</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;IPv6 address&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;IPv6 address&quot;</span><span class="p">)</span>
    <span class="s2">&quot;IPv6 address (long, short, or mixed form)&quot;</span>

    <span class="n">mac_address</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[0-9a-fA-F]</span><span class="si">{2}</span><span class="s1">([:.-])[0-9a-fA-F]</span><span class="si">{2}</span><span class="s1">(?:\1[0-9a-fA-F]</span><span class="si">{2}</span><span class="s1">)</span><span class="si">{4}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;MAC address&quot;</span><span class="p">)</span>
    <span class="s2">&quot;MAC address xx:xx:xx:xx:xx (may also have &#39;-&#39; or &#39;.&#39; delimiters)&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convertToDate</span><span class="p">(</span><span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper to create a parse action for converting parsed date string to Python datetime.date</span>

<span class="sd">        Params -</span>
<span class="sd">         - fmt - format to be passed to datetime.strptime (default= ``&quot;%Y-%m-%d&quot;``)</span>

<span class="sd">        Example::</span>

<span class="sd">            date_expr = pyparsing_common.iso8601_date.copy()</span>
<span class="sd">            date_expr.setParseAction(pyparsing_common.convertToDate())</span>
<span class="sd">            print(date_expr.parseString(&quot;1999-12-31&quot;))</span>

<span class="sd">        prints::</span>

<span class="sd">            [datetime.date(1999, 12, 31)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">cvt_fn</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fmt</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">ve</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cvt_fn</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convertToDatetime</span><span class="p">(</span><span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">T%H:%M:%S.</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper to create a parse action for converting parsed</span>
<span class="sd">        datetime string to Python datetime.datetime</span>

<span class="sd">        Params -</span>
<span class="sd">         - fmt - format to be passed to datetime.strptime (default= ``&quot;%Y-%m-%dT%H:%M:%S.%f&quot;``)</span>

<span class="sd">        Example::</span>

<span class="sd">            dt_expr = pyparsing_common.iso8601_datetime.copy()</span>
<span class="sd">            dt_expr.setParseAction(pyparsing_common.convertToDatetime())</span>
<span class="sd">            print(dt_expr.parseString(&quot;1999-12-31T23:59:59.999&quot;))</span>

<span class="sd">        prints::</span>

<span class="sd">            [datetime.datetime(1999, 12, 31, 23, 59, 59, 999000)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">cvt_fn</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fmt</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">ve</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cvt_fn</span>

    <span class="n">iso8601_date</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;year&gt;\d</span><span class="si">{4}</span><span class="s1">)(?:-(?P&lt;month&gt;\d\d)(?:-(?P&lt;day&gt;\d\d))?)?&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;ISO8601 date&quot;</span><span class="p">)</span>
    <span class="s2">&quot;ISO8601 date (``yyyy-mm-dd``)&quot;</span>

    <span class="n">iso8601_datetime</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;year&gt;\d</span><span class="si">{4}</span><span class="s1">)-(?P&lt;month&gt;\d\d)-(?P&lt;day&gt;\d\d)[T ](?P&lt;hour&gt;\d\d):(?P&lt;minute&gt;\d\d)(:(?P&lt;second&gt;\d\d(\.\d*)?)?)?(?P&lt;tz&gt;Z|[+-]\d\d:?\d\d)?&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;ISO8601 datetime&quot;</span><span class="p">)</span>
    <span class="s2">&quot;ISO8601 datetime (``yyyy-mm-ddThh:mm:ss.s(Z|+-00:00)``) - trailing seconds, milliseconds, and timezone optional; accepts separating ``&#39;T&#39;`` or ``&#39; &#39;``&quot;</span>

    <span class="n">uuid</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[0-9a-fA-F]</span><span class="si">{8}</span><span class="s1">(-[0-9a-fA-F]</span><span class="si">{4}</span><span class="s1">)</span><span class="si">{3}</span><span class="s1">-[0-9a-fA-F]</span><span class="si">{12}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;UUID&quot;</span><span class="p">)</span>
    <span class="s2">&quot;UUID (``xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx``)&quot;</span>

    <span class="n">_html_stripper</span> <span class="o">=</span> <span class="n">anyOpenTag</span><span class="o">.</span><span class="n">suppress</span><span class="p">()</span> <span class="o">|</span> <span class="n">anyCloseTag</span><span class="o">.</span><span class="n">suppress</span><span class="p">()</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stripHTMLTags</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse action to remove HTML tags from web page HTML source</span>

<span class="sd">        Example::</span>

<span class="sd">            # strip HTML links from normal text</span>
<span class="sd">            text = &#39;&lt;td&gt;More info at the &lt;a href=&quot;https://github.com/pyparsing/pyparsing/wiki&quot;&gt;pyparsing&lt;/a&gt; wiki page&lt;/td&gt;&#39;</span>
<span class="sd">            td, td_end = makeHTMLTags(&quot;TD&quot;)</span>
<span class="sd">            table_text = td + SkipTo(td_end).setParseAction(pyparsing_common.stripHTMLTags)(&quot;body&quot;) + td_end</span>
<span class="sd">            print(table_text.parseString(text).body)</span>

<span class="sd">        Prints::</span>

<span class="sd">            More info at the pyparsing wiki page</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">_html_stripper</span><span class="o">.</span><span class="n">transformString</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">_commasepitem</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="o">~</span><span class="n">Literal</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
                                      <span class="o">+</span> <span class="o">~</span><span class="n">LineEnd</span><span class="p">()</span>
                                      <span class="o">+</span> <span class="n">Word</span><span class="p">(</span><span class="n">printables</span><span class="p">,</span> <span class="n">excludeChars</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                                      <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">White</span><span class="p">(</span><span class="s2">&quot; </span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">))))</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;commaItem&quot;</span><span class="p">)</span>
    <span class="n">comma_separated_list</span> <span class="o">=</span> <span class="n">delimitedList</span><span class="p">(</span><span class="n">Optional</span><span class="p">(</span><span class="n">quotedString</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                                  <span class="o">|</span> <span class="n">_commasepitem</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                                         <span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;comma separated list&quot;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Predefined expression of 1 or more printable words or quoted strings, separated by commas.&quot;&quot;&quot;</span>

    <span class="n">upcaseTokens</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">tokenMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()))</span>
    <span class="sd">&quot;&quot;&quot;Parse action to convert tokens to upper case.&quot;&quot;&quot;</span>

    <span class="n">downcaseTokens</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">tokenMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>
    <span class="sd">&quot;&quot;&quot;Parse action to convert tokens to lower case.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">_lazyclassproperty</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="vm">__doc__</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_intern&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_intern</span> <span class="ow">is</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">superclass</span><span class="p">,</span> <span class="s1">&#39;_intern&#39;</span><span class="p">,</span> <span class="p">[])</span>
                                              <span class="k">for</span> <span class="n">superclass</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_intern</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">attrname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">attrname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_intern</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_intern</span><span class="p">[</span><span class="n">attrname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_intern</span><span class="p">[</span><span class="n">attrname</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">unicode_set</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A set of Unicode characters, for language-specific strings for</span>
<span class="sd">    ``alphas``, ``nums``, ``alphanums``, and ``printables``.</span>
<span class="sd">    A unicode_set is defined by a list of ranges in the Unicode character</span>
<span class="sd">    set, in a class attribute ``_ranges``, such as::</span>

<span class="sd">        _ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]</span>

<span class="sd">    A unicode set can also be defined using multiple inheritance of other unicode sets::</span>

<span class="sd">        class CJK(Chinese, Japanese, Korean):</span>
<span class="sd">            pass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_chars_for_ranges</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cc</span> <span class="ow">is</span> <span class="n">unicode_set</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">for</span> <span class="n">rr</span> <span class="ow">in</span> <span class="n">cc</span><span class="o">.</span><span class="n">_ranges</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">unichr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ret</span><span class="p">))]</span>

    <span class="nd">@_lazyclassproperty</span>
    <span class="k">def</span> <span class="nf">printables</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="s2">&quot;all non-whitespace characters in this range&quot;</span>
        <span class="k">return</span> <span class="sa">u</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filterfalse</span><span class="p">(</span><span class="n">unicode</span><span class="o">.</span><span class="n">isspace</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_chars_for_ranges</span><span class="p">()))</span>

    <span class="nd">@_lazyclassproperty</span>
    <span class="k">def</span> <span class="nf">alphas</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="s2">&quot;all alphabetic characters in this range&quot;</span>
        <span class="k">return</span> <span class="sa">u</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">unicode</span><span class="o">.</span><span class="n">isalpha</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_chars_for_ranges</span><span class="p">()))</span>

    <span class="nd">@_lazyclassproperty</span>
    <span class="k">def</span> <span class="nf">nums</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="s2">&quot;all numeric digit characters in this range&quot;</span>
        <span class="k">return</span> <span class="sa">u</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">unicode</span><span class="o">.</span><span class="n">isdigit</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_chars_for_ranges</span><span class="p">()))</span>

    <span class="nd">@_lazyclassproperty</span>
    <span class="k">def</span> <span class="nf">alphanums</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="s2">&quot;all alphanumeric characters in this range&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">alphas</span> <span class="o">+</span> <span class="bp">cls</span><span class="o">.</span><span class="n">nums</span>


<span class="k">class</span> <span class="nc">pyparsing_unicode</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A namespace class for defining common language unicode_sets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">32</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxunicode</span><span class="p">)]</span>

    <span class="k">class</span> <span class="nc">Latin1</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Latin-1 Unicode Character Range&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x0020</span><span class="p">,</span> <span class="mh">0x007e</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x00a0</span><span class="p">,</span> <span class="mh">0x00ff</span><span class="p">),]</span>

    <span class="k">class</span> <span class="nc">LatinA</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Latin-A Unicode Character Range&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x0100</span><span class="p">,</span> <span class="mh">0x017f</span><span class="p">),]</span>

    <span class="k">class</span> <span class="nc">LatinB</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Latin-B Unicode Character Range&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x0180</span><span class="p">,</span> <span class="mh">0x024f</span><span class="p">),]</span>

    <span class="k">class</span> <span class="nc">Greek</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Greek Unicode Character Ranges&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="mh">0x0370</span><span class="p">,</span> <span class="mh">0x03ff</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1f00</span><span class="p">,</span> <span class="mh">0x1f15</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1f18</span><span class="p">,</span> <span class="mh">0x1f1d</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1f20</span><span class="p">,</span> <span class="mh">0x1f45</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1f48</span><span class="p">,</span> <span class="mh">0x1f4d</span><span class="p">),</span>
            <span class="p">(</span><span class="mh">0x1f50</span><span class="p">,</span> <span class="mh">0x1f57</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1f59</span><span class="p">,),</span> <span class="p">(</span><span class="mh">0x1f5b</span><span class="p">,),</span> <span class="p">(</span><span class="mh">0x1f5d</span><span class="p">,),</span> <span class="p">(</span><span class="mh">0x1f5f</span><span class="p">,</span> <span class="mh">0x1f7d</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1f80</span><span class="p">,</span> <span class="mh">0x1fb4</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1fb6</span><span class="p">,</span> <span class="mh">0x1fc4</span><span class="p">),</span>
            <span class="p">(</span><span class="mh">0x1fc6</span><span class="p">,</span> <span class="mh">0x1fd3</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1fd6</span><span class="p">,</span> <span class="mh">0x1fdb</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1fdd</span><span class="p">,</span> <span class="mh">0x1fef</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1ff2</span><span class="p">,</span> <span class="mh">0x1ff4</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1ff6</span><span class="p">,</span> <span class="mh">0x1ffe</span><span class="p">),</span>
        <span class="p">]</span>

    <span class="k">class</span> <span class="nc">Cyrillic</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Cyrillic Unicode Character Range&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x0400</span><span class="p">,</span> <span class="mh">0x04ff</span><span class="p">)]</span>

    <span class="k">class</span> <span class="nc">Chinese</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Chinese Unicode Character Range&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x4e00</span><span class="p">,</span> <span class="mh">0x9fff</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x3000</span><span class="p">,</span> <span class="mh">0x303f</span><span class="p">),]</span>

    <span class="k">class</span> <span class="nc">Japanese</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Japanese Unicode Character Range, combining Kanji, Hiragana, and Katakana ranges&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">class</span> <span class="nc">Kanji</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
            <span class="s2">&quot;Unicode set for Kanji Unicode Character Range&quot;</span>
            <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x4E00</span><span class="p">,</span> <span class="mh">0x9Fbf</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x3000</span><span class="p">,</span> <span class="mh">0x303f</span><span class="p">),]</span>

        <span class="k">class</span> <span class="nc">Hiragana</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
            <span class="s2">&quot;Unicode set for Hiragana Unicode Character Range&quot;</span>
            <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x3040</span><span class="p">,</span> <span class="mh">0x309f</span><span class="p">),]</span>

        <span class="k">class</span> <span class="nc">Katakana</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
            <span class="s2">&quot;Unicode set for Katakana  Unicode Character Range&quot;</span>
            <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x30a0</span><span class="p">,</span> <span class="mh">0x30ff</span><span class="p">),]</span>

    <span class="k">class</span> <span class="nc">Korean</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Korean Unicode Character Range&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0xac00</span><span class="p">,</span> <span class="mh">0xd7af</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1100</span><span class="p">,</span> <span class="mh">0x11ff</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x3130</span><span class="p">,</span> <span class="mh">0x318f</span><span class="p">),</span> <span class="p">(</span><span class="mh">0xa960</span><span class="p">,</span> <span class="mh">0xa97f</span><span class="p">),</span> <span class="p">(</span><span class="mh">0xd7b0</span><span class="p">,</span> <span class="mh">0xd7ff</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x3000</span><span class="p">,</span> <span class="mh">0x303f</span><span class="p">),]</span>

    <span class="k">class</span> <span class="nc">CJK</span><span class="p">(</span><span class="n">Chinese</span><span class="p">,</span> <span class="n">Japanese</span><span class="p">,</span> <span class="n">Korean</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for combined Chinese, Japanese, and Korean (CJK) Unicode Character Range&quot;</span>
        <span class="k">pass</span>

    <span class="k">class</span> <span class="nc">Thai</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Thai Unicode Character Range&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x0e01</span><span class="p">,</span> <span class="mh">0x0e3a</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x0e3f</span><span class="p">,</span> <span class="mh">0x0e5b</span><span class="p">),]</span>

    <span class="k">class</span> <span class="nc">Arabic</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Arabic Unicode Character Range&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x0600</span><span class="p">,</span> <span class="mh">0x061b</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x061e</span><span class="p">,</span> <span class="mh">0x06ff</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x0700</span><span class="p">,</span> <span class="mh">0x077f</span><span class="p">),]</span>

    <span class="k">class</span> <span class="nc">Hebrew</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Hebrew Unicode Character Range&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x0590</span><span class="p">,</span> <span class="mh">0x05ff</span><span class="p">),]</span>

    <span class="k">class</span> <span class="nc">Devanagari</span><span class="p">(</span><span class="n">unicode_set</span><span class="p">):</span>
        <span class="s2">&quot;Unicode set for Devanagari Unicode Character Range&quot;</span>
        <span class="n">_ranges</span> <span class="o">=</span> <span class="p">[(</span><span class="mh">0x0900</span><span class="p">,</span> <span class="mh">0x097f</span><span class="p">),</span> <span class="p">(</span><span class="mh">0xa8e0</span><span class="p">,</span> <span class="mh">0xa8ff</span><span class="p">)]</span>

<span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Japanese</span><span class="o">.</span><span class="n">_ranges</span> <span class="o">=</span> <span class="p">(</span><span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Japanese</span><span class="o">.</span><span class="n">Kanji</span><span class="o">.</span><span class="n">_ranges</span>
                                      <span class="o">+</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Japanese</span><span class="o">.</span><span class="n">Hiragana</span><span class="o">.</span><span class="n">_ranges</span>
                                      <span class="o">+</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Japanese</span><span class="o">.</span><span class="n">Katakana</span><span class="o">.</span><span class="n">_ranges</span><span class="p">)</span>

<span class="c1"># define ranges in language character sets</span>
<span class="k">if</span> <span class="n">PY_3</span><span class="p">:</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;العربية&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Arabic</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;中文&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Chinese</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;кириллица&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Cyrillic</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;Ελληνικά&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Greek</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;עִברִית&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Hebrew</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;日本語&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Japanese</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Japanese</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;漢字&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Japanese</span><span class="o">.</span><span class="n">Kanji</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Japanese</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;カタカナ&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Japanese</span><span class="o">.</span><span class="n">Katakana</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Japanese</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;ひらがな&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Japanese</span><span class="o">.</span><span class="n">Hiragana</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;한국어&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Korean</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;ไทย&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Thai</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">pyparsing_unicode</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;देवनागरी&quot;</span><span class="p">,</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Devanagari</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">pyparsing_test</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    namespace class for classes useful in writing unit tests</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">reset_pyparsing_context</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Context manager to be used when writing unit tests that modify pyparsing config values:</span>
<span class="sd">         - packrat parsing</span>
<span class="sd">         - default whitespace characters.</span>
<span class="sd">         - default keyword characters</span>
<span class="sd">         - literal string auto-conversion class</span>
<span class="sd">         - __diag__ settings</span>

<span class="sd">        Example:</span>
<span class="sd">            with reset_pyparsing_context():</span>
<span class="sd">                # test that literals used to construct a grammar are automatically suppressed</span>
<span class="sd">                ParserElement.inlineLiteralsUsing(Suppress)</span>

<span class="sd">                term = Word(alphas) | Word(nums)</span>
<span class="sd">                group = Group(&#39;(&#39; + term[...] + &#39;)&#39;)</span>

<span class="sd">                # assert that the &#39;()&#39; characters are not included in the parsed tokens</span>
<span class="sd">                self.assertParseAndCheckLisst(group, &quot;(abc 123 def)&quot;, [&#39;abc&#39;, &#39;123&#39;, &#39;def&#39;])</span>

<span class="sd">            # after exiting context manager, literals are converted to Literal expressions again</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;default_whitespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;default_keyword_chars&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Keyword</span><span class="o">.</span><span class="n">DEFAULT_KEYWORD_CHARS</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span>
                <span class="s2">&quot;literal_string_class&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;packrat_enabled&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_packratEnabled</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;packrat_parse&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_parse</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;__diag__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">__diag__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">__diag__</span><span class="o">.</span><span class="n">_all_names</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;__compat__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;collect_all_And_tokens&quot;</span><span class="p">:</span> <span class="n">__compat__</span><span class="o">.</span><span class="n">collect_all_And_tokens</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">def</span> <span class="nf">restore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># reset pyparsing global state</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span>
                <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;default_whitespace&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">setDefaultWhitespaceChars</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;default_whitespace&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">Keyword</span><span class="o">.</span><span class="n">DEFAULT_KEYWORD_CHARS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;default_keyword_chars&quot;</span><span class="p">]</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">inlineLiteralsUsing</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;literal_string_class&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;__diag__&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">__diag__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">_packratEnabled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;packrat_enabled&quot;</span><span class="p">]</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">_parse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;packrat_parse&quot;</span><span class="p">]</span>
            <span class="n">__compat__</span><span class="o">.</span><span class="n">collect_all_And_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_context</span><span class="p">[</span><span class="s2">&quot;__compat__&quot;</span><span class="p">]</span>

        <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

        <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>

    <span class="k">class</span> <span class="nc">TestParseResultsAsserts</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A mixin class to add parse results assertion methods to normal unittest.TestCase classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">assertParseResultsEquals</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">expected_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">expected_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Unit test assertion to compare a ParseResults object with an optional expected_list,</span>
<span class="sd">            and compare any defined results names with an optional expected_dict.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">expected_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">expected_list</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">asList</span><span class="p">(),</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expected_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">expected_dict</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">asDict</span><span class="p">(),</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">assertParseAndCheckList</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">test_string</span><span class="p">,</span> <span class="n">expected_list</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Convenience wrapper assert to test a parser element and input string, and assert that</span>
<span class="sd">            the resulting ParseResults.asList() is equal to the expected_list.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">test_string</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dump</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertParseResultsEquals</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expected_list</span><span class="o">=</span><span class="n">expected_list</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">assertParseAndCheckDict</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">test_string</span><span class="p">,</span> <span class="n">expected_dict</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Convenience wrapper assert to test a parser element and input string, and assert that</span>
<span class="sd">            the resulting ParseResults.asDict() is equal to the expected_dict.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">test_string</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dump</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertParseResultsEquals</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expected_dict</span><span class="o">=</span><span class="n">expected_dict</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">assertRunTestResults</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">run_tests_report</span><span class="p">,</span> <span class="n">expected_parse_results</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Unit test assertion to evaluate output of ParserElement.runTests(). If a list of</span>
<span class="sd">            list-dict tuples is given as the expected_parse_results argument, then these are zipped</span>
<span class="sd">            with the report tuples returned by runTests and evaluated using assertParseResultsEquals.</span>
<span class="sd">            Finally, asserts that the overall runTests() success value is True.</span>

<span class="sd">            :param run_tests_report: tuple(bool, [tuple(str, ParseResults or Exception)]) returned from runTests</span>
<span class="sd">            :param expected_parse_results (optional): [tuple(str, list, dict, Exception)]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">run_test_success</span><span class="p">,</span> <span class="n">run_test_results</span> <span class="o">=</span> <span class="n">run_tests_report</span>

            <span class="k">if</span> <span class="n">expected_parse_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">rpt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rpt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">expected</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">rpt</span><span class="p">,</span> <span class="n">expected</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">run_test_results</span><span class="p">,</span> <span class="n">expected_parse_results</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">test_string</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">expected</span> <span class="ow">in</span> <span class="n">merged</span><span class="p">:</span>
                    <span class="c1"># expected should be a tuple containing a list and/or a dict or an exception,</span>
                    <span class="c1"># and optional failure message string</span>
                    <span class="c1"># an empty tuple will skip any result validation</span>
                    <span class="n">fail_msg</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">expected</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="nb">str</span><span class="p">)),</span> <span class="kc">None</span>
                    <span class="p">)</span>
                    <span class="n">expected_exception</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">exp</span>
                            <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">expected</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)</span>
                        <span class="p">),</span>
                        <span class="kc">None</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">expected_exception</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span>
                            <span class="n">expected_exception</span><span class="o">=</span><span class="n">expected_exception</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">fail_msg</span> <span class="ow">or</span> <span class="n">msg</span>
                        <span class="p">):</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                                <span class="k">raise</span> <span class="n">result</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">expected_list</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">expected</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="nb">list</span><span class="p">)),</span> <span class="kc">None</span>
                        <span class="p">)</span>
                        <span class="n">expected_dict</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">exp</span> <span class="k">for</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">expected</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)),</span> <span class="kc">None</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">expected_list</span><span class="p">,</span> <span class="n">expected_dict</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">assertParseResultsEquals</span><span class="p">(</span>
                                <span class="n">result</span><span class="p">,</span>
                                <span class="n">expected_list</span><span class="o">=</span><span class="n">expected_list</span><span class="p">,</span>
                                <span class="n">expected_dict</span><span class="o">=</span><span class="n">expected_dict</span><span class="p">,</span>
                                <span class="n">msg</span><span class="o">=</span><span class="n">fail_msg</span> <span class="ow">or</span> <span class="n">msg</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># warning here maybe?</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no validation for </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">test_string</span><span class="p">))</span>

            <span class="c1"># do this last, in case some specific test results can be reported instead</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span>
                <span class="n">run_test_success</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span> <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;failed runTests&quot;</span>
            <span class="p">)</span>

        <span class="nd">@contextmanager</span>
        <span class="k">def</span> <span class="nf">assertRaisesParseException</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="o">=</span><span class="n">ParseException</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">exc_type</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">):</span>
                <span class="k">yield</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="n">selectToken</span>    <span class="o">=</span> <span class="n">CaselessLiteral</span><span class="p">(</span><span class="s2">&quot;select&quot;</span><span class="p">)</span>
    <span class="n">fromToken</span>      <span class="o">=</span> <span class="n">CaselessLiteral</span><span class="p">(</span><span class="s2">&quot;from&quot;</span><span class="p">)</span>

    <span class="n">ident</span>          <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="n">alphanums</span> <span class="o">+</span> <span class="s2">&quot;_$&quot;</span><span class="p">)</span>

    <span class="n">columnName</span>     <span class="o">=</span> <span class="n">delimitedList</span><span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">upcaseTokens</span><span class="p">)</span>
    <span class="n">columnNameList</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">delimitedList</span><span class="p">(</span><span class="n">columnName</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;columns&quot;</span><span class="p">)</span>
    <span class="n">columnSpec</span>     <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span> <span class="o">|</span> <span class="n">columnNameList</span><span class="p">)</span>

    <span class="n">tableName</span>      <span class="o">=</span> <span class="n">delimitedList</span><span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">upcaseTokens</span><span class="p">)</span>
    <span class="n">tableNameList</span>  <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">delimitedList</span><span class="p">(</span><span class="n">tableName</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;tables&quot;</span><span class="p">)</span>

    <span class="n">simpleSQL</span>      <span class="o">=</span> <span class="n">selectToken</span><span class="p">(</span><span class="s2">&quot;command&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">columnSpec</span><span class="p">(</span><span class="s2">&quot;columns&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">fromToken</span> <span class="o">+</span> <span class="n">tableNameList</span><span class="p">(</span><span class="s2">&quot;tables&quot;</span><span class="p">)</span>

    <span class="c1"># demo runTests method, including embedded comments in test string</span>
    <span class="n">simpleSQL</span><span class="o">.</span><span class="n">runTests</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        # &#39;*&#39; as column list and dotted table name</span>
<span class="s2">        select * from SYS.XYZZY</span>

<span class="s2">        # caseless match on &quot;SELECT&quot;, and casts back to &quot;select&quot;</span>
<span class="s2">        SELECT * from XYZZY, ABC</span>

<span class="s2">        # list of column names, and mixed case SELECT keyword</span>
<span class="s2">        Select AA,BB,CC from Sys.dual</span>

<span class="s2">        # multiple tables</span>
<span class="s2">        Select A, B, C from Sys.dual, Table2</span>

<span class="s2">        # invalid SELECT keyword - should fail</span>
<span class="s2">        Xelect A, B, C from Sys.dual</span>

<span class="s2">        # incomplete command - should fail</span>
<span class="s2">        Select</span>

<span class="s2">        # invalid column name - should fail</span>
<span class="s2">        Select ^^^ frox Sys.dual</span>

<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">number</span><span class="o">.</span><span class="n">runTests</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        100</span>
<span class="s2">        -100</span>
<span class="s2">        +100</span>
<span class="s2">        3.14159</span>
<span class="s2">        6.02e23</span>
<span class="s2">        1e-12</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># any int or real number, returned as float</span>
    <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">fnumber</span><span class="o">.</span><span class="n">runTests</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        100</span>
<span class="s2">        -100</span>
<span class="s2">        +100</span>
<span class="s2">        3.14159</span>
<span class="s2">        6.02e23</span>
<span class="s2">        1e-12</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">hex_integer</span><span class="o">.</span><span class="n">runTests</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        100</span>
<span class="s2">        FF</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">uuid</span>
    <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">uuid</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">tokenMap</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">))</span>
    <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">uuid</span><span class="o">.</span><span class="n">runTests</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        12345678-1234-5678-1234-567812345678</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Library Simplified Circulation Manager</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">circulation</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, The New York Public Library, Astor, Lenox, and Tilden Foundations.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>